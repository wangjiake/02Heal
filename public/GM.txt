所有命令前全部输入 //
static int gs_iIfPermitNonGMLogin = 0;//是否允许非GM角色登陆(在限制登录IP的情形下)


static TAUNT g_astTaunt[MONSTER_MAX_TAUNT];
static unsigned int ulRoleZID = 0;

static unsigned int gs_ulUinBegin = 0;
static unsigned int gs_ulUinEnd = 0;
static GMMAP g_astEntries[] =
{
	/* command,			function, 		permission needed,	args*/
	/****f* position/position
	*/
	/******/
	/****f* role/role
	*/
	/******/
	/****f* guild/guild
	*/
	/******/
	/****f* skill/skill
	*/
	/******/
	/****f* map/map
	*/
	/******/
	/****f* item/item
	*/
	/******/
	/****f* monster/monster
	*/
	/******/
	/****f* task/task
	*/
	/******/
	/****f* trade/trade
	*/
	/******/
	/****f* script/script
	*/
	/******/
	/****f* pet/pet
	*/
	/******/
	/****f* system/system
	*/
	/******/
	/****f* message/report
	*/
	/******/
	/****f* pworld/pworld
	*/
	/******/
	/****f* mail/mail
	*/
	/******/
	/****f* Wchat/Wchat
	*/
	/******/
	/****f* title/title
	*/
	/******/
	/****f* act/act
	*/
	/******/
	/****f* other/other
	*/
	/******/
	/****f* auth/auth
	*/
	/******/
	/****f* whitelist/whitelist
	*/
	/******/

	/****f* A使用说明/使用说明
	 * 名称
	 *   无
	 * 用法
	 *   请根据对应的模块，然后查找相关指令，点击进入后查看使用方法，其中<>内为参数，
	 * 用例
	 *   无
	 * 权限
	 */
	/******/

	
	/****f* position/goto --- 跳转地图
	 * 名称
	 *   goto -- 瞬移到某个地图
	 * 用法
	 * goto map_id <pos_x pos_y> -- map_id:地图ID 方括号中为可选参数,pos_x:坐标X,pos_y:坐标Y
	 * 用例
	 *   goto 7   瞬移到龙城
	 * 权限
	 */
	{"goto", 			gm_goto, 			GM_POWER_EIGHTH, 		NULL},
	/******/
	
	/****f* role/hugrole -- 拉角色
	 * 名称
	 *   hugrole --  把指定的角色拉到自己所在的位置
	 * 用法
	 * hugrole  uin <uin> | rolename <rolename> 
	 * 用例
	 *   hugrole uin 10001  拉到自己跟前 
	 * 权限
	 */
	{"hugrole", 			gm_hugrole, 			GM_POWER_EIGHTH, 		NULL},
	/******/

	/****f* role/block -- 封角色或者封帐号 
	 * 名称
	 *  block -- 封角色或者封帐号 
	 * 用法
	 *   block acc <uin> <time> <reason> 
	 *   block role <nick> <uin> <time> <reason>
	 * 用例
	 *   block acc  4428  18000 无
	 *   block role tiger 4428 18000 无
	 * 权限
	 */
	{"block", 			gm_block, 			GM_POWER_SIXTH, 		NULL},
	/******/

	/****f* role/muterole -- 禁言角色 
	 * 名称
	 *  muterole -- 禁言角色 
	 * 用法
	 * muterole uin <uin> <time>/ rolename <rolename> <time>
	 * 用例
	 *   muterole uin 10001  100 
	 * 权限
	 */
	{"muterole", 			gm_muterole, 			GM_POWER_EIGHTH, 		NULL},
	/******/

	/****f* role/unmuterole -- 解除禁言角色 
	 * 名称
	 *  unmuterole -- 解除禁言角色 
	 * 用法
	 * unmuterole uin <uin> / rolename <rolename> 
	 * 用例
	 *   unmuterole uin 10001 
	 * 权限
	 */
	{"unmuterole", 			gm_unmuterole, 			GM_POWER_SEVENTH, 		NULL},
	/******/
	
	/****f* role/catchrole -- 把角色送到其地图的复活点 
	 * 名称
	 *  catchrole -- 把角色送到地图复活点 
	 * 用法
	 * catchrole <rolename>
	 * 用例
	 *   catchrole kavin   
	 * 权限
	 */
	{"catchrole", 			gm_catchrole, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addluckyvalue -- 加好友间的缘分度 
	 * 名称
	 *  addluckyvalue -- 加好友间的缘分度 
	 * 用法
	 * addluckyvalue SrcUin DesUin LuckyValue
	 * 用例
	 *   addluckyvalue SrcUin DesUin LuckyValue   
	 * 权限
	 */
	{"addluckyvalue", 			gm_addluckyvalue, 			GM_POWER_FOURTH, 		NULL},
	/******/

	 /****f* role/marry -- 结婚相关
	 * 名称
	 *   marry --  结婚相关GM
	 * 用法
	 *marry makecouple <qq1> <qq2>
	 *marry clearflowdata
	 *marry addlovevalue <num>
	 *marry setauctiontimes <num>
	 *marry resetparadetime <time>
	 *marry resetmarrydata
	 *marry registernum <num>
	 *marry bidmarrytime <time> <price> <qq>
	 */
	{"marry", 			gm_marry, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/wofvip -- 幻世VIP相关
	 * 名称
	 *   wofvip -- 幻世VIP相关GM
	 * 用法
	 *  wofvip renewal days //续期
	 *  wofvip goldcoin value //加小金币
	 *  wofvip acce actid //活动替身加速
	 *
	 *
	 *
	 */
	{"wofvip", 			gm_wofvip, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/clear_recent_bid_sold_list -- 清最近售卖列表(竞价商城) 
	 * 名称
	 *  clear_recent_bid_sold_list -- 清最近售卖列表(竞价商城) 
	 * 用法
	 *  clear_recent_bid_sold_list
	 * 用例
	 *  clear_recent_bid_sold_list   
	 * 权限
	 */
	{"clear_recent_bid_sold_list", 			gm_clear_recent_bid_sold_list, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/confine_non_gm_login -- 设置是否允许非GM角色登录(在限制登录IP的情形下) 
	 * 名称
	 *  confine_non_gm_login -- 设置是否允许非GM角色登录(在限制登录IP的情形下) 
	 * 用法
	 *  confine_non_gm_login get/set [flag]
	 * 用例
	 *  confine_non_gm_login  set 1
	 * 权限
	 */
	{"confine_non_gm_login", 			gm_confine_non_gm_login, 			GM_POWER_FOURTH, 		NULL},
	/******/
	
	/****f* role/changementorvalue -- 改变师缘度
	 * 名称
	 *  changementorvalue -- 改变师缘度 
	 * 用法
	 *  changementorvalue TargetUin MentorValue
	 * 用例
	 *  changementorvalue 4266 10   
	 * 权限
	 */
        {"changementorvalue",                   gm_changementorvalue,                   GM_POWER_FOURTH,                NULL},
        /******/

	/****f* role/charmbackup -- 威望列表备份 
	 * 名称
	 *  charmbackup -- 威望列表备份 
	 * 用法
	 *  charmbackup
	 * 用例
	 *  charmbackup    
	 * 权限
	 */
	/*{"charmbackup", 			gm_charm_backup, 			GM_POWER_NORMAL, 		NULL},*/
	/******/
	
	/****f* role/addcharm --  给角色添加威望值 
	 * 名称
	 *  addcharm --  给角色添加威望值(可加可减) 
	 * 用法
	 * addcharm <charmvalue> 
	 * 用例
	 *  addcharm 1000 
	 * 权限
	 */
	{"addcharm", 			gm_addcharm, 			GM_POWER_FOURTH , 		NULL},
	/******/

	/****f* role/promotepet --  自定义参数进行宠物属性提升 -- 当前激活宠物
	 * 名称
	 *  promotepet --  自定义参数进行宠物属性提升 -- 当前激活宠物
	 * 用法
	 * promotepet <宠物品质1-5> <宠物强化等级1-9> <宠物服用资质果实次数1-3>
	 * 用例
	 *  promotepet 1 1 1 
	 * 权限
	 */
	{"promotepet", 			gm_promotepet, 			GM_POWER_FOURTH , 		NULL},
	/******/

	/****f* role/reducedclient 
	 * 名称
	 * reducedclient 更新精简资源 
	 * 用法
	 * changepetlifespan [0|1] 1 2 3 
	 * 用例
	 * changepetlifespan [0|1] 1 2 3 
	 * 权限
	 */
	{"reducedclient", 			gm_reducedclient, 			GM_POWER_FOURTH , 		NULL},
	/******/

	/****f* role/changepetlifespan --  改变当前激活宠物的寿命值 
	 * 名称
	 *  changepetlifespan --  改变当前激活宠物的寿命值(可加可减) 
	 * 用法
	 * changepetlifespan <changevalue> (changevalue >0 增加 changevalue <0 减少) (需要在宠物自身的0~maxlifespan之间) 
	 * 用例
	 *  changepetlifespan 1000 
	 * 权限
	 */
	{"changepetlifespan", 			gm_change_pet_life_span, 			GM_POWER_FOURTH , 		NULL},
	/******/

	/****f* role/changepetlifespanmax --  改变当前激活宠物的寿命值上限 
	 * 名称
	 *  changepetlifespanmax --  改变当前激活宠物的寿命值上限(可加可减) 
	 * 用法
	 * changepetlifespanmax <changevalue> (changevalue >0 增加 changevalue <0 减少) (需要大于当前值) 
	 * 用例
	 *  changepetlifespanmax 1000 
	 * 权限
	 */
	{"changepetlifespanmax", 			gm_change_pet_life_span_max, 			GM_POWER_FOURTH , 		NULL},
	/******/

	/****f* map/roleinfo -- 查询地图的对象数目
	 * 名称
	 * roleinfo-- 查询当前地图上的对象数目
	 * 用法
	 * roleinfo
	 * 用例
	 * 权限
	 */
	{"roleinfo",               gm_show_role_info,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/dumprole -- 导出角色信息到文件
	 * 名称
	 * dumprole-- 把role信息打包度门票到log或xml文件 
	 * 用法
	 * dumprole -- dumprole [uin [xml|log] ]
	 * 用例
	 * 权限
	 */
	{"dumprole",               gm_dumprole,			GM_POWER_FOURTH,		NULL},
	/******/

	

	/****f* role/findrole -- 查询角色详细信息 
	 * 名称
	 * findrole -- 根据角色名或者UIN 查询其他角色的详细信息 
	 * 用法
	 * findrole --findrole uin <uin> / rolename <name> 
	 * 用例
	 * 权限
	 */
	{"findrole",               gm_findrole,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/notifyplaytime -- 通知客户端玩家此次游戏时间 
	 * 名称
	 * notifyplaytime -- 设置玩家游戏时间然后通知客户端 这个时间不是实际的游戏时间 
	 * 用法
	 * notifyplaytime --notifyplaytime uin iHour 
	 * 用例
	 * 权限
	 */
	{"notifyplaytime",               gm_set_play_time,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* map/clear_monster -- 清除地图怪物
	 * 名称
	 * clear_monster-- 直接杀死怪物
	 * 用法
	 * clear_monster mode --<all 清除整个当前地图的怪， mon $id 杀死指定怪物，没模式，清空视野内的> 
	 * 用例
	 * 权限
	 */
	{"clear_monster",               gm_clear_monster,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* map/gm_clear_visionitem -- 清除视野内的物品
	 * 名称
	 * gm_clear_visionitem-- 清除视野内的物品
	 * 用法
	 * gm_clear_visionitem 
	 * 用例
	 * 权限
	 */
	{"clearvisionitem",               gm_clear_visionitem,			GM_POWER_FOURTH,		NULL},
	/******/
	

	/****f* map/queryobj -- 查询当前地图上的对象数目
	 * 名称
	 * queryobj -- 查询当前地图上的对象数目
	 * 用法
	 * queryobj objtype -- objtype :
	 * 用例
	 * 权限
	 */
	{"queryobj",               gm_query_obj,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* map/querynear  -- 查询角色周围玩家
	 * 名称
	 * querynear -- 查询角色周围3*3屏幕范围的玩家列表 
	 * 用法
	 * querynear 
	 * 用例
	 * 权限
	 */
	{"querynear",               gm_query_near,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/roleupgrade -- 角色手动升级 
	 * 名称
	 * roleupgrade -- 角色手动升级 
	 * 用法
	 * roleupgrade <uin/ or empty> 
	 * 用例
	 * 权限
	 */
	{"roleupgrade",               gm_role_upgrade,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/queryspecstat  -- 查询角色特殊状态 
	 * 名称
	 * queryspecstat -- 查询角色身上当前带的特殊状态 
	 * 用法
	 * queryspecstat 
	 * 用例
	 * 权限
	 */
	{"queryspecstat",               gm_query_role_specstat,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* map/querymon  -- 查询地图上的怪物
	 * 名称
	 * querymon -- $monsterid =0查询当前地图上的怪物 ,指定其他怪物ID
	 * 用法
	 * querymon 
	 * 用例
	 * 权限
	 */
	{"querymon",               gm_query_monster,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* map/querynpc -- 查询地图上的NPC
	 * 名称
	 * querynpc -- 查询当前地图上的NPC
	 * 用法
	 * querynpc 
	 * 用例
	 * 权限
	 */
	{"querynpc",               gm_query_npclist,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* item/item -- 创建物品（直接掉落背包）
	 * 名称
	 *   item -- 创建物品（直接掉落背包）
	 * 用法
	 * item id <num> <genattrid> -- id:物品或卡片或装备ID <num> 创建个数 <genattrid>:如果是常规装备需要提供装备生成的属性ID
	 * 用例
	 *   //item   11300001   -- 创建一把千锤百炼剑的定值装备
	 * 用例2
	 *   //item   12500001   -- 创建一把劣质铁剑的特殊装备
	 * 用例3
	 *   //item   10102001  1 100  -- 按产生装备的属性库ID 100 来产生一把铜斧头的常规装备 <属性参考:fo2_armattr_genlib.xml>
	 * 用例4
	 *   //item   20800001          -- 创建一个一等的布料
	 * 用例5
	 *   //item   20310001          -- 创建一个一等灰狼卡片
	 * 权限
	 */
	{"item",		gm_item, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* item/createitem  -- 创建物品（掉落地图）
	 * 名称
	 *   createitem -- 创建物品（掉落地图）
	 * 用法
	 * createitem id <num> <genattrid> -- id:物品或卡片或装备ID <num> 创建个数 <genattrid>:如果是常规装备需要提供装备生成的属性ID
	 * 用例
	 *   //createitem   11300001   -- 创建一把千锤百炼剑的定值装备
	 * 用例2
	 *   //createitem   12500001   -- 创建一把劣质铁剑的特殊装备
	 * 用例3
	 *   //createitem   10102001  1 1009  -- 按产生装备的属性库ID 1009 来产生一把铜斧头的常规装备
	 * 用例4
	 *   //createitem   20800001          -- 创建一个一等的布料
	 * 用例5
	 *   //createitem   20310001          -- 创建一个一等灰狼卡片
	 * 权限
	 */
	{"createitem",		gm_createitem, 		GM_POWER_FOURTH, 		NULL},
	/******/


	/****f* item/itemattr -- 修改物品的属性
	 * 名称
	 *   itemattr -- 修改物品的属性
	 * 用法
	 * itemattr ListType BagIndex ItemIndex attrtype attrvalue 
	 *         [attrtype 属性类型
	 *         0= 设置装备的耐久度 
	 *		   1= 查询装备的耐久度 
	 *		   2= 设置装备属主名 
	 *		   3= 查看计时装备剩余的秒数 
	 *		   4= 修改精炼次数 
	 *		   5= 修改装备的孔数 
	 *		   6= 修改大药品属性值
	 *		   7= 设置物品交易冷却时间 
	 *		   8= 拆解指定装备 
	 *		   9= 改装备品质:1,上品；2,绝品 
	 *		   10= 改天赐属性,name, value  
	 *		   11= 装备升级, 新装备ID 
	 *		   12= 修改装备祝福点 +9祝福点 +11祝福点 +13祝福点
	 *         13= 设置物品强制交易冷却时间
	 *         14= 查询宠物装备的耐久度
	 *         15= 修改宠物装备的耐久度
	 *         16= 设置战魂系数: attrvalue: 531 修改战魂系数(5个140,3个130,1个120)
	 *		   attrtype 属性类型]
	 * 用例
	 *   //itemattr 1 0 0 0 30
	 * 权限
	 */
	{"itemattr",		gm_item_attr, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* item/itemunlocktime -- 修改物品的解锁时间
	 * 名称
	 *   itemunlocktime -- 修改物品的解锁时间
	 * 用法
	 * itemunlocktime [destuin <uin> / destname <name> / destzid <zid>] ListType BagIndex ItemIndex time 
	 *          可以用uin、name、zid三种方式指定指定目标角色，随后三个字段是物品在该角色身上的位置，最后一字段是把解锁时间改成n秒之后
	 * 用例
	 *   //itemunlocktime destuin 4298 1 0 0 30  将QQ号为4298的角色背包中第一个物品的解锁时间改成30秒以后
	 * 权限
	 */
	{"itemunlocktime",		gm_itemunlocktime, 		GM_POWER_FOURTH, 		NULL},
	/******/
	
	/****f* item/ride  -- 坐骑操作
	 * 名称
	 *   ride -- 坐骑操作
	 * 用法
	 * itemattr optype (ListType BagIndex ItemIndex)
	 *          [optype 操作类型，0=乘骑  1= 取消乘骑 2 仅打印下当前速度]  ()为位置号，不输入默认为背包中的第一个位置
	 * 用例
	 *   //ride 0 1 0 0 
	 * 权限
	 */
	{"ride",		gm_ride, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* script/execscript -- 执行脚本
	 * 名称
	 *   execscript -- 执行脚本
	 * 用法
	 * execscript scriptname funcname param1 param2 param3
	 * 用例
	 *   //execscript test_script test_func
	 * 权限
	 */
	{"execscript",	gm_execscript,		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* script/reloadscript -- 重载全部脚本
	 * 名称
	 *   reloadscript -- 重载全部脚本
	 * 用法
	 * reloadscript
	 * 用例
	 *   //reloadscript
	 * 权限
	 */
	{"reloadscript",	gm_reloadscript,		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/actserial -- 执行动作序列
	 * 名称
	 *   actserial -- 执行动作序列
	 * 用法
	 * actserial iActSerialID
	 * 用例
	 *   //actserial 1
	 * 权限
	 */
	{"actserial",	gm_actserial,		GM_POWER_FOURTH,		NULL},
	/******/
	
	/****f* role/roleactdata -- 角色活动数据
	 * 名称
	 *	 roleactdata -- 活动数据
	 * 用法
	 * roleactdata force type actid varid value   force:强制设置，仅100为有效; type:0set1get(当force有效时为偏移0开始)； actid:活动ID; varid:变量ID； value:变量值
	 * 用例
	 *	 //roleactdata 100 0 1 20 33  强制将位置0的活动ID设为1， 20号变量设成33
	 *	 //roleactdata 0 0 1 20 33    将活动1的20号变量设成33
	 *	 //roleactdata 0 1 1 20       读活动1的20号变量
	 * 权限
	 */
	{"roleactdata", gm_role_act_data,		GM_POWER_FOURTH, 	NULL},
	/******/
	
	/****f* act/commactdata -- 共用活动数据
	 * 名称
	 *	 commactdata -- 活动数据
	 * 用法
	 * commactdata type actid varid value   type:0set1get(当force有效时为偏移0开始)； actid:活动ID; varid:变量ID； value:变量值
	 * 用例
	 *	 //commactdata 0 1 20 33	  将活动1的20号变量设成33
	 *	 //commactdata 1 1 20 	       读活动1的20号变量
	 * 权限
	 */
	{"commactdata", gm_comm_act_data,		GM_POWER_FOURTH, 	NULL},
	/******/
	
	/****f* act/commdata_info -- 充值积分活动排名查询
	 * 名称
	 *	 commdata_info -- 活动数据
	 * 用法
	 * commdata_info actid  cmdid  param 
	 * 用例
	 *	//commdata_info 60 1 20   查询前20名的积分活动排名玩家信息	
	 *	//commdata_info 60 2      查询角色当前的积分
	 *	//commdata_info 60 3 100  加充值积分
	 *  //commdata_info 60 4      清除排名
	 *	//commdata_info 60 5 4424 100 [是否入榜可选 0不入 非0则入 默认值1] 给QQ为4424的本服在线角色加100充值积分
	 * 权限
	 */
	{"commdata_info", gm_commdata_info,		GM_POWER_FOURTH, 	NULL},
	/******/

	/****f* pworld/respworldact -- 执行动作序列
	 * 名称
	 *	 respworldact -- 修改副本活动资源
	 * 用法
	 * respworldact ActID(活动ID) enterlimit [VAL(进入次数,不填返回当前值)]
	 * 用例
	 *	 //respworldact 1  enterlimit 6   将五子进入次数改成6次
	 * 权限
	 */
	{"respworldact",	gm_res_pworld_minigame,		GM_POWER_FOURTH, 	NULL},
	/******/

	/****f* item/resattr -- 修改物品资源的属性
	 * 名称
	 *   resattr -- 修改物品的属性
	 * 用法
	 * resattr resid attrtype attrvalue1,2...
	 *          [attrtype 属性类型，0=限时道具的时间和时长，参数1类型，参数值]
	 * 用例
	 *   //resattr 20100001 0 1 30
	 * 权限
	 */
	{"resattr",		gm_res_attr, 		GM_POWER_FOURTH, 		NULL},
	
	/******/

	/****f* item/clearbag -- 清空背包
	 * 名称
	 *   clearbag -- 清空普通物品栏内所有物品
	 * 用法
	 * clearbag
	 * 用例
	 *   //clearbag
	 * 权限
	 *
	 *
	 */
	{"clearbag",		gm_clearbag, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* monster/createmonster -- 创建怪物
	 * 名称
	 *   createmonster -- 创建怪物
	 * 用法
	 * createmonster id num  norefresh listid dir group
	 * 用例
	 *   createmonster 3 1 1 1 0 -1
	 * 权限
	 */
	{"createmonster", 	gm_createmonster,	GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* monster/createnpc -- 创建NPC
	 * 名称
	 *   createnpc  --- 根据NPCID 创建一个NPC出来
	 * 用法
	 *   createnpc  npcid 
	 * 用例
	 *   craatenpc 1   
	 * 权限
	 */
	{"createnpc", 	gm_createnpc,	GM_POWER_FOURTH, 		NULL},
	/******/

	
	/****f* role/addxp -- 增加经验
	 * 名称
	 *   addxp -- 增加经验
	 * 用法
	 * addxp xp_value
	 * 用例
	 *   addxp 200
	 * 权限
	 */
	{"addxp", 			gm_addxp, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addvigour -- 增加天地元气
	 * 名称
	 *   addvigour heaven\earth value-- 增加天地元气 value可正可负
	 * 用法
	 *   addvigour heaven\earth value
	 * 用例
	 *   addvigour heaven\earth 200
	 * 权限
	 */
	{"addvigour", 			gm_addvigour, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addtp -- 增加当前激活的法宝的灵力
	 * 名称
	 *   addtp value-- 增加当前激活的法宝的灵力 value可正可负
	 * 用法
	 *   addtp value
	 * 用例
	 *   addtp 200
	 * 权限
	 */
	{"addtp", 			gm_addtp, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addessence -- 增加精华当前值
	 * 名称
	 *   addessence value-- 增加精华当前值 value可正可负
	 * 用法
	 *   addessence value
	 * 用例
	 *   addessence 200
	 * 权限
	 */
	{"addessence", 			gm_addessence, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/trumpuncd -- 取消法宝激活CD
	 * 名称
	 *   trumpuncd -- 取消法宝激活CD
	 * 用法
	 *   trumpuncd
	 * 用例
	 *   trumpuncd
	 * 权限
	 */
	{"trumpuncd", 			gm_trumpuncd, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addskillpoints -- 改变当前激活法宝的技能点
	 * 名称
	 *   addskillpoints value -- 改变当前激活法宝的技能点 value可正可负
	 * 用法
	 *   addskillpoints value
	 * 用例
	 *   addskillpoints -2
	 * 权限
	 */
	{"addskillpoints", 			gm_addskillpoints, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addrefinelevel -- 改变当前激活法宝的祭炼等级
	 * 名称
	 *   addrefinelevel value -- 改变当前激活法宝的祭炼等级 value可正可负
	 * 用法
	 *   addrefinelevel value
	 * 用例
	 *   addrefinelevel -2
	 * 权限
	 */
	{"addrefinelevel", 			gm_addrefinelevel, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/setspeed -- 增加速度
	 * 名称
	 *   setspeed --  修改角色移动速度( 单独提出来可以单独控制权限) 
	 * 用法
	 * setspeed <speed> 
	 * 用例
	 *  setspeed 200 
	 * 权限
	 */
	{"setspeed", 			gm_setspeed, 			GM_POWER_EIGHTH, 		NULL},
	/******/


	/****f* role/addhp -- 增加生命
	 * 名称
	 *   addhp -- 增加当前生命
	 * 用法
	 * addhp hp_value
	 * 用例
	 *   addhp 50
	 * 权限
	 */
	{"addhp",			gm_addhp,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/changetianyuanvalue -- 改变天缘值
	 * 名称
	 *   changetianyuanvalue -- 改变天缘值
	 * 用法
	 * changetianyuanvalue changevalue
	 * 用例
	 *   changetianyuanvalue 50
	 * 权限
	 */
	{"changetianyuanvalue",			gm_changetianyuanvalue,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/changediyuanvalue -- 改变地缘值
	 * 名称
	 *   changediyuanvalue -- 改变地缘值
	 * 用法
	 * changediyuanvalue changevalue
	 * 用例
	 *   changediyuanvalue 50
	 * 权限
	 */
	{"changediyuanvalue",			gm_changediyuanvalue,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/changecharmingvalue -- 改变魅力度
	 * 名称
	 *   changecharmingvalue -- 改变魅力值
	 * 用法
	 * changecharmingvalue changevalue
	 * 用例
	 *   changecharmingvalue 50
	 * 权限
	 */
	{"changecharmingvalue",			gm_changecharmingvalue,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/changefamousvalue -- 改变知名度
	 * 名称
	 *   changefamousvalue -- 改变天缘值
	 * 用法
	 * changefamousvalue changevalue
	 * 用例
	 *   changefamousvalue 50
	 * 权限
	 */
	{"changefamousvalue",			gm_changefamousvalue,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addrelationer -- 增加关系人
	 * 名称
	 *   addrelationer -- 增加关系人
	 * 用法
	 * addrelationer targetuin mainrelation secondrelation
	 * 用例
	 *   addrelationer 4266 0-2 0-8
	 * 权限
	 */
	{"addrelationer",			gm_addrelationer,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/ripenfruit -- 催熟仙果
	 * 名称
	 *   ripenfruit -- 催熟仙果
	 * 用法
	 * ripenfruit time
	 * 用例
	 *   ripenfruit 10
	 * 权限
	 */
	{"ripenfruit",			gm_ripenfruit,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* test/richflag --  图标测试
	 * 名称
	 *   ripenfruit -- 图标测试
	 * 用法
	 * richflag get/save uin [value]
	 * 用例
	 *   richflag save 4166 2
	 * 权限
	 */
	{"richflag",			gm_richflag,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* test/vip --  vip测试
	 * 名称
	 *   vip -- vip测试
	 * 用法
	 * vip s[g]etmember [value]
	 * vip s[g]etpink [value]
	 * vip s[g]etblue [value]
	 * vip s[g]etsuperqq [value]
	 * vip s[g]etmonthdonate [value]
	 * 用例
	 *   vip setmember 2
	 *   vip getmember
	 * 权限
	 */
	{"vip",			gm_vip,			GM_POWER_FOURTH, 		NULL},
	/******/



	/****f* role/addrepu --- 增加声望
	 * 名称
	 *   addrepu -- 增加当前声望
	 * 用法
	 *   addrepu repu_id repu_value
	 * 用例
	 *   addrepu 2 50
	 * 权限
	 */
	{"addrepu",			gm_addrepu,			GM_POWER_FOURTH, 		NULL},
	/******/
	
	/****f* role/addmp -- 增加法力
	 * 名称
	 *   addmp -- 增加当前法力
	 * 用法
	 *   addmp mp_value
	 * 用例
	 *   addmp 50
	 * 权限
	 */
	{"addmp",			gm_addmp,			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/addlp -- 增加属性点
	 * 名称
	 *   addlp -- 增加剩余属性点
	 * 用法
	 *   addlp lp_value
	 * 用例
	 *   addlp 5
	 * 权限
	 */
	{"addlp",			gm_addlp,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/addep -- 增加EP
	 * 名称
	 *   addep -- 增加EP
	 * 用法
	 *   addep sp_value
	 * 用例
	 *   addep 5
	 * 权限
	 */
	{"addep",			gm_addep,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f* role/addsp -- 增加技能点
	 * 名称
	 *   addsp -- 增加技能点
	 * 用法
	 *   addsp sp_value
	 * 用例
	 *   addsp 5
	 * 权限
	 */
	{"addsp",			gm_addsp,			GM_POWER_FOURTH,		NULL},
	/******/

	/****f*  role/addminattack -- 增加最小物理攻击
	  * 名称
	  *   addminattack -- 增加最小物理攻击 用于打怪打不过时加强力量
	  * 用法
	  *   addminattack <MiniAtk>
	  * 用例
	  *   //addminattack 100   -- 最小攻击加强100点
	  * 权限
	  */
	{"addminattack",     gm_addminattack,   	GM_POWER_FOURTH,      NULL},
	/******/

	/****f*  role/addattr -- 增加属性
	  * 名称
	  *   addattr -- 增加指定属性，改二次偏移
	  * 用法
	  *   addattr <type> <value>
	  * 用例
	  *   //addattr 15 10   -- 暴击加10点
	  * 权限
	  */
	{"addattr",     gm_addattr,   	GM_POWER_FOURTH,      NULL},
	/******/

	/****f*  role/addpetattr -- 增加属性
	  * 名称
	  *   addpetattr -- 增加当前宠物指定属性，改二次偏移
	  * 用法
	  *   addpetattr <type> <value>
	  * 用例
	  *   //addpetattr 15 10   -- 暴击加10点
	  * 权限
	  */
	{"addpetattr",     gm_addpetattr,   	GM_POWER_FOURTH,      NULL},
	/******/
	
	/****f*  role/setlevel --设置角色等级
	  * 名称
	  *   //setlevel -- 设置角色等级，只增不减
	  * 用法
	  *   setlevel <RoleLevel>
	  * 用例
	  *   //setlevel 20   -- 设置角色等级为20级
	  * 权限
	  */
	{"setlevel",     gm_setlevel,   	GM_POWER_FOURTH,      NULL},
	/******/

	/****f*  role/addmoney --  加钱
	  * 名称
	  *  //addmoney --  加钱
	  * 用法
	  *   addmoney <Money> <moneycerti> <gold> <goldcerti>
	  * 用例
	  *   //addmoney 1000   -- 增加1000银两
	  * 权限
	  */
	{"addmoney",        gm_addmoney,      	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* role/camp -- 修改阵营
	 * 名称
	 *   camp -- 阵营API
	 * 用法
	 *   camp optype campid  optype=0 获得角色阵营， =1 设置角色阵营，=2 设置队伍的阵营 =3 设置整个地图阵营
	 * 用例
	 *   camp 1 2 
	 * 权限
	 */
	{"camp", 			gm_camp, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* map/fly -- 飞行
	 * 名称
	 *   fly -- 飞行
	 * 用法
	 *   fly iFlyID 飞行ID
	 * 用例
	 *   fly 1 
	 * 权限
	 */
	{"fly", 			gm_fly, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* system/logctrl -- 日志控制
	 * 名称
	 *   logctrl -- 日志控制
	 * 用法
	 * logctrl level DEBUG(日志洁白)
     *    logctrl module 模块ID(模块ID见LOG_MODULE_XXX宏) 值(0,1打开)
	 * 用例
	 *   logctrl level DEBUG 
	 	logctrl module 0 1 - 全部都开， 
	 * 权限
	 */
	{"logctrl", 			gm_logctrl, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* system/glory --  排行榜
	 * 名称
	 *   glory -- 排行榜相关GM
	 * 用法
	 * glory shift <Time1> <Time2>进行排行榜的切换，所有GM不参与排行
	 *	glory gmshift <Time1> <Time2>进行排行榜的切换,GM角色和家族也参与排行
   	 *	glory dump [Type] 导出Type类型的排行榜到文件中，如果不指定Type则到处所有排行榜
   	 *	glory time [Type] 查看本服排行榜的生成时间
   	 *	glory del [Type] [Pos] 删除本服的Type排行榜的第Pos个位置的角色。Pos从1到最大值,【注意:a.删除第一个之后，第二个就会成为第一个，b.只清除内存，不清除DB,停机重启后恢复】
   	 *	glory delall [Type] 清除本服Type类型的所有排行榜，【注意:a.只清除内存，不清除DB,停机重启后恢复】
	 * 用例
	 *   glory shift 10 30 
	 * 权限
	 */
	{"glory", 			gm_glory, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* pet/createpet --创建宠物
	 * 名称
	 *	 createpet -- 制造一只指定的宠物，放入背包
	 * 用法
	 *	 createpet <PetResID>
	 * 用例
	 *	createpet 21202001  :创建一只resid为21202001的宠物物品
	 * 权限
	 */
	{"createpet",    gm_createpet,    	GM_POWER_FOURTH,     NULL},
	/******/

	/****f* pet/washpet --洗宠物
	 * 名称
	 *	 washpet -- 洗一只指定的宠物
	 * 用法
	 *     washpet 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *	washpet 33 -1 2
	 *洗位于宠物栏的第三个宠物
	 * 权限
	 */
	{"washpet",     gm_washpet,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/washaptitude --洗资质
	 * 名称
	 *	 washaptitude -- 洗一只指定的宠物的资质
	 * 用法
	 *     washaptitude 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *	washaptitude 33 -1 2
	 *   洗位于宠物栏的第三个宠物的资质
	 * 权限
	 */
	{"washaptitude",     gm_washaptitude,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/maxpetaptitude --将宠物某一项资质达到最大
	 * 名称
	 *	 maxpetaptitude -- 将一只指定的宠物的某一资质达到最大
	 * 用法
	 *     maxpetaptitude <宠物栏里的位置> <资质>
	 *     位置:宠物栏里的具体位置，从0开始计数
	 * 用例
	 *	maxpetaptitude 2 Bld
	 *   洗位于宠物栏的第三个宠物的气血资质以使其达到最大
	 * 权限
	 */
	{"maxpetaptitude",     gm_maxpetaptitude,    	GM_POWER_FOURTH,      NULL},
	/******/
	
	/****f* pet/domespet --驯服宠物
	 * 名称
	 *	 domespet -- 驯服一只指定的宠物以提升其忠诚度
	 * 用法
	 *     domespet 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *domespet 33 -1 2
	 *驯服位于宠物栏的第三个宠物
	 * 权限
	 */
	{"domespet",     gm_domespet,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/setpetaptimax --设置宠物资质
	 * 名称
	 *	 setpetaptimax -- 设置宠物栏中的某个宠物的4个资质值达到最大
	 * 用法
	 *     setpetaptimax chIndex
	 *     宠物位置:宠物在宠物栏的具体位置，从0开始计数
	 * 用例
	 *setpetaptimax 2
	 *设置第三个位置的宠物的资质值达到最大
	 * 权限
	 */
	{"setpetaptimax",     gm_setpetaptimax,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/petdie --减少忠诚
	 * 名称
	 *	 petdie -- 会减宠物的忠诚度10点
	 * 用法
	 *     petdie 宠物位置
	 *     
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *petdie 2
	 *减位于宠物栏的第三个宠物的忠诚度
	 * 权限
	 */
	{"petdie",     gm_petdie,    	GM_POWER_FOURTH,      NULL},
	/******/
	
	/****f* pet/petfruit --使用资质果实
	 * 名称
	 *	 petfruit -- 宠物使用资质果实以提升资质
	 * 用法
	 *     petfruit 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *petfruit 33 -1 2
	 *位于宠物栏的第三个宠物使用资质果实
	 * 权限
	 */
	{"petfruit",     gm_petfruit,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/petstrengthen --强化宠物
	 * 名称
	 *	 petstrengthen -- 宠物使用宠物强化石进行强化以提升资质
	 * 用法
	 *     petstrengthen 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *petstrengthen 33 -1 2 1
	 *位于宠物栏的第三个宠物使用宠物强化石进行强化
	 * 权限
	 */
	{"petstrengthen",     gm_petstrengthen,    	GM_POWER_FOURTH,      NULL},
	/******/

	/****f* pet/strengthenpet --强化宠物
	 * 名称
	 *	 strengthenpet -- 使用宠物强化石进行强化以提升资质
	 * 用法
	 *     strengthenpet
	 * 用例
	 *strengthenpet
	 *位于宠物栏的当前宠物使用宠物强化石进行强化
	 * 权限
	 */
	{"strengthenpet",     gm_strengthenpet,    	GM_POWER_FOURTH,      NULL},
	/******/
	
	/****f* pet/washpointspet --宠物洗点
	 * 名称
	 *	 washpointspet -- 对一只指定的宠物洗点
	 * 用法
	 *     washpointspet 宠物所在位置类型（宠物栏/背包） -1 宠物位置
	 *     宠物所在位置类型（宠物栏/背包）：宠物栏(33)，背包(1)
	 *     宠物位置:宠物的具体位置，从0开始计数
	 * 用例
	 *washpointspet 33 -1 2
	 *洗位于宠物栏的第三个宠物
	 * 权限
	 */
	{"washpointspet", gm_washpointspet,		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* pet/addpetxp --增加宠物经验
	 * 名称
	 *	 addpetxp -- 对当前激活的宠物加经验
	 * 用法
	 *	 addpetxp xp_points
	 * 用例
	 *	addpetxp 1000  :为当前宠物增加1000的经验值
	 * 权限
	 */
	{"addpetxp", gm_addpetxp, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* pet/addpetmp -- 给宠物加MP
	 * 名称
	 *	 addpetmp -- 给宠物加MP
	 * 用法
	 *	 addpetmp mp_points
	 * 用例
	 *	addpetmp 1000  :为宠物增加1000MP
	 * 权限
	 */
	{"addpetmp", gm_addpetmp, 		GM_POWER_FOURTH, 		NULL},
	/******/
	
	/****f* pet/addpethp  -- 宠物加HP
	 * 名称
	 *	 addpethp -- 宠物加HP
	 * 用法
	 *	 addpethp hp_points
	 * 用例
	 *	addpethp 1000  :为宠物增加1000HP
	 * 权限
	 */
	{"addpethp", gm_addpethp, 		GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* pet/petmasterskill -- 宠物学习技能
	 * 名称
	 *	 petmasterskill-- 宠物学习技能
	 * 用法
	 *	 petmasterskill  skillid 
	 * 用例
	 *	petmasterskill  1009 : 使得当前激活的宠物按正常的逻辑检测学会指定的技能
	 * 权限
	 */
	{"petmasterskill", gm_petmasterskill,	GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/petskillgriddecap -- 宠物技能格解封
	 * 名称
	 *	 petskillgriddecap-- 宠物技能格解封
	 * 用法
	 *	 petskillgriddecap  skillgrid 
	 * 用例
	 *	 petskillgriddecap  2: 使得当前激活的宠物的第2个技能格解封
	 * 权限
	 */
	{"petskillgriddecap", gm_petskillgriddecap,	GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/petskillgridreset -- 宠物技能格重置
	 * 名称
	 *	 petskillgridreset-- 宠物技能格重置
	 * 用法
	 *	 petskillgridreset  skillgrid 
	 * 用例
	 *	 petskillgridreset  2: 使得当前激活的宠物的第2个技能格重置
	 * 权限
	 */
	{"petskillgridreset", gm_petskillgridreset,	GM_POWER_FOURTH,		NULL},
	/******/
	
	/****f* pet/addpetlist  -- 增加宠物栏数量
	 * 名称
	 *	 addpetlist -- 增加宠物栏数量
	 * 用法
	 *	 addpetlist 1/2
	 * 用例
	 *	 addpetlist 1  增加一个宠物栏位
	 * 权限
	 */
	{"addpetlist", gm_add_pet_list,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* pet/petcloneskill -- 宠物学习技能
	 * 名称
	 *	 petcloneskill-- 宠物学习技能
	 * 用法
	 *	 petcloneskill skillid skillgridindex
	 * 用例
	 *	petcloneskill  1009  1 使得当前激活的宠物的第一个技能格学会指定的技能 
	 * 权限
	 */
	{"petcloneskill", gm_petcloneskill,	GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/petshowinfo --打印宠物信息
	 * 名称
	 *	 petshowinfo -- 宠物打印当前血和法的数值
	 * 用法
	 *	 petshowinfo
	 * 权限
	 */
	{"petshowinfo", gm_petshowinfo,	GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/awakepet --唤醒宠物
	 * 名称
	 *	 awakepet -- 将已睡眠宠物唤醒
	 * 用法
	 *	 awakepet
	 * 用例
	 *	awakepet:将所有宠物唤醒
	 * 权限
	 */
	{"awakepet", gm_awakepet, 		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/loadpet -- 装载宠物
	 * 名称
	 *	 loadpet -- 装载宠物
	 * 用法
	 *	 loadpet 宠物所在位置类型（宠物栏(33)/背包(1)） -1 宠物物品位置(从0开始) 宠物栏位置(从0开始)
	 * 用例
	 *	loadpet 1 -1 2 1:将背包中第3个储物格中的宠物物品装载进宠物栏的第2个栏位
	 * 权限
	 */
	{"loadpet", gm_loadpet, 		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/unloadpet  -- 卸载宠物
	 * 名称
	 *	 unloadpet -- 卸载宠物
	 * 用法
	 *	 unloadpet 1 -1 宠物物品在背包中的位置(从0开始) 宠物在宠物栏的位置(从0开始)
	 * 用例
	 *	unloadpet 1 -1 2 1:将宠物栏第2个栏位的宠物卸载到背包中的第3个储物格中
	 * 权限
	 */
	{"unloadpet", gm_unloadpet, 		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/calluppet -- 激活宠物
	 * 名称
	 *	 calluppet -- 激活宠物
	 * 用法
	 *	 calluppet 宠物栏位置(从0开始)
	 * 用例
	 *	 calluppet 1 :将宠物栏第2个栏位的宠物激活
	 * 权限
	 */
	{"calluppet", gm_calluppet, 		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/callbackpet -- 召回宠物
	 * 名称
	 *	 callbackpet -- 召回宠物
	 * 用法
	 *	 callbackpet 宠物栏位置(从0开始)
	 * 用例
	 *	 callbackpet 1 :将宠物栏第2个栏位的宠物召回
	 * 权限
	 */
	{"callbackpet", gm_callbackpet, 		GM_POWER_FOURTH,		NULL},
	/******/

	/****f* pet/chgpetattr -- 修改宠物的属性
	 * 名称
	 *   chgpetattr -- 修改宠物的属性
	 * 用法
	 * chgpetattr ListType BagIndex ItemIndex attrtype attrvalue 
	 *          [ListType 储物格类型 0=角色背包 33=宠物栏]
	 *          [BagIndex 丢弃物品所在的背包位置 指令中该值可任意]
	 *          [ItemIndex 物品在储物格里的索引 指令中该值从0开始表示第一个格子]
	 *          [attrtype 属性类型
	 *          0=宠物强化祝福值操作]
	 * 用例
	 *   //chgpetattr 1 0 0 0 30 表示将背包中第一个格子上的宠物的强化祝福值加30
	 *   //chgpetattr 33 0 1 0 -30 表示将宠物栏中第二个格子上的宠物的强化祝福值减30
	 * 权限
	 */
	{"chgpetattr",		gm_chg_pet_attr, 		GM_POWER_FOURTH, 		NULL},
	/******/

	
	/****f* whitelist/whitelist --加入其他线白名单
	 * 名称
	 *   whitelist -- 把自己加入到其他ZONE的白名单，或查看服务器的白名单信息
	 * 用法
	 * whitelist add  zoneid <uin>  如果提供了UIN则把UIN加入到白名单
	 *   whitelist list   显示本线的白名单情况
	 *   whitelist queue   显示本线的排队情况
	 *   whitelist setmax  MaxNum 设定其他各线分别可以跨入本线的最大值
	 *   whitelist checkqueue  ZoneID 检查本线对于指定线的排队情况	 
	 * 用例
	 *  whitelist add 1 10001
	 * 权限
	 */
	{"whitelist",gm_whitelist,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* whitelist/login --加入其他线白名单
	 * 名称
	 *   login -- 登陆排队相关信息
	 * 用法
	 * login show 显示当前状态  
	 *   login setmax <Num>  设置最大的排队人数
	 * 用例
	 *  login setmax 200
	 * 权限
	 */
	{"login",gm_login,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* task/task --任务相关
	 * 名称
	 *   task -- 调用task接口
	 * 用法
	 * task help
	 *   task accept <TaskID> <CycleID> 接受任务,如果是循环或者互助任务，可指定最后一个参数来直接接收想要的任务
	 *   task submit <TaskID> 提交任务
	 *   task remove <TaskID>  放弃正在执行的任务 
	 *   task getinfo <TaskID>   重新发一遍角色的任务数据给前台
	 *   task addfinish <TaskID>  把TASKID指定的任务加入到完成列表
	 *   task removefinish <TaskID> 删除任务永久列表中的任务
	 *   task getacceptlist <TaskID>   获取正在执行的任务的ID列表
	 *   task finishpworld <PworldID> <Difficult>   向任务系统发一个完成指定难度的副本的消息
	 *   task getpracticetime   获取试炼任务的时间信息
	 *   task addpracticetime <Time(s)>   给试炼任务的接收时间加一个值，好放弃，一般为负数-1800
	 *   task setcycle <TaskID> <Num>   设置循环任务的当前环数
	 *   task listfinish   列出已经完成的任务
	 * 用例
	 *  task accept 10001
	 *  task submit 10001
	 *  task remove 10001
	 */
	{"task",gm_task,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/taunt --打印仇恨信息
	 * 名称
	 *   taunt -- 打印仇恨信息，包括自身的仇恨和所选目标的仇恨
	 * 用法
	 * taunt 1 打印角色自己的被仇恨信息
	 *   taunt 必须先用鼠标选定一个非物品的目标
	 * 用例
	 */
	{"taunt",gm_taunt,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* system/transtime -- 将time_t 转化为GMT
	 * 名称
	 *   transtime -- 将time_t 转化为GMT
	 * 用法
	 * transtime 1234457438 
	 *   transtime  获取系统当前的time_t和GMT时间
	 * 用例
	 */
	{"transtime",gm_transtime,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* monster/ai --怪物AI相关
	 * 名称
	 *   ai  --启用或者禁用怪物ai系统   或打印  怪物技能 选中技能
	 * 用法
	 * ai pause 怪物ID ；怪物暂停Ai处理
	 *   ai resume 怪物ID ；怪物继续Ai处理
     *   ai printskill 怪物ID ；打印怪物技能列表和当前选择技能
     *   ai skill 技能ID 怪物ID ；怪物释放某个指定技能
	 * 用例
	 */
	{"ai",gm_ai,	GM_POWER_FOURTH, NULL},
	/******/
	
	/****f* role/bp --查看战斗力
	 * 名称
	 *   bp  --查看战斗力
	 * 用法
	 * bp 				 :角色自身战斗力
	 *   bp PetNo			 ；PetNo号宠物的战斗力
     *   bp MonID			 ；MonID怪物的战斗力
	 * 用例
	 */
	{"bp",gm_battlepower,	GM_POWER_FOURTH, NULL},
	/******/
	/****f* role/roleattr --角色属性
	 * 名称
	 *   roleattr  --调整角色的基本属性
	 * 用法
	 * roleattr 1 1 1 1 
	 * 用例
	 */
	{"roleattr",gm_roleattr,	GM_POWER_FOURTH, NULL},
	/******/
	/****f* pet/attr
	 * 名称
	 *   petattr  --宠物的基本属性
	 * 用法
	 * //petattr
	 * 用例
	 */
	{"petattr",gm_petattr,	GM_POWER_FOURTH, NULL},
	/******/
	/****f* pet/petitemattr --宠物属性
	 * 名称
	 *   petitemattr  --宠物物品的一些基本属性
	 * 用法
	 * //petitemattr 1 --宠物栏第1个位置的宠物的属性(可以不激活宠物使用此指令)
	 * 用例
	 */
	{"petitemattr",gm_petitemattr,	GM_POWER_FOURTH, NULL},
	/******/
	
	/****f* pet/egg --宠物蛋相关
	 * 名称
	 *   egg  --宠物蛋相关
	 * 用法
	 * //egg 0 打印信息； egg 1~3 设置 [1:visit times; 2: egglevle; 3: time += ]；egg 其他 重置全部信息
	 * 用例
	 */
	{"egg", gm_egg,	GM_POWER_FOURTH, NULL},
	/******/
	
	/****f* sys/act--世界杯设置比赛结果
	 * 名称
	 *	 worldcup
	 * 用法
	 * //worldcup   设置比赛结果
	 * 用例
	 * //worldcup set 1 2 3 4 5  设第一场 比赛为 2、3队，比分 4:5
	 * //worldcup display 3      查看第3场比赛
	 * //worldcup setall 24      同原来的worldcup_set_result，按预先发布的表格设置前24场比赛
	 * 其中，set命令要求必须按顺序设，比如现在有3场比赛，则只能设1~4场的结果，设4时比赛场次更新为4，下次可以设置5； 如果把比赛2的球队设成0，则比赛场数变成1，从而实现删的功能
	 */
	{"worldcup", gm_worldcup, GM_POWER_FOURTH, NULL},
	/******/
	/****f* sys/act--活动掉落
	 * 名称
	 *	 actloot
	 * 用法
	 * //actloot disable 关闭活动掉落
	 * //actloot enable  开启活动掉落
	 * //actloot insert [type] [id]    类型[type]增加掉落方案ID[id]
	 * //actloot delete [type] [id]    类型[type]删除掉落方案ID[id]
	 * //actloot print [type]     打印指定类型的活动掉落方案ID列表
	 * 用例
	 */
	{"actloot", gm_act_loot, GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/repairall --修理装备
	 * 名称
	 *   repairall --修理角色身上的所有装备
	 * 用法
	 * //repairall
	 * 用例
	 */
	{"repairall",gm_repairall,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/ac --自动战斗相关
	 * 名称
	 *   ac  --自动战斗相关调试
	 * 用法 (注意下面参数程序没做校验，请务必保证每次都输入，而且都输入正确)
	 * ac agent -- 直接触发离线自动战斗
     *   ac online -- 返回在线状态
     *   ac setting -- 默认设置全部选项(战士)
     *   ac setting print -- 打印自动战斗设置
     *   ac setting pick $Flag $color -- 自动拾取设置$flag[0,1] $color[1~4]
     *   ac setting hp $Flag $percent $resid -- 生命药
     *   ac setting mp $Flag $percent $resid -- 法力药
     *   ac setting repair $Flag $resid -- 修理装备
     *   ac setting ac $Flag $distance $defaultskill $mainskill -- 自动战斗
     *   ac setting buff $Flag -- buff技能战斗
     *   ac setting offlineac $Flag $time-- 是否离线战斗
     *   ac  autopay $Flag -- 是否自动充值	 
	 */
//comment:ac	{"ac", gm_ac,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/mascot --福神相关gm  add by lcs for mascot
	 * 名称
	 *   mascot  --
	 * 用法 
	 */
//	{"mascot", gm_mascot,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/pk -- pk相关
	 * 名称
	 *   pk -- PK相关的参数设置
	 * 用法
	 * pk print 打印PK相关的几个参数值
	 *   pk pkvalue set $Value  	 
	 *   pk pkmode set $Value  	 
	 *   pk regionpkmode get - 让后台获取一下地域pk属性，可再用print打印看看
	 *   pk 5v5 sys info -查看单方人数 是否三职业限制 是否要求组队
	 *   pk 5v5 sys set  -设定单方人数 三职业要求 组队要求
	 *   pk 5v5 map info -地图实例总数 主要检测地图实例正常释放
	 *   pk 5v5 map data -查看角色所在地图实例上战场信息：得分 平均分 角色分等
	 *   pk 5v5 team info  	-查看匹配队列中等待的队伍
	 *   pk 5v5 team reset 	-重置匹配队列等待队伍为0
	 *   pk 5v5 role info 	-查看角色本人士气值 积分 点值
	 *   pk 5v5 role morale 0 
	 *   pk 5v5 role enter 
	 *   pk 5v5 qq [qq] info 		-查看指定qq在线角色士气值 积分 点值
	 *   pk 5v5 qq [qq] reset 		-重置指定qq在线角色士气值 积分 点值 胜利 失败次数
	 *   pk 5v5 qq [qq] 10 morale	-将指定qq在线角色士气值加上10
	 *   pk 5v5 qq [qq] 100 score		-将指定qq在线角色积分加上100
	 *   pk 5v5 qq [qq] 10 point	-将指定qq在线角色勇者点加上10
	 *   pk 5v5 qq [qq] 1 win		-将指定qq在线角色胜利次数加上1
	 *   pk 5v5 qq [qq] 1 lost	 	-将指定qq在线角色失败次数加上1
	 *   pk 5v5 rank info
	 * 用例
	 */
	{"pk",gm_pk,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* role/jailrole -- 监狱相关操作
	 * 名称
	 *   jailrole -- 监狱相关操作
	 * 用法
	 * jailrole $QQ号 $Hour $Min $Sec  -----若时间同为0，则是将角色从监狱中释放。	 
	 * 用例
	 */
	{"jailrole", gm_jailrole,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* pworld/pworld -- 副本相关
	 * 名称
	 *   pworld enter
	 * 用法
	 * pworld  pworldid  mapid xpos ypos
	 * 用例
	 * //pworld   1  1001  200 200
	 */
	{"pworld",gm_pworld,	GM_POWER_FOURTH, NULL},
	/******/


	/****f* pworld/minigame    -- minigame相关
	 * 名称
	 *   minigame... 
	 * 用法
	 * minigame rank daily/week <类型：1 经典模式 2 爆破模式 3 黄金模式>
	 * 权限
	 */
	{"minigame", gm_minigame,	GM_POWER_FOURTH, NULL}, 
	/******/


	/****f* sell/    --  摆摊 相关
	 * 名称
	 *   sell ... 
	 * 用法
	 * sell close <uin>/<all> 关闭某人摊位  所有摆摊的人都不能摆摊取消摆摊状态
	 * 权限
	 */
	{"sell", gm_sell,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* sellquery/    --  摆摊查询
	 * 名称
	 *   sellquery ... 
	 * 用法
	 * sellquery class 类型
	 * 权限
	 */
	{"sellquery", gm_sellquery,	GM_POWER_FOURTH, NULL}, 
	/******/


	/****f* position/transfer --传送列表
	 * 名称
	 *   transfer -- 借助NPC移动具体的地图和位置，NPC必须具备传送功能，和goto功能类似
	 * 用法
	 * transfer transferid transferitemindex [传送ID  传送ID下面传送目的地的位置索引]
	 * 用例
	 *   transfer 1 0
	 * 权限
	 */
	{"transfer", 			gm_transfer, 			GM_POWER_FOURTH, 		NULL}, 
	/******/

	/****f* trade/deal --npc交易
	 * 名称
	 *   deal -- NPC交易，NPC必须具备售卖功能
	 * 用法
	 *   deal msg_cmd_id selllist_id Filename [Deal消息的命令码，比如31代表购买  售卖列表ID 物品信息存储的文件名，全路径，格式见范例]
	 * 用例
	 *   deal 31 1 ../testdata/purchase.txt
	 * 权限
	 */
	{"deal", 			gm_deal, 			GM_POWER_FOURTH, 		NULL}, // added by lcs_test
	/******/

	/****f* system/sysnotice -- 系统通知
	 * 名称
	 *   sysnotice -- 系统通知
	 * 用法
	 *   sysnotice ID
	 * 用例
	 *   sysnotice 20001
	 * 权限
	 */
	{"sysnotice", 			gm_sys_notice, 			GM_POWER_FOURTH, 		NULL}, // added by lcs_test
	/******/

	/****f* trade/exchange -- P2P交易
	 * 名称
	 *   exchange -- P2P之间的交易
	 * 用法
	 *   exchange msg_cmd_id role_zid Filename [exhange消息的命令码，比如11代表交易发起  Role_zID 物品信息存储的文件名，全路径，格式见范例]
	 * 用例
	 *   exchange 11 13579 /home/kevin/exchange_info1.txt
	 * 权限
	 */
	{"exchange", 			gm_exchange, 			GM_POWER_FOURTH, 		NULL}, // added by lcs_test
	/******/

	/****f* trade/exchanger -- 交易所gm
	 * 名称
	 *   exchange -- 交易所gm
	 * 用法
	 *   exchange 
	 * 权限
	 */
	{"exchanger", 			gm_exchanger, 			GM_POWER_FOURTH, 		NULL}, 
	/******/

	/****f* skill/smash -- 一击必杀
	 * 名称
	 *   smash -- 一击必杀
	 * 用法
	 *   smash 1 / 0
	 * 用例
	 *   smash 1  设置
	 *   smash 0  取消
	 * 权限
	 */
	{"smash", 			gm_smash, 			GM_POWER_FOURTH, 		NULL},
	/******/

     /****f* skill/strong -- 无敌
	 * 名称
	 *   strong -- 无敌，不减少血量、法力、真气等
	 * 用法
	 *   strong 3/2/1/0
	 * 用例
	 *   strong   1 不受战斗伤害  2 不受战斗伤害不受损益BUFF 3 会受buff伤害，所有战斗伤害将化简为1点伤害
	 *   strong 0  取消
	 * 权限
	 */
	{"strong", 			gm_strong, 			GM_POWER_EIGHTH, 		NULL},
	/******/

	  /****f* system/hide -- GM隐身
	 * 名称
	 *   hide -- GM隐身
	 * 用法
	 *   hide 1 / 0
	 * 用例
	 *   hide 1  设置
	 *   hide 0  取消
	 * 权限
	 */
	{"hide", 			gm_hide, 			GM_POWER_EIGHTH, 		NULL},
	/******/

	 /****f* system/follow -- 跟随
	 * 名称
	 *   follow -- 跟随
	 * 用法
	 *   follow $uin ， $uin=0表示取消跟随
	 * 用例
	 *   follow $uin  跟随某个Uin的角色
	 *   follow 0 取消跟随
	 * 权限
	 */
	{"follow", 			gm_follow, 			GM_POWER_FOURTH, 		NULL},
	/******/
	

	/****f* skill/suite --套路
	 * 名称
	 *   suite -- 三段协议，支持套路
	 * 用法
	 *   suite 1/0
	 * 用例
	 *   suite 1  设置
	 *   suite 0  取消
	 * 权限
	 */
	{"suite", 			gm_suite, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/cd -- 冷却相关
	 * 名称
	 *   cd -- 冷却关闭
	 * 用法
	 *   cd 1 / 0  关闭冷却系统
	 * 用例
	 *   cd 1  恢复
	 *   cd 0  取消
	 * 权限
	 */
	{"cd", 			gm_cd, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/team -- 组队相关
	 * 名称
	 *   team -- 组队相关
	 * 用法
	 *   team  publish/cancel/querymy/querybrief/queryall
	 * 用例
	 * 权限
	 */
	{"team", 			gm_team, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* role/assisdata -- 查看SERVER的辅助数据
	 * 名称
	 *   assisdata-- 查看数据值
	 * 用法
	 *   assisdata $opr $type $key $attr $value
	 * 用例
	 * 权限
	 */
	{"assisdata", 			gm_assisdata, 			GM_POWER_FOURTH, 		NULL},
	/******/


	
	/****f* system/systimectrl-- 时间控制产出
	 * 名称
	 *   systimectrl --时间控制产出
	 * 用法
	 *   systimectrl 
	 * 用例
	 * 权限
	 */
	{"systimectrl", 			gm_systimectrl, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/skill -- 技能属性调整
	 * 名称
	 *   skill -- 技能属性调整
	 * 用法
	 * skill prac $value
	 *   skill setprac $skillid $value
	 * 用例
	 *   skill prac $value -- 设置每释放一次技能，熟练度增加$value
	 *   skill setprac $skillid $value -- 直接设置指定技能的熟练度数值为$value
	 * 权限
	 */
	{"skill", 			gm_skill, 			GM_POWER_FOURTH, 		NULL},
	/******/


	/****f* skill/masterskill --学习技能
	 * 名称
	 *   masterskill -- 让角色掌握某种技能，会检查技能掌握需求
	 * 用法
	 *   masterskill skill_id
	 * 用例
	 *   masterskill 31100101
	 * 权限
	 */
	{"masterskill", 			gm_masterskill, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* guild/masterfamilyskill ---- 学习家族技能
	 * 名称
	 *   masterfamilyskill -- 让角色掌握某种技能，会检查技能掌握需求
	 * 用法
	 *   masterfamilyskill skill_id
	 * 用例
	 *   masterfamilyskill 31100101
	 * 权限
	 */
	{"masterfamilyskill", 			gm_masterfamilyskill, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/cloneskill --掌握技能
	 * 名称
	 *   cloneskill -- 让角色掌握某种技能，而不会检查技能掌握需求
	 * 用法
	 *   cloneskill skill_id
	 * 用例
	 *   cloneskill 31100101
	 * 权限
	 */
	{"cloneskill", 			gm_cloneskill, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/forgetskill -- 洗掉所有已学技能
	 * 名称
	 *   forgetskill -- 洗掉所有已学技能
	 * 用法
	 *   forgetskill  0  之所以要加个0，主要是客户端不把//forgetskill当GM命令。。一定要有个参数，随便是啥
	 * 用例
	 *   forgetskill 0
	 * 权限
	 */
	{"forgetskill", 			gm_forgetskill, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/batchskill --掌握全部技能
	 * 名称
	 *   batchskill -- 让角色掌握某批技能，而不会检查技能掌握需求
	 * 用法
	 * batchskill $batch_id-参考配置表:GM参数表.xml(fo2_gmarg)
	 *   batchskill prof - 直接根据当前角色的职业和等级，学习当前角色所有的可学习的技能	 
	 * 用例
	 *   batchskill 1
	 *   batchskill prof
	 
	 * 权限
	 */
	{"batchskill", 			gm_batchskill, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/applystat --应用特殊状态
	 * 名称
	 *   applystat -- 让角色增加指定等级的某种特殊状态，如果指定等级为0，则删除该特殊状态
	 *   ID与特殊状态对应表请查看key_skill.ini
	 * 用法
	 *   applystat stat_id stat_level
	 * 用例
	 * applystat 3001 1 //增加等级为1，ID是3001的特殊状态<br/>
	 *   applystat 3001 0 //删除<br/>
	 *   对照表<br/>
	 *   痛			3000<br/>
	 *   灼烧		3001<br/>
	 *   诅咒		3002<br/>
	 *   流血		3003
	 *   爆击之心	3004
	 *   定身		3005
	 *   恐惧		3006
	 *   变形		3007
	 *   眩晕		3008
	 *   狂斧系变身	3009
	 *   神剑系变身	3010
	 *   仁杖系变身	3011
	 *   魔杵系变身	3012
	 *   火铳系变身	3013
	 *   圣弩系变身	3014
	 *   控制状态清除	3015
	 *   四抗提升	3016
	 *   禁魔		3017
	 *   破甲		3018
	 *   嘲讽		3019
	 *   反击		3020
	 *   分身斩		3021
	 *   缴械		3022
	 *   断筋		3023
	 *   反弹		3024
	 *   控制增益	3025
	 *   法力护盾	3026
	 *   生命之心	3027
	 *   赞达拉		3028
	 *   拘魂		3029
	 *   冰箱		3030
	 *   光盾		3031
	 *   标记		3032
	 *   急行		3033
	 *   消除损益状态	3034
	 *   消除增益状态	3035
	 *   安抚		3036
	 *   精良火药	3037
	 *   血性怒吼	3038
	 *   飞弹群攻	3039
	 *   装死		3040
	 *   躲闪		3041
	 *   针刺		3042
	 *   麻痹		3043
	 *   龙兽守护	3044
	 * 权限
	 */
	{"applystat", 			gm_applystat, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/stat -- 查询角色是否在某个状态下
	 * 名称
	 *   stat -- 查询角色是否在某个状态下
	 * 用法
	 *   stat $id
	 * 用例
	 *   stat 1
	 *   stat 3001
	 * 权限
	 */
	{"stat", 			gm_stat, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/xp2 -- 双倍经验时间区间
	 * 名称
	 *   xp2 -- 双倍经验时间区间
	 * 用法
	 *   usage: //xp2 $BEGINTIME(14) $ENDTIME(14) 
	 * 用例
	 *   //xp2 20090530150000  20090530170000
	 * 权限
	 */
	{"xp2", 			gm_xp2, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* skill/setprof -- 设置职业
	 * 名称
	 *   setprof -- 设置成指定职业，从一个职业洗成另一个职业时，会成为一个一级角色
	 * 用法
	 *   setprof prof_id
	 * procid (1,2,3) (战士 法师 猎手)
	 * 用例
	 *   setprof 1
	 * 权限
	 */
	{"setprof", 			gm_setprof, 			GM_POWER_FOURTH, 		NULL},
	/******/

	/****f* item/itemgid -- 物品GID的操作
	 * 名称
	 *   itemgid  -- 物品GID的操作
	 * 用法
	 *  itemgid CmdID ListType BagIndex ItemIndex GID 
	 *          [CmdID 命令码，0=生成一个GID，打印一下， 1=打印一下指定位置物品的GID，
	 *					  2=为指定位置的物品重新分配新的GID， 3=用传入的GID参数作为指定位置的物品的GID ]
	 *
	 * 用例
	 *  itemgid 0
	 *  itemgid 1 0 0 1 
	 *  itemgid 2 0 0 1 
	 *  itemgid 3 0 0 1 78812994690871383
	 
	 * 权限
	 */
	{"itemgid", 	gm_item_gid, 	GM_POWER_FOURTH,		NULL}, //added by lcs for gid
	/******/

	/****f* item/clrlootclt -- 清除掉落控制数
	 * 名称
	 *   clrlootclt -- 清除受掉落控制的物品的已掉落数
	 * 用法
	 *  clrlootclt clear itemid 清除该物品的掉落数
	 *  clrlootclt show itemid  显示这个物品的掉落数
	 *  clrlootclt set itemid [month|week|day] count 设置这个物品 月, 星期, 天的掉落数
	 * 用例
	 *  clrlootclt 20100003
	 * 权限
	 */
	{"clrlootclt", 	gm_clear_loot_control,	GM_POWER_FOURTH,		NULL},//added by yanbinchen
	/******/


	/****f*  pworld/finishpworld -- 触发结束平行世界
	 * 名称
	 *   finishpworld -- 触发结束平行世界的通知
	 * 用法
	 *  finishpworld
	 * 用例
	 *  //finishpworld
	 * 权限
	 */
	{"finishpworld", 	gm_finish_pworld,	GM_POWER_FOURTH,		NULL},
	/******/

	/****f*  monster/savetaunt --打开仇恨记录
	 *名称
	 *   savetaunt  ---用于打开记录死亡怪物的伤害列表, 配合disptaunt  使用（输入一次即可），如果要更换角色，那么在新角色命令窗口重新输入该命令即可
	 * 用法
	 *  savetaunt   
	 * 用例
	 * savetaunt  
	 * 权限
	 */
	{"savetaunt", 	gm_save_taunt,	GM_POWER_FOURTH,		NULL}, //added by kevinfan
	/******/


	/****f*  monster/disptaunt ---显示仇恨列表
	 * 名称
	 *   disptaunt  ---显示死亡怪仇恨列表的伤害值，该命令应该与 savetaunt 在同一个角色下 操作
	 * 用法
	 *  disptaunt   [filename]  // filename 可选用于输出到文件放置屏幕看不清楚（但该文件放在服务器上）
	 * 用例
	 * disptaunt   /home/kevinfan/taunt.txt
	 *disptaunt
	 * 权限
	 */
	{"disptaunt", 	gm_disp_taunt,	GM_POWER_FOURTH,		NULL}, //added by kevinfan
	/******/


	/****f*  map/clrrgnrefresh --清除角色区域怪物
	 * 名称
	 *   clrrgnrefresh  ---清除角色所在地图区域怪物的已刷新数
	 * 用法
	 *  clrrgnrefresh   [RegionID]  // RegionID 区域ID 为空时表示当前地图的所有区域
	 * 用例
	 * clrrgnrefresh 1 
	 *clrrgnrefresh 
	 * 权限
	 */
	{"clrrgnrefresh", gm_clear_region_refresh,	GM_POWER_FOURTH, NULL}, //add by yanbinchen
	/******/

	/****f*  map/clrrgnalived --清除角色区域怪物，仅对喷发式怪物有效
	 * 名称
	 *   clrrgnalived  ---清除角色所在地图区域怪物的已存活数, 仅对喷发式怪物有效
	 * 用法
	 *  clrrgnalived   [RegionID]  // RegionID 区域ID 为空时表示当前地图的所有区域
	 * 用例
	 * clrrgnalived 1 
	 *clrrgnalived 
	 * 权限
	 */
	{"clrrgnalived", gm_clear_region_blowout_alived,	GM_POWER_FOURTH, NULL}, //add by yanbinchen
	/******/

	/****f*  role/addrolelog --打印角色日志开关
	 * 名称
	 *   addrolelog  --打印角色的详细日志
	 * 用法
	 * 	 addrolelog add uin    --添加角色
	 *   addrolelog remove uin --删除角色
	 * 用例
	 *   addrolelog add 4444
	 *   addrolelog remove 4444
	 * 权限
	 */
	{"addrolelog", gm_add_role_log,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f*  role/commdatareset -- commdata数据清空并初始化
	 * 名称
	 *   commdatareset  -- commdata数据清空并初始化
	 * 用法
	 *   commdatareset appkey  -- commdata数据清空并初始化
	 * 用例
	 *   commdatareset 1000
	 * 权限
	 */
	{"commdatareset", gm_commdata_reset, GM_POWER_FIRST, NULL}, 
	/******/
	
	/****f*  role/gm_setgm-- 协助测试 
	 * 名称
	 *   setgm -- setgm?	 * 用法
	 *   gm_setgm qqnumber -- 设置gm 权限 (限定只有测试号4199可以) 
	 * 用例
	 *   setgm 10001 
	 * 权限
	 */
	{"setgm", gm_setgm, GM_POWER_FIRST, NULL}, 
	/******/

	/****f*  pworld/statusvar --副本状态变量
	 * 名称
	 *   statusvar  --设置平行世界的状态变量值
	 * 用法
	 * statusvar ID  Value	--设置
	 *   statusvar ID  		--查询
	 * 用例
	 *   statusvar 1 123
	 * 权限
	 */
	{"statusvar", gm_statusvar,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f*  pworld/eventvar --副本事件变量
	 * 名称
	 *   eventvar  --设置平行世界的事件变量值
	 * 用法
	 * eventvar ID  Value	--设置
	 *   eventvar ID  		--查询
	 * 用例
	 *   eventvar 1 123
	 * 权限
	 */
	{"eventvar", gm_pworld_event_var,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f*  pworld/statusmode --副本状态变量模式
	 * 名称
	 *   statusmode  --设置平行世界的状态变量模式
	 * 用法
	 * statusmode Mode 	--设置
 	 *   statusmode 		--查询
	 * 用例
	 *  statusmode Mode 	--设置
	 * 权限
	 */
	{"statusmode", gm_statusmode,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f*  pworld/starpworld --星级副本（英雄副本）相关设定
	 * 名称
	 *   starpworld  --星级副本查询与设定
	 * 用法
 	 *   starpworld set  	--设置
	 * 用例
 	 *   starpworld set 2  	--设置队伍人数
 	 *   starpworld reset   --重置本人星级
 	 *   starpworld id 51 35  	--设置副本ID以及总星级
	 * 权限
	 */
	{"starpworld", gm_starpworld,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f*  role/commstat --普通状态
	 * 名称
	 *   commstat  --设置/查询/删除角色的普通状态
	 * 用法
	 * commstat add 	ID	--设置
 	 *   commstat remove ID --清除
 	 *   commstat check  ID	--查看指定
 	 *   commstat look 	--查看所有
 	 *   commstat clear 	--清除所有
	 * 用例
	 *   commstat add 1	--增加角色交易状态
	 * 权限
	 */
	{"commstat", gm_commstat,	GM_POWER_FOURTH, NULL}, 
	/******/


	/****f*  system/fetchattr --获取属性
	 * 名称
	 *   fetchattr  --获取属性  ATP测试时，打开发消息开关
	 * 用法
	 * fetchattr $isNoticeMsg  $ObjID $AttrID1 .... 
	 *   fetchattr 0 0 	AttrID		--获取角色的某个或者某些属性
 	 *   fetchattr 0 1 AttrID 		--获取角色宠物的某个或者某些属性
 	 *   fetchattr 0 ObjID  AttrID	--获取指定怪物的某个或者某些属性
	 * 用例
	 *   fetchattr 0 0 103	--获取角色的等级, 并发送消息
	 * 权限
	 */
	{"fetchattr", gm_fetchattr,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* system/zoneinfo  --获取zone运行状态
	 * 名称
	 *   zoneinfo  --获取zone的运行状态
	 * 用法
	 *   zoneinfo 
	 * 权限
	 */
	{"zoneinfo", gm_zoneinfo,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* guild/guild  -- 家族相关GM
	 * 名称
	 *   guild --家族gm指令
	 * 用法
	 *   guild help  获得帮助 
	 *   guild create <guild_name>  创建家族
	 *   guild list   列出家族的所有成员 
	 *   guild delete   删除家族 
	 *   guild flag 提取该家族的创建人标识，看是否是gm创建
	 *   guild dump	 在后台log中打印指定家族的数据库信息
	 *   guild dumpall 在后台log中打印家族的所有数据库信息 
	 *   guild entersceen 进入自己的家族场景 
	 *   guild blesstime <Hour> <Min>  设置家族的祈福时间，只有族长可以设置 
	 *   guild dinnertime <Weekday> <Hour> <Min>  设置家族的聚餐时间，只有族长可以设置 
	 *   guild adddish <DishID> <Pos> 设置一个菜肴给家族的某个位置 
	 *   guild showdish 显示当前家族的所有菜肴 
	 *   guild resetblesstime  重置后台的开始祈福时间，这样可以在一天内进行多次祈福任务 
	 *   guild resetdinnertime  重置后台的开始聚餐时间，这样可以在一天内进行多次聚餐 
	 *   guild showblesstime 祈福任务开始，查看祈福任务的进行状态。 
	 *   guild showdinnertime 查看聚餐任务的进行状态 
	 *   guild resetreckon  清除家族本周的结算记录
	 *   guild  addstuff <StuffID> <Num>  给家族直接加材料:木材[20200423] 石料[20200424] 泥灰[20200425]  水晶之心[20200426]
	 *   guild  addgold <Num>  为家族的金券池加钱
	 *   guild  maint	进行今天的家族结算
	 *   guild  maintinfo	查看家族结算信息
	 *   guild  swap RoleIDA RoleIDB  交换两个成员的职位
	 *   guild  setjob RoleID DestJob  设置某一个成员的新职位
	 *   guild  addbuildlevel  <NUM>	增加家族的家族建设度
	 *   guild  addfriendly <TYPE> <NUM>	增加家族的友好度
	 *	友好度类型:灵猫一族[1] 蕉叶鼠[2] 古老天兵[3] 君子国[4] 小人国[5] 巨人国[6] 毛民国[7]
	 *	友好度类型: 丈夫国[8] 奇肱国[9] 翼人国[10] 沉梦国[11] 月兔国[12] 轩辕国[13] 降魔道士[14]
	 *   guild  maintlack <Times>	设置家族的欠账次数 1 - 6
	 *   guild  setlevel <ID> <level>  直接设置家族或者家族技能的等级
	 *   guild raisetime <ID> <AddTime> 增加技能或者家族已经升级的时间(秒) ID = [ -1] 将所有正在升级的升级完成; [ 0] 家族; Other[SkillID] 代表技能，AddTime 可加可减
	 *	家族建筑技能ID:衣帽精炼堂[38941] 配饰精炼堂[38942] 武器精炼坊[38943] 首饰精炼坊[38944] 珠宝精炼坊[38945] 护具精炼坊[38946] 宝石合成坊[38947]
	 *	家族科技技能ID:衣帽精炼专精[38948] 武器精炼专精[38949] 护具精炼专精[38950] 首饰精炼专精[38951] 珠宝精炼专精[38952] 配饰精炼专精[38953]
	 *	家族科技技能ID:桃园结义[38955] 义结金兰[38956] 歃血为盟[38957] 忠孝之气[38958] 同生共死[38959] 高义云薄[38960] 肝胆相照[38961] 兄弟之握[38962]
	 *   guild  addlamp <ListID>  为家族点亮某个忠义灯
	 *   guild  resetlamp 将家族忠义灯的结算时间调整为立刻结算
	 *   guild  addlamptime <LayNum> <AddTime> [RefreshSingle] 为家族增加某一层忠义灯的点亮时长(秒),并指定是否刷新单灯点亮时长
	 *   guild  removemutu <MutulID>  删除家族中的某个互助任务
	 *   guild  mid <minonline|maxinst|newsvr|oldsvr> <Param>  设定家族中秋副本的参数<最小在线| 最大地图实例| 新服标准 | 老服参数>
	 *   guild  clearlamprecord 清除家族忠义灯的相关物品记录
	 *   guild  listlamprecord  列出家族忠义灯的相关物品记录
	 *   guild  reckonmasterelect  进行家族族长选举结算，停止投票开始结算
	 *   guild  querylifetree 查询生命树
	 *   guild  changelifetree value 修改生命树
	 * 权限
	 */
	{"guild", gm_guild,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* guild/guildrole  -- 家族相关GM
	 * 名称
	 *   guildrole --家族角色gm指令
	 * 用法
	 * guildrole help  获得帮助 
	 *   guildrole join <guild_name>  加入招募状态为: Open的家族 
	 *   guildrole addcontribute <Num> 增加家族贡献度 
	 *   guildrole addlastcontribute <Num> 增加上周家族贡献度 
	 *   guildrole addmutupoint <Num>  增加家族互助点 
	 *   guildrole chgmutualtasktime <AddTimeSec>  修改互助任务的接收时间 
	 *   guildrole mutulpointtime <AddTimeSec> 修改上次互助点的发放时间 
	 *   guildrole resetroleblesstime  清除角色今天的祈福记录 
	 *   guildrole resetroledinnertime  清除角色本周的聚餐记录 
	 *   guildrole showquestion 向角色发送一个家族祈福的题目
	 *   guildrole  setvote <VoteNum>  为角色设置钦慕之花个数
	 *   guildrole  act <ActID>  进入指定的家族活动大副本
	 *   guildrole  setlamptime <UseNum>  设置忠义灯保护符的总使用次数，称号
	 *   guildrole  lastlongintime <Days>  修改家族成员上次登陆时间(天)，向前调整负数
	 *   guildrole  jointime <Days>  修改家族成员加入家族的时间(天)，向前调整负数
	 *   guildrole  resetmasterelect  重置家族成员族长选举投票信息，当天可多次投票
	 * 权限
	 */
	{"guildrole", gm_guildrole,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* trade/groupbuy  -- 团购GM
	 * 名称
	 *   groupbuy --团购GM指令
	 * 用法
	 * groupbuy query 查询当前团购活动的GroupID,物品ID,开启时间等
	 *   groupbuy setnum <ItemID>  <Num> 团购活动开启后，设置其中某个物品的购买人数，设置之后gid全部设置为0
	 *   groupbuy opentime <OpenSec> 设置团购活动的开启，如果当前已经开启则开启时间设置无效
	 *   groupbuy reckon  立即结算当前的团购活动
	 * 权限
	 */
	{"groupbuy", gm_groupbuy,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* mail/mail  -- 邮件相关GM
	 * 名称
	 *   mail --邮箱gm指令
	 * 用法
	 * mail help  获得帮助
	 * 权限
	 */
	{"mail", gm_mail,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* name_to_uin_gid/name_to_uin_gid  -- 邮件相关GM
	 * 名称
	 *   name_to_uin_gid -- 由名字查询uin gid和设置gid的指令 
	 * 用法 name_to_uin_gid set name gid / name_to_uin_gid get name
	 * 权限
	 */
	{"name_to_uin_gid", gm_namegid,	GM_POWER_EIGHTH, NULL},
	/******/


	/****f* other/award   -- 活动奖励
	 * 名称
	 *   award -- 活动奖励测试gm
	 * 用法
	 * award help  获得帮助
	 * 权限
	 */
	{"award", gm_award,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* Wchat/autochat   --自动聊天
	 * 名称
	 *  autochat 自动聊天, 用于测试client 的包处理能力
	 * 用法
	 * autochat 10 100  没秒100个包 持续10秒
	 * 权限
	 */
	{"autochat", gm_autochat,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* Wchat/allnotice   --通�所�?	 * 名称
	 *  autochat 自动聊天, 用于测试client 的包处理能力
	 * 用法
	 * autochat 10 100  没秒100个包 持续10秒
	 * 权限
	 */
	{"allnotice", gm_allnotice,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* other/counter   --计数器相关
	 * 名称
	 *  counter 计数器相关的gm指令
	 * 用法
	 * autochat help
	 * 权限
	 */
	{"counter", gm_counter,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* item/itemindex   --物品索引
	 * 名称
	 *  itemindex 
	 * 用法
	 * itemindex 1
	 * 权限
	 */
	{"itemindex", gm_itemindex,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* other/gm   -- gm管理指令
	 * 名称
	 *   gm -- gm管理指令
	 * 用法
	 * gm grant 权限 zoneID UIN RoleName
	 * 权限
	 */
	{"gm", gm_gm,	GM_POWER_SECOND, NULL},
	/******/

	/****f* role/kickrole   -- 踢人
	 * 名称
	 *   kickrole 踢人
	 * 用法
	 * kickrole uin <uin> /  rolename <rolename>
	 * 权限
	 */
	{"kickrole", gm_kickrole,	GM_POWER_SEVENTH, NULL},
	/******/

	/****f* role/returnaddbuddyfunc   -- 恢复加好友功能
	 * 名称
	 *   returnaddbuddyfunc 恢复加好友功能
	 * 用法
	 * returnaddbuddyfunc uin
	 * 权限
	 */
	{"returnaddbuddyfunc", gm_tmp_insert_data_to_db,	GM_POWER_SEVENTH, NULL},
	/******/

	/****f* system/boradcast   -- 是否用组播
	 * 名称
	 *   kickrole 是否用组播
	 * 用法
	 * boradcast use/nouse
	 * 权限
	 */
	{"boradcast", gm_boradcast,	GM_POWER_FOURTH, NULL},
	/******/

	/****f* system/netflow   -- 流量查看
	 * 名称
	 *   netflow  --获取zone的网络流量信息
	 * 用法
	 * netflow 
	 * 权限
	 */
	{"netflow", gm_netflow,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* item/senditem    -- 赠送物品
	 * 名称
	 *   senditem  -- 赠送物品
	 * 用法
	 * senditem ItemID Num RoleName 
	 * 权限
	 */
	{"senditem", gm_senditem,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* item/delitem    -- 删除物品
	 * 名称
	 *   delitem  -- 删除物品
	 * 用法
	 * delitem ItemID Num RoleName 
	 * 权限
	 */
	{"delitem", gm_delitem,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* role/reviverole    --  复活角色
	 * 名称
	 *   reviverole  -- 复活角色
	 * 用法
	 * reviverole uin <uin>  /  rolename <rolename>
	 * 权限
	 */
	{"reviverole", gm_revive_role, GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* role/objectattr    -- 取属性
	 * 名称
	 *   objectattr 
	 * 用法
	 * objectattr <objectid> 
	 * 权限
	 */
	{"objectattr", gm_objectattr,	GM_POWER_FOURTH, NULL}, 
	/******/



	/****f* role/qboperation   -- 查询兑换QB 
	 * 名称
	 *   qboperation -- 查询兑换QB 
	 * 用法
	 * qboperation  
	 * 权限
	 */
	{"qboperation", gm_qboperation,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* role/chgsvr   -- 转服相关 
	 * 名称
	 *  chgsvr --转服相关参数
	 * 用法
	 *  chgsvr qq [qq] 0 lasttime 	--0 查看上次转服时间 非0 原转服时间加上该非0值
	 *  chgsvr qq [qq] 0 chgflag 	--0 查看转服标记 非0 原转服标记加上该非0值
	 * 权限
	 */
	{"chgsvr", gm_change_svr,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* system/setsystemtime  -- 设置系统时间
	 * 名称
	 *   setsystemtime -- 设置系统时间
	 * 用法
	 * setsystemtime  
	 * 权限
	 */
	{"setsystemtime", gm_set_systemtime,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* script/setscriptvar -- 设置脚本变量
	 * 名称
	 *   setscriptvar -- 设置脚本变量
	 * 用法
	 * setscriptvar  ID  Value
	 * 权限
	 */
	{"setscriptvar", gm_set_script_ctrlvar,	GM_POWER_FOURTH, NULL}, 
	/******/


	/****f* title/title -- 称号系统相关
	 * 名称
	 *  title -- 称号系统相关gm指令
	 * 用法
	 * title  help
	 *   title list  列出当前所有称号
	 *   title check <TitleID>  检查是否有某个称号
	 *   title add <TitleID>  增加某个称号
	 *   title remove <TitleID>  移除某个称号，但是阶段奖励会在下次登陆后移除
	 *   title reporthy  <Num>  发送一个红颜人数变更的消息
	 *   title reportzj  <Num>  发送一个知己人数变更的消息
	 *   title reportty  <Num>  发送一个天缘人数变更的消息 
	 *   title recordnum  <Title> <Num>  修改某一称号的获取人数，Num可加，可减，当小于0时，强制等于0【注意:该修改会保存数据库，是永久性修改】
	 *   title record  <TitleID>  查看称号 TitleId 的获取情况
	 *   title report  向游戏人生报告称号
	 *   title repair  修复称号
	 *   title info  查看所有称号的辅助信息
	 *   title settimes team < Num >  设置组队次数
	 *   title settimes refine < Num >  设置精炼失败
	 *   title settimes redrole < Num >  设置红名区域杀死红名玩家个数
	 *   title settimes sellmoney < Num >  设置摆摊交易总额
	 *   title settimes freepet < Num >  设置放生宠物个数
	 *   title settimes login < Num >  设置连续登陆天数
	 *   title settimes tower < Num >  设置连续开启绝情塔次数
	 *   title settimes love < Num >  设置连续开启情愿次数，必须首先与某人开启一次，然后设置
	 *   title settimes groupbuy < Num >  设置连续参加团购的次数
	 *   title settimes guildtask < Num >  设置连续完成家族任务的天数
	 *   title settimes finger < Num >  设置猜拳获胜次数
	 *   title settimes quiz < Num >  设置祈福答题正确次数
	 *   title settimes perfectpet < Num >  设置洗出完美宝宝的个数
	 *   title settimes petegg < Num >  设置孵化宠物蛋个数
	 *   title settimes star < Num >  设置获得家族之星的次数
	 *   title settimes guildstuff < Num >  设置提交家族食材的个数
	 *   title settimes protectlamp < Num >  设置使用忠义灯保护符的次数
	 *   title settimes miji < Num >  设置发布传道秘籍的次数	 
	 *   title settimes petpworld < Num >  设置当天完成护送公主次数
	 *   title settimes killouter < Num >  设置当天杀死外服成员个数
	 *   title settimes wabao < Num >  设置当天进入挖宝副本的次数	 
	 *   title settimes task < Num > <Key> 设置完成任务的完成次数，Key为任务ID或者类型，具体要看称号表格	 
	 * 权限
	 */
	{"title", gm_title,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* auth/auth -- 图片验证相关
	 * 名称
	 *  auth -- 图片验证相关gm指令
	 * 用法
	 * auth  help
	 *   auth ask <Src> 进行图片验证，如果Src 为2 则进行安全中心验证，其他则进行游戏内验证
	 *   auth Answer <ID> 回答图片验证，如果没有输入answer默认使用正确答案
	 *   auth refresh 刷新图片
	 *   auth disable 本次登陆不弹出图片验证
	 * 权限
	 */
	{"auth", gm_auth,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* security/security -- 密保验证相关
	 * 名称
	 *  security -- 密保验证相关gm指令
	 * 用法
	 * secu  help
	 *   secu request  请求服务器进行验证
	 *   secu clearlock 清除安全锁
	 *   secu queryed 设置帐号为已经查询过密保状态
	 *   secu verified 设置帐号为已经验证过的状态
	 *   secu keymap 获取键盘图
	 *   secu resetkeymap 重新生成键盘图，下次获取时得到新的键盘图
	 *   secu loginprotect 设定登陆保护时间
	 *   secu resetpwd 重置安全锁密码,将角色的安全锁密码重置为000000
	 *   secu level 设定验证等级
	 *   secu use 设定使用类型
	 *   secu frenq 设定验证频率
	 *   secu show 显示所有信息
	 *	secu lockuser 将角色设置为安全锁用户，并重置密码为000000
	 * 权限
	 */
	{"secu", gm_security,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* sys/updateclientinfo --设置上报客户端数据的参数
	 * 名称
	 *  updateclientinfo -- 设置上班客户端数据的参数 
	 * 用法
	 *   updateclientinfo updatetime delaytime 
	 * 权限
	 */
	{"updateclientinfo", gm_updateclientinfo,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* sys/set_config -- 更改服务器配置
	 * 名称
	 *  set_config --  更改服务器配置
	 * 用法
	 *    set_config maxonline 1000 将服务最高在线改为1000
	 *    set_config maxlogin  1000  ( 服务可限制正常登录的角色个数. 不包括跳线回来的)
	 * 权限
	 */
	{"set_config", gm_set_config,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* trade/update_mall_hot_list -- 更新商城热销排行榜
	 * 名称
	 *  update_mall_hot_list --  更新商城热销排行榜
	 * 用法
	 *    update_mall_hot_list 
	 * 权限
	 */
	{"update_mall_hot_list", gm_update_mall_hot_list,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* trade/reset_commo_sell_limit -- 清空商品已卖数量信息
	 * 名称
	 *  reset_commo_sell_limit --  清空商品已卖数量信息
	 * 用法
	 *    reset_commo_sell_limit 
	 * 权限
	 */
	{"reset_commo_sell_limit", gm_reset_commo_sell_limit,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* trade/market -- 商票相关操作
	 * 名称
	 *  market -- 商票相关操作gm指令
	 * 用法
	 * market  help
	 *   market stock  进行缺货，10秒内生效
	 *   market shout  进行喊话，10秒内生效
	 * 权限
	 */
	{"market", gm_market,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* message/report -- 消息报告系统gm
	 * 名称
	 *  report -- 消息报告系统的gm
	 * 用法
	 * report  help
	 *   report task <MessageID> <ID> <NUM> 报告一个消息
	 *   report openboxpay <PworldID> <PworldLevel> <ItemID> [ItemAttr] 报告副本付费抽箱事件
	 *   report openboxfree <PworldID> <PworldLevel> <ItemID> [ItemAttr] 报告副本免费抽箱事件
	 *   report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum> 报告完成活动事件
	 *   report teamfinishact <ActID> <Score> <ElapseTime> 报告组队完成活动事件
	 *   report runcycle <ActID> <Cycle> <HitNum>  <ElapseTime> 报告活动过轮事件
	 *   report pworldscore <PworldID> <PworldLevel> <Score> 报告副本得分事件
	 *   report actinfo <ActID> <ActLevel> <FoodPoint>  <Coef1> 报告活动完成信息事件
	 *   report raffle <Times> 报告抽奖事件
	 *   report addfriend <FriendNum> 报告增加好友事件
	 *   report protectlamp <ItemID> 报告保护忠义灯事件
 	 *   report petegg 报告孵化宠物蛋时间
	 * 权限
	 */
	{"report", gm_report,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* act/act -- 活动相关操作
	 * 名称
	 *  act -- 活动服务器相关操作序号ID为misc中的使用序号，
	 *	当misc向zone发送消息时，统一使用活动ID，而zone向misc使用GM的时候，使用序号ID,
	 *	(可以理解为只有Misc要求zone启动活动的时候使用活动ID，其他均使用序号)
	 * 用法
	 * act  help [act|ann] 可选择其一，也可省略，默认act
	 *   act list 查询zone内的活动信息
	 *   act query [act|ann] <ID>  查询活动或提醒的详细信息
	 *   act open [act|ann] <ID>  开启一个活动或提醒 (开启活动后，要通知客户端更新界面sysnotice 48001 边境任务开启通知， sysnotice 48002 边境任务关闭通知，这里仅仅为策划提供，测试组请不要使用)
	 *   act close  [act|ann] <ID> 关闭一个活动或提醒
	 *   act slice [act|ann] <ID>  <HH:MM:SS> <HH:MM:SS>  重新设置活动或提醒的时间片
	 *   act addzone [act|ann] <ID> <ZoneID1> ...  为活动或提醒增加zone
	 *   act delzone [act|ann] <ID> <ZoneID1> ... 取消某个zone
	 *   act today 看本zone今天会开启的活动
	 * 权限
	 */
	{"act", gm_act,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* act/actraffle -- 充值翻翻活动
	 * 名称
	 * actraffle info 查看角色77号活动通用数据区数值
	 * actraffle set 0 100 重置第一个值为100
	 * actraffle comm 0 查看奖池值
	 * actraffle comm 100 奖池值加上100
	 * actraffle bless info 查看角色80号活动通用数据区数值
	 * actraffle bless set 0 0 将角色80号活动通用数据区下标为0的值置为0
	 * actraffle bless tree 圣诞树详细信息
	 * actraffle bless del 1 按照数组下标删除第2棵树（不同步角色数据，但是输出日志）
	 * actraffle bless rank 累计祈福点值排行榜
	 * actraffle bless rankreset 重置累计祈福点值排行榜
	 * actraffle bless rankrole [gid] [point] 给榜中角色增加点值并重排排行榜
	 * actraffle bless recvr 恢复comm db数据与地图上怪物的对应关系
	 * actraffle bless clr 将皇家园林内所有圣诞树清除，数据返还角色
	 * 权限
	 */
	{"actraffle", gm_recharge_raffle,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* act/actlover -- 情人节活动
	 * 名称
	 * actlover qq [qq] 0 vote 查看qq在线角色票数
	 * 权限
	 */
	{"actlover", gm_lover_day,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* system/relation -- zone svr 相互关系
	 * 名称
	 *  relation -- zonesvr之间相互关系的维护
	 * 用法
	 * relation  help  理出帮助信息
	 *   relation reset 重新刷新关系
	 *   relation rollticket <Num>  增加突袭任务的凭证获取个数
	 *   relation rollindex <Index1> <Index2>  增加服务器的资格参数1和2
	 *   relation list 列出本服务器的当前资格信息
	 * 权限
	 */
	{"relation", gm_relation,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* test/refinetest -- 精炼曲线测试
	 * 名称
	 *  refinetest -- 精炼曲线测试
	 * 用法
	 * refinetest  1 20202121
	 *   refinetest  <Mode> <ArmID> 精炼曲线测试
	 * 权限
	 */
	{"refinetest", gm_refine_test,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* test/lootprob -- 掉落概率测试
	 * 名称
	 *  lootprob -- 掉落概率测试
	 * 用法
	 * lootprob  
	 *   lootprob  <LootID> <TestTime> 
	 * 权限
	 */
	{"lootprob", gm_lootprob_test,	GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* test/commdata -- 通用存储测试
	 * 名称
	 *  testcommdata -- 通用存储测试
	 * 用法
	 *   testcommdata  save/get value 
	 * 权限
	 */
	{"testcommdata", gm_testcommdata,	GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/roleofflinemsg -- 离线消息系统测试
	 * 名称
	 *  testcommdata -- 
	 * 用法
	 *   testcommdata  30 发送 30条消息 
	 * 权限
	 */
	{"testoffline", gm_testoffline, GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/oldfriend----老友相关的GM
	 * 名称
	 *  oldfriend -- 老友相关的GM
	 * 用法
	 *  oldfriend set 0/1 (0:取消老友资格 1:设置老友资格)
	 *  oldfriend list 招募者GID (由于每个角色只存招募者不存老友 所以无法列出老友们)
	 *  oldfriend get/add 0/1/2/4/5/6/7/8/9 value (取或者改变对应数字代表的相关值)
	 *                0 是否是老友(1是 0不是)
	 *			   1 老友在回归前连续离线天数
	 *                2 招募者GID
	 *                4 招募者召回老友所获得的积分
	 *                5 招募者召回的45-60级老友数
	 *                6 招募者召回的61-75级老友数
	 *                7 招募者召回的76-90级老友数
	 *                8 招募者召回的老友们在回归后所获得的总威望
	 *                9 老友个体在活动开放后所获得的威望
	 *                10 老友本周获得威望
	 * 权限
	 */
	{"oldfriend", gm_old_friend, GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/testraffle -- 抽奖系统测试
	 * 名称
	 *  testraffle -- 
	 * 用法
	 *   testraffle  
	 * 权限
	 */
	{"testraffle", gm_testraffle, GM_POWER_FOURTH, NULL}, 
	/******/

	/****f* test/rentstorage -- 租赁仓库 测试
	 * 名称
	 *  rentstorage -- 
	 * 用法
	 *   rentstorage expire index time(second)  设置过期时间
	 * 权限
	 */
	{"rentstorage", gm_rentstorage, GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/addxpchangeattr -- 经验兑换属性点 测试
	 * 名称
	 *  addxpchangeattr -- 
	 * 用法
	 *   addxpchangeattr <type>  经验兑换指定类型的属性点 
	 * 权限
	 */
	{"addxpchangeattr", gm_add_xpchange_attr, GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/delxpchangeattr -- 扣除其他玩家经验兑换属性点,用于盗号后的处理
	 * 名称
	 *  delxpchangeattr -- 
	 * 用法
	 *   delxpchangeattr <gid> <pilltype> <pillnum> gid =0表示自己，否则表示别人
	 * 权限
	 */
	{"delxpchangeattr", gm_del_xpchange_attr, GM_POWER_FOURTH, NULL}, 
	/******/
	/****f* test/tiredmin -- 查看疲劳时间
	* 名称
	 *  tiredmin -- 
	 * 用法
	 *   tiredmin 
	 * 权限
	 */
	{"tiredmin", gm_role_tiredmin, GM_POWER_FOURTH, NULL},
	/******/
	/****f* test/resetdragonrank --重置神龙殿排行榜
	* 名称
	 *  resetdragonrank -- 
	 * 用法
	 *   resetdragonrank 
	 * 权限
	 */
	{"resetdragonrank", gm_resetdragonrank, GM_POWER_FOURTH, NULL},
	/******/
	/****f* test/setbibleactjointime --设置角色记录的指定宝典活动的上次参加时间
	* 名称
	 *  setbibleactjointime -- 
	 * 用法
	 *  setbibleactjointime <ActID> <DaysBeforeToday>
	 * 权限
	 */
	{"setbibleactjointime", gm_set_bible_act_last_jointime, GM_POWER_FOURTH, NULL},
	/******/
	/****f* test/quizact --答题活动相关GM
	* 名称
	 *  quizact -- 
	 * 用法
	 *   quizact setrightnum <num: 0-100> 
	 * 权限
	 */
	{"quizact", gm_quizact, GM_POWER_FOURTH, NULL},
	/******/
	/****f* airshipwar/airshipwar --飞空战场相关
	 * 名称
	 *   airshipwar -- 飞空战场相关GM
	 * 用法
	 *   airshipwar entersceen 进入飞空战场副本
	 *   airshipwar setcampmembernum <camp max member num> 设置单个阵营参加人数上限
	 *   airshipwar ranklist 查看本月排行信息
	 *   airshipwar rankshift 更新上月排行信息
	 *   airshipwar rankreset 清空全部排行数据
	 */
	{"airshipwar", gm_airshipwar, GM_POWER_FOURTH, NULL},
	/******/	

	{"equipsoul", gm_equipsoul, GM_POWER_FOURTH, NULL},
	/******/

	/****f* lottertact/lotteryact --抽奖活动相关
	 * 名称
	 *   lottertact -- 抽奖活动相关GM
	 * 用法
	* lotteryact bet <isbet> <npc1> 	<npc2> <npc3> <npc4> <npc5>	投注:  (0:查询1:投注)  ,投注NPC编号列表
	* lotteryact award <period> <betindex>	领奖: 期号投注序号(1-5) 
	* lotteryact result						查询开奖 
	* lotteryact history						查询往期记录
	* lotteryact setreckon <seconds after now>设置开奖时间: 相对于当前时间的秒数
	* lotteryact setsign <dayno: 1-30> <new value: 0 or 1>
	* lotteryact buyitem 购买投注道具
	* lotteryact cleardata 强制清除抽奖活动commdata数据
	* lotteryact setresult 设置本期开奖结果<npc1> <npc2> <npc3> <npc4> <npc5>
	* lotteryact setpool <val> 设置本服的奖池总额
	 */
	{"lotteryact", gm_lotteryact, GM_POWER_FOURTH, NULL},
	/******/

	{"raffle", gm_raffle, GM_POWER_FOURTH, NULL},
	/******/

	{"armrefine", gm_armrefine, GM_POWER_FOURTH, NULL},
	/******/

	/****f* rewardtoken/rewardtoken --悬赏令相关
	 * 名称
	 *   rewardtoken -- 悬赏令相关GM
	 * 用法
	* rewardtoken open <cardpos: 0 - 3> 翻开卡牌接取任务
	* rewardtoken acce 加速完成当前接取且未完成的悬赏令任务
	* rewardtoken reset刷新全部4张卡牌
	*/
	{"rewardtoken", gm_rewardtoken, GM_POWER_FOURTH, NULL},
	/******/
	/****f* hpmpcontainer/hpmpcontainer --血蓝缸相关
	 * 名称
	 *   hpmpcontainer -- 血蓝缸相关GM
	 * 用法
	 * 	//hpmpcontainer setreserve <type:101 hp 102 mp 103 pethp 104 petmp> <value>
	*/
	{"hpmpcontainer", gm_hpmpcontainer, GM_POWER_FOURTH, NULL},
	/******/
};

int sort_gm_cmd_func(const void* pv1, const void* pv2)
{
	GMMAP* pstMap1;
	GMMAP* pstMap2;

	pstMap1	= (GMMAP*)pv1;
	pstMap2	= (GMMAP*)pv2;
	if(pstMap1 == NULL || pstMap2 == NULL)
	{
		return -1;
	}
	if(pstMap1->pszCmd == NULL || pstMap2->pszCmd == NULL)
	{
		return -1;
	}

	return strncasecmp(pstMap1->pszCmd, pstMap2->pszCmd, GM_MAX_CMD_LEN);
}

int gm_get_val(const char** ppszCmd, char* szBuff, int iBuff)
{
	size_t iLen;

	iLen = strcspn(*ppszCmd, GM_SEP_STR);

	if(iLen >= iBuff)
		return -1;

	if(iLen)
		memcpy(szBuff, *ppszCmd, iLen);
	szBuff[iLen] = '\0';

	*ppszCmd = *ppszCmd + iLen;

	iLen = strspn(*ppszCmd, GM_SEP_STR);

	*ppszCmd = *ppszCmd + iLen;

	return 0;
}

/*
 * Func :  gm_extract_target_role
 * Desc:  提取GM指令字符串中可能有的角色,如果不包含下列三个指向角色的标志，那么默认为本角色执行
 *        [destuin | destname |destzid ]
 *		 如果有uin 和 name 或 destzid，则返回LPROLE, 没有指定或查找失败返回NULL
 *		 在传入的标志位中告诉调用者，是否有指定角色
 */
LPROLE  gm_extract_target_role(const char** ppszCmd ,char *pchHasDest)
{
	char szStr[MAX_ROLE_NAME_LEN];
	LPROLE pstRole = NULL;
	size_t iLen;
	iLen = strcspn(*ppszCmd, GM_SEP_STR);
	if(iLen >= MAX_ROLE_NAME_LEN)
		return NULL;
	if(iLen)
		memcpy(szStr, *ppszCmd, iLen);
	szStr[iLen]	= '\0';

	if(!strncasecmp(szStr, "destuin", sizeof("destuin")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			pstRole = uin_to_role(atoll(szStr));
		}
	}
	else if(!strncasecmp(szStr, "destname", sizeof("destname")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			pstRole = name_to_role(szStr);
		}
	}
	else if(!strncasecmp(szStr, "destzid", sizeof("destzid")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			pstRole = zid_to_role(atoll(szStr));
		}
	}
	return pstRole;
}

/*
 * Func :  gm_extract_target_guild
 * Desc:  提取GM指令字符串中可能有的角色,如果不包含下列三个指向角色的标志，那么默认为本角色执行
 *        [guildname | guildgid ]
 *		 如果有guildname 和 guildgid，则返回LPGUILD, 没有指定或查找失败返回NULL
 *		 在传入的标志位中告诉调用者，是否有指定家族
 */
LPGUILD  gm_extract_target_guild(const char** ppszCmd,char *pchHasDest)
{
	char szStr[MAX_ROLE_NAME_LEN];
	LPGUILD pstGuild = NULL;
	size_t iLen;
	iLen = strcspn(*ppszCmd, GM_SEP_STR);
	if(iLen >= MAX_ROLE_NAME_LEN)
		return NULL;
	if(iLen)
		memcpy(szStr, *ppszCmd, iLen);
	szStr[iLen]	= '\0';

	if(!strncasecmp(szStr, "guildname", sizeof("guildname")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			pstGuild = get_guild_by_name(szStr);
		}
	}
	else if(!strncasecmp(szStr, "guildgid", sizeof("guildgid")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			pstGuild = get_guild_by_gid(atoll(szStr));
		}
	}
	else if(!strncasecmp(szStr, "guildid", sizeof("guildid")))
	{
		if(pchHasDest != NULL)
		{
			*pchHasDest = 1;
		}
		*ppszCmd = *ppszCmd + iLen;
		iLen = strspn(*ppszCmd, GM_SEP_STR);
		*ppszCmd = *ppszCmd + iLen;
		gm_get_val(ppszCmd,szStr,MAX_ROLE_NAME_LEN);
		if(szStr[0])
		{
			int iGuildID = atoll(szStr);
			unsigned long long ullGuildGID = 0;
			generate_guild_gid(&ullGuildGID,get_sys_worldid(), iGuildID);
			pstGuild = get_guild_by_gid(ullGuildGID);
		}
	}
	return pstGuild;
}


//执行GM指令
int gm_cmd(LPROLE pstRole, const char* pszArg)
{
	char szCmd[GM_MAX_CMD_LEN];
	char szTmpCmd[GM_MAX_CMD_LEN];
	GMMAP stMap;
	GMMAP* pstEntry = NULL;
	int iRet = 0;

	static int s_fSorted = 0;

	if(s_fSorted == 0)
	{
		qsort(g_astEntries, sizeof(g_astEntries)/sizeof(GMMAP), sizeof(GMMAP), sort_gm_cmd_func);
		s_fSorted = 1;
	}

	strncpy(szTmpCmd, pszArg, sizeof(szTmpCmd));
	szTmpCmd[GM_MAX_CMD_LEN - 1] = '\0';

	if(strncasecmp(pszArg, GM_PREFIX, GM_PREFIX_LEN))
	{
		return 0;
	}

	pszArg += GM_PREFIX_LEN;

	if(gm_get_val(&pszArg, szCmd, sizeof(szCmd)) < 0)
	{
		return 0;
	}

	stMap.pszCmd = szCmd;
	pstEntry = (GMMAP*)bsearch(&stMap, g_astEntries, sizeof(g_astEntries)/sizeof(GMMAP), sizeof(GMMAP), sort_gm_cmd_func);

	if(!pstEntry || !pstEntry->pfnEntry)
		return 0;

	//检查权限
	//防止GM的权限被配置为0
	if(pstRole->ulUin < gs_ulUinBegin || pstRole->ulUin > gs_ulUinEnd)
	{
		if(!(get_gmpower(pstRole) & pstEntry->bPowerNeeded) || 0 == pstEntry->bPowerNeeded)
		{
			//system_msg_to_role(pstRole, "not enough power");
			return -1;
		}
	}

	if(pstEntry->pszArg)
	{
		iRet = (*pstEntry->pfnEntry)(pstRole, pstEntry->pszArg);
	}
	else
	{
		iRet = (*pstEntry->pfnEntry)(pstRole, pszArg);
	}

	LPPLAYER pstPlayer = uin_to_player(pstRole->ulUin);
	if(pstPlayer == NULL)
	{
		log_info(LOG_ERR,"%s:gmcmd fatal error role(%u:%s) not found player obj to use gm cmd:%s",__FUNCTION__,pstRole->ulUin,pstRole->szName,szCmd);
		return -1;
	}
	log_info(LOG_ERR,"%s:!!! not error. gmcmd role(%u:%s) from ip:%s use gm command(%s)",__FUNCTION__,pstRole->ulUin,pstRole->szName,get_proc_str_by_id(pstPlayer->stConndInfo.ulClientIP),szCmd);

	if(iRet < 0)
	{
		log_info(LOG_ERR,"%s:gmcmd role(%u:%s) from ip:%s use gm command(%s) failed.",__FUNCTION__,pstRole->ulUin,pstRole->szName,get_proc_str_by_id(pstPlayer->stConndInfo.ulClientIP),szCmd);
		return -1;
	}
	else
	{
		return 1;
	}

	return 0;
}


int gm_catchrole(LPROLE pstRole, const char *pszArg)
{

	//只支持在普通地图拉或者玩家的地图实例同自己一致
	char szTemp[128];
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, "Usage:catchrole <nickname>");
		return -1;
	}

//	unsigned int ulTargetUin = atoll(szTemp);
//	LPROLE pstTargetRole = uin_to_role(ulTargetUin);
	LPROLE pstTargetRole = name_to_role(szTemp);
	if(pstTargetRole == NULL)
	{
		system_msg_to_role(pstRole,"fail to find target role by uin.");
		return -1;
	}		

	if( is_role_at_pworld(pstRole))
	{
		system_msg_to_role(pstRole," target role at pworld. should not transfer.");
		return -1;
	}

	int iNewbieMap = get_revive_map(&pstTargetRole->stObject.stMapInstIndex);
	POSITION stPos;
        LPMAPINDEX pstMapIndex = find_map_index(iNewbieMap, NULL);
        if (pstMapIndex && 0 == get_revive_pos(pstMapIndex, &stPos))
        {
                 role_change_normalmap(pstTargetRole, iNewbieMap, &stPos);
        }
	system_msg_to_role(pstRole,"success transfer role to revive map pos.");

	send_sys_notice_msg(pstTargetRole,NULL, CS_CODE_TRANSFER_ROLE_TO_REVIVE_POINT_BY_GM, NULL, NULL, NULL,NULL);
		
	return 0;

}

/*
 *@Desc:结算威望排名的GM命令
 */
 /*
int gm_charm_backup(LPROLE pstRole,const char*pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	int iRet = on_decrease_all_online_role_charm_req(get_sys_env());
	return iRet;
}
*/

int gm_hugrole(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
        {
               return -1;
        }
	
	//只支持在普通地图拉或者玩家的地图实例同自己一致
	char szTemp[128];
	LPROLE pstTargetRole = NULL;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, "Usage:hugrole uin <uin> | rolename <rolename>");
		return -1;
	}

	if (0 == strncmp(szTemp, "uin", 128))
        {
               gm_get_val(&pszArg, szTemp, sizeof(szTemp));
               if (szTemp[0] == 0)
               {
                       system_msg_to_role(pstRole, "Usage:hugrole uin <uin> | rolename <rolename>");
                       return  -1;
               }
               pstTargetRole = uin_to_role(atoll(szTemp));
       }
       else if (0 == strncmp(szTemp, "rolename", 128))
       {
               gm_get_val(&pszArg, szTemp, sizeof(szTemp));
               if (szTemp[0] == 0)
               {
                       system_msg_to_role(pstRole, "Usage:hugrole uin <uin> | rolename <rolename>");
                       return  -1;
               }
               pstTargetRole = name_to_role(szTemp);
       }
       else
       {
               system_msg_to_role(pstRole, "Usage:hugrole uin <uin> | rolename <rolename>");
               return  -1;
       }

	//unsigned int ulTargetUin = atoll(szTemp);
	//LPROLE pstTargetRole = uin_to_role(ulTargetUin);
	//LPROLE pstTargetRole = name_to_role(szTemp);
	if(pstTargetRole == NULL)
	{
		system_msg_to_role(pstRole,"fail to find target role by uin or rolename.");
		return -1;
	}		
/**

	if(pstRole->stObject.stMapInstIndex.ullID == pstTargetRole->stObject.stMapInstIndex.ullID)
	{
		// 同地图更新坐标位置
                LPMAPINST pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
                if(pstMapInst == NULL)
                {
                        log_info_m(LOG_MODULE_PWORLD,LOG_ERR,"%s: mapinst not foundfail to re init ",__FUNCTION__);
			system_msg_to_role(pstRole,"fail to find role mapinst.");
			return -1;
                }
                if(object_update_pos(&pstTargetRole->stObject,pstMapInst,&pstRole->stObject.stPos) < 0)
                {
                        log_info_m(LOG_MODULE_PWORLD,LOG_ERR,"%s: fail to re init object pos ",__FUNCTION__);
			system_msg_to_role(pstRole,"fail to update to pos.");
			return -1;
                }

		return 0;
	}
*/

	if(is_role_at_pworld(pstTargetRole))
	{
		role_exit_pworld(pstTargetRole,0,0,0,0,__FUNCTION__);	

	}

	if(is_role_at_pworld(pstRole))
	{
		system_msg_to_role(pstRole,"hugrole : youself at pworld, this cmd should used at common map.");
		return -1;
	}
	
	LPMAPINST pstDstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if(pstDstMapInst == NULL)
	{
		system_msg_to_role(pstRole,"fail to find role mapinst.");
		return -1;
	}	

	send_sys_notice_msg(pstTargetRole, NULL,CS_CODE_TRANSFER_ROLE_TO_GM_SELF_BY_GM, NULL, NULL, NULL,NULL);
	
	object_change_map(&pstTargetRole->stObject, pstDstMapInst, &pstRole->stObject.stPos,NULL);
		
	return 0;

}


int gm_goto(LPROLE pstRole,const char*pszArg)
{
	// goto wMapID iX iY
	char szTemp[128];
	LPROLE pstTargetRole = NULL;
	unsigned short wMapID;
	int iX = 0, iY = 0;
	LPMAPINST pstMapInstDst;
	POSITION stPosDst;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(strncmp(szTemp,"role",sizeof(szTemp)) == 0)
	{
		//goto role pos.
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0]) 	
		{
			 if (0 == strncmp(szTemp, "uin",128))
                         {
                               gm_get_val(&pszArg, szTemp, sizeof(szTemp));
                               if (0 == szTemp[0])
                               {
                                      return -1;
                               }
                               pstTargetRole = uin_to_role(atoll(szTemp));
                         }
                         else if (0 == strncmp(szTemp, "rolename", 128))
                         {
	                           gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	                           if (0 == szTemp[0])
	                           {
	                                    return -1;
	                            }
	                             pstTargetRole = name_to_role(szTemp);
                          }
	                  else
	                  {
	                            system_msg_to_role(pstRole, "Usage:goto role uin <uin> | rolename <rolenname>");
	                            return -1;
	                  }
                       
			//unsigned int ulTargetUin = atoll(szTemp);
			//LPROLE pstTargetRole = uin_to_role(ulTargetUin);
			if(pstTargetRole == NULL)
			{
				system_msg_to_role(pstRole,"fail to find target role by uin or rolename.");
				return -1;
			}			
			if(is_role_at_pworld(pstRole))
			{
				system_msg_to_role(pstRole,"target role at pworld. fail to jump.");
				return -1;
			}	
			pstMapInstDst = find_map_inst_by_index(&pstTargetRole->stObject.stMapInstIndex);

			stPosDst.x  = pstTargetRole->stObject.stPos.x;
			stPosDst.y  = pstTargetRole->stObject.stPos.y;
			send_sys_notice_msg(pstRole, NULL,CS_CODE_TRANSFER_ROLE_TO_SOME_COORDINATE_BY_GM, NULL, NULL, NULL,NULL);
			return  object_change_map(&pstRole->stObject, pstMapInstDst, &stPosDst,NULL);
		}
		system_msg_to_role(pstRole,"fail to get target role uin or rolename.");
		return -1;
	}
	else if(strncmp(szTemp,"mapname",sizeof(szTemp)) == 0)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		LPMAP pstMap = get_map_def_list();		
		if ( !pstMap)  return -1;		
		int i = 0;
		char sTmpStr[256];
		for(i = 0; i < pstMap->iMapIndex; i++) //gm可以不用考虑效率，直接遍历即可
		{
			if((!szTemp[0]) || NULL != strstr(pstMap->astMapIndex[i].stSetting.szName, szTemp)) //szTemp[0]为空，表示所有的都发
			{
				sprintf(sTmpStr, "%s=%d", pstMap->astMapIndex[i].stSetting.szName, pstMap->astMapIndex[i].stSetting.wID);
				system_msg_to_role(pstRole, sTmpStr);
			}
		}
		return 0;		
	}
	else if(strncmp(szTemp,"fbname",sizeof(szTemp)) == 0)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		LPPWORLD  pstpWorld = get_pworld_setting();	
		if (!pstpWorld)  return -1;		
		int i = 0;
		char sTmpStr[256];
		for(i = 0; i < pstpWorld->iPworldIndex; i++) //gm可以不用考虑效率，直接遍历即可
		{
			if((!szTemp[0]) || NULL != strstr(pstpWorld->astPworldIndex[i].stSetting.szName, szTemp))
			{
				sprintf(sTmpStr, "%s=%d", pstpWorld->astPworldIndex[i].stSetting.szName, pstpWorld->astPworldIndex[i].stSetting.wID);
				system_msg_to_role(pstRole, sTmpStr);
			}
		}
		return 0;		
	}
	else if(strncmp(szTemp,"curmap",sizeof(szTemp)) == 0)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		stPosDst.x = atoi(szTemp);

		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		stPosDst.y = atoi(szTemp);
	
		role_instance_move(pstRole, &stPosDst, 0);  //为了测试，这不检查阻挡
		return 0;
	}
	

	if (szTemp[0]) wMapID = (unsigned short)atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iX = atoi(szTemp);

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iY = atoi(szTemp);
	stPosDst.x = iX;
	stPosDst.y = iY;
	
	if(stPosDst.x < 0 || stPosDst.y < 0) 
	{
		snprintf(szTemp, 127, "invalid point[%d,%d], goto failed.",  stPosDst.x, stPosDst.y);
		system_msg_to_role(pstRole, szTemp);
		return -1;
	}
	else if(stPosDst.x == 0 && stPosDst.y == 0) //没有指定点，传到复活点
	{
		LPMAPINDEX pstMapIndex = find_map_index(wMapID, NULL);
		if (pstMapIndex)
		{
			get_revive_pos(pstMapIndex, &stPosDst);
		}
	}

	if(0 == is_commstat(pstRole, RES_COMMSTAT_PK_JAIL)) //如果是坐牢状态，不允许goto
	{
		log_info_m(LOG_MODULE_MAP, LOG_DEBUG, "%s: uin(%u) is in jail, can't goto.", __FUNCTION__, get_role_uin(pstRole));
		return -1;	
	}

	if(is_role_at_pworld(pstRole) == 0 )
	{
		if(IS_GUILD_SCEEN_MAP(pstRole->stObject.stMapInstIndex.ullID) == 1 && MAP_INST_ID_TO_MAP_ID(pstRole->stObject.stMapInstIndex.ullID) == wMapID)
		{
			//如果是场景地图只能在本地图内跳转
			pstMapInstDst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
		}
		else
		{
			pstMapInstDst = find_map_inst(MAP_ID_TO_MAP_INST_ID(wMapID), NULL);
		}
	}
	else
	{
		if(wMapID != MAP_INST_ID_TO_MAP_ID(pstRole->stObject.stMapInstIndex.ullID))
		{
			// 禁止跨平行世界地图跳转
			// 否则请用pworld 命令
			log_info(LOG_WARN,"%s:forbidden jump in pworld map:%d",__FUNCTION__,wMapID);
			return -1;
		}
		log_info(LOG_TRACE,"%s find mapinst by index:(%lld:%d)",__FUNCTION__,
					pstRole->stObject.stMapInstIndex.ullID,pstRole->stObject.stMapInstIndex.iPos);

		pstMapInstDst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);

	}
	if (!pstMapInstDst)
	{
		log_info(LOG_WARN,"%s: fail to find map inst",__FUNCTION__);
		return -1;
	}

/*	暂时去掉，现阶段允许走到地图任意地点上
	if (iX <= 0 || iY <= 0 || 0 > map_valid_pos(pstMapInstDst,wMapID, &stPosDst))
	{
		if (0 > map_random_pos(pstMapInstDst,wMapID, &stPosDst)) return -1;
	}
*/

	if(stPosDst.x == 0 && stPosDst.y == 0) 
	{	
		//被传送到地图复活点
		send_sys_notice_msg(pstRole, NULL,CS_CODE_TRANSFER_ROLE_TO_REVIVE_POINT_BY_GM, NULL, NULL, NULL,NULL);
	}
	else
	{	
		//被传送到指定地点
		send_sys_notice_msg(pstRole, NULL,CS_CODE_TRANSFER_ROLE_TO_SOME_COORDINATE_BY_GM, NULL, NULL, NULL,NULL);
	}

	object_change_map(&pstRole->stObject, pstMapInstDst, &stPosDst,NULL);

	role_exit_pkplatform(pstRole, 0); //begin add by lcs for BT-QIECUO
	
	return 0;
}

int gm_createitem(LPROLE pstRole, const char* pszArg)
{
	log_info(LOG_TRACE,"%s: enter..", __FUNCTION__);

	char szID[32];
	char szNum[32];
	char szAttr[32]; // 创建随机掉落装备需要一个属性ID

	int iNum = 1;
	int iAttr = 0;
	gm_get_val(&pszArg,szID,sizeof(szID));
	gm_get_val(&pszArg,szNum,sizeof(szNum));
	gm_get_val(&pszArg,szAttr,sizeof(szAttr));

	LPITEM pstItem = NULL;
	if( !szID[0] )
	{
		//pstItem = random_dropitem(iNum);
		// 不支持随机创建物品
		return -1;
	}
	else
	{

		int iID =   atoi(szID);
		if( szNum[0] )
			iNum    =   atoi(szNum);
		if(szAttr[0])
			iAttr = atoi(szAttr);

		log_info(LOG_DEBUG,"%s:drop resid:%d number:%d iAttr:%d",__FUNCTION__,iID,iNum,iAttr);
		pstItem = dropitem_byresid(iID,iNum,iAttr, 
				DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL);
	}

	if(pstItem == NULL)
	{
		log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
		return -1;
	}

	LPMAPINST pstMapInst = NULL;
	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if (!pstMapInst)
	{
		log_info(LOG_ERR,"%s:fail to find map inst by index pos[%d] ID[%llx].", __FUNCTION__, pstRole->stObject.stMapInstIndex.iPos, pstRole->stObject.stMapInstIndex.ullID);
		return -1;
	}

	int iDist = 50;
	POSITION stPos;
	int wMapId = MAP_INST_ID_TO_MAP_ID(pstRole->stObject.stMapInstIndex.ullID);
	get_random_pos_in_map(pstMapInst,wMapId,&pstRole->stObject.stPos,iDist,&stPos);

	log_info(LOG_DEBUG,"role pos:(x:y)(%d:%d): drop pos:(x:y):(%d:%d)",
			pstRole->stObject.stPos.x,pstRole->stObject.stPos.y,stPos.x,stPos.y);

	item_enter_map(pstItem, pstMapInst, &stPos);


	return 0;
}

int gm_item(LPROLE pstRole, const char* pszArg)
{
	log_info(LOG_TRACE,"%s: enter..", __FUNCTION__);

	char szID[32];
	char szNum[32];
	char szAttr[32]; // 创建随机掉落装备需要一个属性ID
	char szSrc[32]; // 创建装备的来源
	char szArmSkill[32];

	int iID = 0;
	int iNum = 1;
	int iAttr = 888;//默认attr 通用方式
	int iSrc = DROP_STATIC_ARM_SRC_GM; //来源默认gm赠送

	gm_get_val(&pszArg,szID,sizeof(szID));
	gm_get_val(&pszArg,szNum,sizeof(szNum));
	gm_get_val(&pszArg,szAttr,sizeof(szAttr));
	gm_get_val(&pszArg,szSrc,sizeof(szSrc));
	gm_get_val(&pszArg,szArmSkill,sizeof(szArmSkill));

#define MAX_GM_CREATE_ITEM 10
	int iItemNum = 0;
	LPITEM apstItem[MAX_GM_CREATE_ITEM] = {};
	if( !szID[0] )
	{
		//pstItem = random_dropitem(iNum);
		// 不支持随机创建物品
		return -1;
	}
	else
	{

		iID =   atoi(szID);
		if( szNum[0] )
			iNum    =   atoi(szNum);
		if(szAttr[0])
			iAttr = atoi(szAttr);
		if(szSrc[0])
			iSrc = atoi(szSrc);

		if(is_wear_type(iID,NORMAL_ARM_TYPE) == 1 ||
			is_wear_type(iID,SPECIAL_ARM_TYPE))
		{
			if(iNum <= 0 || iAttr <= 0)
			{
				system_msg_to_role(pstRole,"item GM指令全格式为: //item <ID>  <Num>  <Attr> <Src>");
				system_msg_to_role(pstRole,"对于一般物品://item <ID> 即可. 默认数目: 1 默认来源: GM创建.");
				system_msg_to_role(pstRole,"对于随机和特殊装备，必须输入<ID>  <Num>  <Attr>.");
				system_msg_to_role(pstRole,"Src: 1 任务奖励 2 免费抽奖 3 付费抽奖 4 商店销售 5 GM赠送 7 怪物掉落.");
				system_msg_to_role(pstRole,"Attr: 不关注可以填 100 普通怪物装备掉落.");
				return -1;
			}
		}
		
		system_msg_to_role(pstRole,"item GM指令全格式为: //item <ID>  <Num>  <Attr> <Src>");
		system_msg_to_role(pstRole,"对于一般物品://item <ID> 即可. 默认数目: 1 默认来源: GM创建.");
		system_msg_to_role(pstRole,"对于随机和特殊装备，必须输入<ID>  <Num>  <Attr>.");
		system_msg_to_role(pstRole,"Src: 1 任务奖励 2 免费抽奖 3 付费抽奖 4 商店销售 5 GM赠送 7 怪物掉落.");
		system_msg_to_role(pstRole,"Attr: 不关注可以填 100 普通怪物装备掉落.");


		log_info(LOG_DEBUG,"%s:drop resid:%d number:%d iAttr:%d  src:%d",__FUNCTION__,iID,iNum,iAttr,iSrc);
		//pstItem = dropitem_byresid(iID,iNum,iAttr, iSrc);
		drop_multi_items_byresid(iID, iNum, iAttr, iSrc, ENM_LOOT_CONTROL_CODE_NORMAL, apstItem, MAX_GM_CREATE_ITEM, &iItemNum);
	}

	if(iItemNum <= 0)
	{
		log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
		return -1;
	}
	
	int i = 0;
	for (i = 0; i < iItemNum; ++i)
	{
		if(apstItem[i] == NULL)
		{
			log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
			continue;
		}

		if(can_put_item_in_commlist(pstRole,&apstItem[i]->stData.stItem,iID,apstItem[i]->stData.stItem.chNumber) == 0)
		{
			destroy_dropitem(apstItem[i]);
			continue;
		}

		if(!strncasecmp(szArmSkill, "skill", sizeof("skill")))
		{
			gm_get_val(&pszArg,szArmSkill,sizeof(szArmSkill));
			int iSkillID = atoi(szArmSkill);
			//确保技能存在且是装备技能
			LPRESSKILL pstResSkill = find_skill_def(iSkillID);
			if(NULL == pstResSkill || (RES_SYS_ARM_BIND != pstResSkill->chSystem && RES_SYS_INIT_ARM_BIND != pstResSkill->chSystem))
			{
				iSkillID = 0;
				system_msg_to_role(pstRole, "this arm skill not exist, no skill arm");
			}		
			if(CS_RES_ARM == apstItem[i]->stData.stItem.chResType)
			{
				apstItem[i]->stData.stItem.stItemAttr.stArmAttr.iSkillID = iSkillID;
			}
		}

		put_item(pstRole, apstItem[i], NULL, NULL, 1, 1);
	}
	return 0;
}

int gm_clearbag(LPROLE pstRole, const char* pszArg)
{
	CSLISTS stSvrS;
	LPZONECOMMITEMLIST pstZoneItemList;
	LPZONEITEM pstZoneItem;
	stSvrS.nEno = 0;
	stSvrS.chResultType = CS_LISTRESULT_CHANGE;
	stSvrS.stResult.stListDesc.chTotal = 0;
	pstZoneItemList = &pstRole->stRoleItem.stData.stCommItem;
	int i =0;
	for(; i < pstZoneItemList->iCount ; ++i)
	{
		pstZoneItem = pstZoneItemList->astItems+ i;
		if (0 == pstZoneItem->iResId)
		{
			continue;
		}
		pstZoneItem->ullGID = 0;
		pstZoneItem->chNumber = 0;
		pstZoneItem->iResId = 0;
		make_cs_item_pkg(&stSvrS,CS_LISTTYPE_COMMITEM, 0, pstZoneItem);
	}

	pstZoneItemList->iCount = 0;
	memset(pstRole->stRoleItemIndex.achCommListIndex2Pos, -1 , CS_MAX_COMMITEM_NUM);
	
	reply_server_pkg(pstRole->ulUin, CS_CMD_LIST, &stSvrS);
	return 0;
}

int gm_itemindex(LPROLE pstRole, const char* pszArg)
{
	char szID[32];
	char szMsg[1024];
	int iType = 0;
	int iBagIndex = 0;
	gm_get_val(&pszArg,szID,sizeof(szID));
	if(szID[0])
	{
		iType = atoi(szID);
	}
	gm_get_val(&pszArg,szID,sizeof(szID));
	if(szID[0])
	{
		iBagIndex = atoi(szID);
	}

	LPROLEITEMINDEX pstZoneAllIndex = &pstRole->stRoleItemIndex;
	int i = 0;
	switch(iType)
	{
		case CS_LISTTYPE_COMMITEM:
		{
			int iNum = 0;
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"CommList\n");
			for(i = 0 ; i < CS_MAX_COMMITEM_NUM; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"[%d]",(int)pstZoneAllIndex->achCommListIndex2Pos[i]);
				if((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\n");
				}
				if( pstZoneAllIndex->achCommListIndex2Pos[i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		case CS_LISTTYPE_STORAGE_ITEM:
		{
			int iNum = 0;
			if(iBagIndex < 0 || iBagIndex >= CS_MAX_STORAGE_TAB )
			{
				iBagIndex = 0;
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"Storage[%d] \n",iBagIndex);
			for(i = 0 ; i < CS_ONE_TAB_STORAGEITEM_NUM; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"[%d]",(int)pstZoneAllIndex->achStorageListIndex2Pos[iBagIndex][i]);
				if((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\n");
				}
				if( pstZoneAllIndex->achStorageListIndex2Pos[iBagIndex][i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		case CS_LISTTYPE_PET_LIST:
		{
			int iNum = 0;
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"PetList\n");
			for(i = 0 ; i < MAX_PET_LIST; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"[%d]",(int)pstZoneAllIndex->achPetListIndex2Pos[i]);
				if((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\n");
				}
				if( pstZoneAllIndex->achPetListIndex2Pos[i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		case CS_LISTTYPE_WEARBASE:
		{
			int iNum = 0;
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"WearList\n");
			for(i = 0 ; i < CS_MAX_WEAR; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"[%d]",(int)pstZoneAllIndex->achWearListIndex2Pos[i]);
				if((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\n");
				}
				if( pstZoneAllIndex->achWearListIndex2Pos[i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		case CS_LISTTYPE_RENT_STORAGE:
		{
			int iNum = 0;
			if(iBagIndex < 0 || iBagIndex >= CS_MAX_RENT_STORAGE_TAB )
			{
				iBagIndex = 0;
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"Rent Storage[%d] \n",iBagIndex);
			for(i = 0 ; i < CS_ONE_TAB_STORAGEITEM_NUM; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"[%d]",(int)pstZoneAllIndex->achRentStorageListIndex2Pos[iBagIndex][i]);
				if((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\n");
				}
				if( pstZoneAllIndex->achRentStorageListIndex2Pos[iBagIndex][i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		case CS_LISTTYPE_GENERAL_LIST:
		{
			int iNum = 0;
			if (0 > iBagIndex || iBagIndex >= CS_GENERAL_LIST_MAX_NUM)
			{
				iBagIndex = 0;
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg), "GeneralList[%d] \n", iBagIndex);
			LPGENERALLISTMAP pstGenaralListMap = get_general_list_map();
			for (i = 0 ; i < pstGenaralListMap->astListMap[iBagIndex].chListMax; ++i)
			{
				snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg), "[%d]", (int)pstZoneAllIndex->achGeneralListIndex2Pos[iBagIndex][i]);
				if ((i + 1) % 6 == 0)
				{
					snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg), "\n");
				}
				if ( pstZoneAllIndex->achGeneralListIndex2Pos[iBagIndex][i] != -1)
				{
					++iNum;
				}
			}
			snprintf(szMsg + strlen(szMsg), 1024 - strlen(szMsg),"\nTotal Item[%d]",iNum);
			system_msg_to_role(pstRole,szMsg);
			break;
		}
		default:
		{
			system_msg_to_role(pstRole,"//itemindex 1 -- CommList");
			system_msg_to_role(pstRole,"//itemindex 39  0 -- StorageList 0 Tag, Total [0 - 3]Tags");
			system_msg_to_role(pstRole,"//itemindex 30 -- WearList");
			system_msg_to_role(pstRole,"//itemindex 33 -- PetList");
			system_msg_to_role(pstRole,"//itemindex 43 0 -- GeneralList 0(Trump)");
			break;
		}
			
	}
	return 0;
}

int gm_createnpc(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iID;
	LPMAPINST pstMapInst = NULL;
	MONSTER stMon;
	LPMONSTER pstMon;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iID = atoi(szTemp);
	else return -1;

	if (iID < 0) return -1;
	
	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if (!pstMapInst)
	{
		log_info(LOG_ERR,"%s:fail to find map inst by index pos[%d] ID[%llx].", __FUNCTION__, pstRole->stObject.stMapInstIndex.iPos, pstRole->stObject.stMapInstIndex.ullID);
		return -1;
	}

	LPRESNPC pstResNPC = get_npc_by_id(iID);
	if(pstResNPC == NULL)
	{
		system_msg_to_role(pstRole,"fail to find resnpc by resnpc id.");	
		return -1;
	}

	memset(&stMon, 0, sizeof(stMon));
	MONSTER_STATUS_SET(&stMon, MONSTER_STATUS_DIE);

	stMon.iID = pstResNPC->iMonsterID;
	stMon.iNPCResID = iID;
	stMon.iOriginalID = stMon.iID;
	stMon.iListID = 0;
	//stMon.stObject.bDirection = RAND() % 180;
	stMon.chType = CS_TYPE_MONSTER;

	memcpy(&stMon.stOriginalPos, &pstRole->stObject.stPos, sizeof(stMon.stOriginalPos));
	// 死后不刷新
	stMon.chFlag = MONSTER_FLAG_NA;
	stMon.chType = CS_TYPE_NPC;
	pstMon =  new_monster(stMon.iID, &stMon);
	if(!pstMon)
	{
		log_info(LOG_ERR, "%s: new monster fail", __FUNCTION__);
		return -1;
	}

	if (0 > refresh_monster(pstMapInst, pstMon,0,0,0,0))
	{
		log_info(LOG_ERR, "%s: refresh monster fail", __FUNCTION__);
		return -1;
	}
	return 0;
}



int gm_createmonster(LPROLE pstRole,const char*pszArg)
{
	char szTemp[80];
	int iID, iNum;
	LPMAPINST pstMapInst = NULL;
	MONSTER stMon;
	LPMONSTER pstMon;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iID = atoi(szTemp);
	else
	{
		 system_msg_to_role(pstRole,"Usage://createmonster id num norefresh listid dir");  
		 return -1;
	}

	if (iID < 0) return -1;

	iNum = 1;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iNum = (unsigned short)atoi(szTemp);

	if (iNum < 0) iNum = 1;

	int iNoRefresh = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iNoRefresh = atoi(szTemp);
	

	int iListID = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iListID = atoi(szTemp);

	int iDir = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iDir = atoi(szTemp);
	
	short nGroupID = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) nGroupID = atoi(szTemp);
	
	
	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if (!pstMapInst)
	{
		log_info(LOG_ERR,"%s:fail to find map inst by index pos[%d] ID[%llx].", __FUNCTION__, pstRole->stObject.stMapInstIndex.iPos, pstRole->stObject.stMapInstIndex.ullID);
		return -1;
	}

	memset(&stMon, 0, sizeof(stMon));
	MONSTER_STATUS_SET(&stMon, MONSTER_STATUS_DIE);
	
	LPRESMONSTER pstMonsterDef = find_monster_def(iID,NULL);
    if(pstMonsterDef == NULL)
	{               
		log_info(LOG_ERR,"%s: fail to find monster def by monster id:%d",__FUNCTION__,iID);
		system_msg_to_role(pstRole,"wrong monster resid.,create failed.");
		return -1;
	}       
	
	stMon.iID = iID;
	stMon.iOriginalID = stMon.iID;
	stMon.iListID = iListID;
	if(iDir != 0)
	{
		stMon.bOriginDirection= iDir;
	}
	else
	{
		stMon.bOriginDirection= RAND() % 180;
	}
	stMon.chType = CS_TYPE_MONSTER;

	memcpy(&stMon.stOriginalPos, &pstRole->stObject.stPos, sizeof(stMon.stOriginalPos));
//	stMon.nOriginalDist = MONSTER_RAND_DIST;

	if(iNoRefresh == 1)
	{
		// 死后不刷新
		stMon.chFlag = MONSTER_FLAG_NA;
	}
	else
	{
		stMon.chFlag = MONSTER_FLAG_REFRESH;
	}
	if(iNum > 2000)
	{
		return -1;
	}
	int i = 0;
	for( ; i < iNum; i++)
	{
		pstMon =  new_monster(iID, &stMon);
		if(!pstMon)
		{
			log_info(LOG_ERR, "%s: new monster fail", __FUNCTION__);
			return -1;
		}

		if (0 > refresh_monster(pstMapInst, pstMon,0,0,0,0))
		{
			log_info(LOG_ERR, "%s: refresh monster fail", __FUNCTION__);
			return -1;
		}
		pstMon->chFlag = MONSTER_FLAG_NA;

		if (nGroupID) 
		{
			POSITION stPos;
			int iRet = monster_enter_group(pstMapInst, pstMon, nGroupID, 0, &stPos);
			if (iRet != 0)
			{
				log_info(LOG_ERR, "%s: monster entry Group[%d] error.", __FUNCTION__, nGroupID);
			}
		}

		system_msg_to_role(pstRole, "monster id:%d", pstMon->stObject.ulID);
	}

	return 0;
}

int gm_setspeed(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, "Usage:setspeed <sppeed>");
		return -1;
	}
	int iAddMoveSpeed = atoi(szTemp);
	ATTRREVLIST stRevList;
	stRevList.nTotal = 0;
	stRevList.astRev[stRevList.nTotal].chRevType = ATTR_REVTYPE_ADDEX;
	stRevList.astRev[stRevList.nTotal].nAttr = CS_ATTR_MOVESPEED;
	stRevList.astRev[stRevList.nTotal].iRevValue = iAddMoveSpeed;  	
	stRevList.nTotal++;
	set_role_movespeed(pstRole, &stRevList, 0);
	reply_server_pkg(pstRole->ulUin, CS_CMD_ROLE_REV_ATTR, &stRevList); 
	return 0;		
}

/*
 *@Desc: GM加威望
 */
int gm_addcharm(LPROLE pstRole, const char* pszArg)
{	
	if (NULL == pstRole || NULL == pszArg)
	{
		log_info_m(LOG_MODULE_CHARM, LOG_ERR, "%s:The Param is NULL!", __FUNCTION__);
		return -1;
	}
	
	char szTemp[80] = {0};
	int iCharmAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iCharmAdd = atoi(szTemp);
	}
	else
	{
		system_msg_to_role(pstRole, "Usage:addcharm <value>");
		return -1;
	}

	if (iCharmAdd == 0) 
	{
		return -1;
	}

	add_role_charm(pstRole, iCharmAdd);

	/*
	if (LEVEL_LIMIT_CHARM_RANK <= get_role_level(pstRole))
	{
		send_update_role_charm_info_req(pstRole->ullGID, pstRole->iCharm);//发送更新角色威望值请求到misc
	}
	*/
	
	return 0;
}

int gm_addtp(LPROLE pstRole, const char* pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		log_info_m(LOG_MODULE_CHARM, LOG_ERR, "%s:The Param is NULL!", __FUNCTION__);
		return -1;
	}
	
	char szTemp[80] = {0};
	int iTpAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iTpAdd = atoi(szTemp);
	}
	else
	{
		system_msg_to_role(pstRole, "Usage:addtp <value>");
		return -1;
	}

	change_role_curtrump_curtp(pstRole, iTpAdd);

	return 0;
}

int gm_addessence(LPROLE pstRole, const char* pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		log_info(LOG_ERR, "%s:The Param is NULL!", __FUNCTION__);
		return -1;
	}
	
	char szTemp[64] = {0};
	int iEssenceAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iEssenceAdd = atoi(szTemp);
	}
	else
	{
		system_msg_to_role(pstRole, "Usage:addessence <value>");
		return -1;
	}

	change_role_essence(pstRole, iEssenceAdd, 1);

	return 0;
}

int gm_addvigour(LPROLE pstRole, const char* pszArg)
{
	char szTmp[64];
	int iVigour = 0;
	char chType = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		if (!strncasecmp(szTmp, "heaven", sizeof("heaven")) && 
			!strncasecmp(szTmp, "earth", sizeof("earth")))
		{
			system_msg_to_role(pstRole, "Usage:addvigour heaven\earth value");
			return -1;
		}
		else
		{
			if (!strncasecmp(szTmp, "heaven", sizeof("heaven")))
			{
				chType = 1;
			}
			else
			{
				chType = 2;
			}
		}
	}
	else
	{
		system_msg_to_role(pstRole, "Usage:addvigour heaven\earth value");
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (!szTmp[0])
	{
		system_msg_to_role(pstRole, "Usage:addvigour heaven\earth value");
		return -1;
	}
	else
	{
		iVigour = atoi(szTmp);
	}

	if (1 == chType)
	{
		change_role_heaven_vigour(pstRole, iVigour);
	}
	else
	{
		change_role_earth_vigour(pstRole, iVigour);
	}
	
	return 0;
}

int gm_trumpuncd(LPROLE pstRole, const char* pszArg)
{
	if (NULL == pstRole)
	{
		return -1;
	}
	pstRole->iTrumpCD = time(NULL);
	return 0;
}

int gm_addskillpoints(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	int iAddSkillPoints = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iAddSkillPoints = atoi(szTemp);
		LPZONEITEM pstZoneItem = get_current_active_trump(pstRole);
		if (NULL != pstZoneItem)
		{
			CSITEMID stCSItemID;
			stCSItemID.chType = CS_LISTTYPE_GENERAL_LIST;
			stCSItemID.chBagIndex = CS_GENERAL_LIST_TRUMP_INDEX;
			stCSItemID.chItemIndex = pstZoneItem->chGridIndex;
			stCSItemID.chNum = 1;
			
			if ((0 > iAddSkillPoints) && (abs(iAddSkillPoints) > pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpSkillPoint))
			{
				pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpSkillPoint = 0;
			}
			else
			{
				pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpSkillPoint += iAddSkillPoints;
			}
			
			update_roleitem(pstRole, &stCSItemID, pstZoneItem);
			return 0;
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return -1;
	}
}

int gm_addrefinelevel(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	int iAddRefineLevel = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iAddRefineLevel = atoi(szTemp);
		LPZONEITEM pstZoneItem = get_current_active_trump(pstRole);
		if (NULL != pstZoneItem)
		{
			CSITEMID stCSItemID;
			stCSItemID.chType = CS_LISTTYPE_GENERAL_LIST;
			stCSItemID.chBagIndex = CS_GENERAL_LIST_TRUMP_INDEX;
			stCSItemID.chItemIndex = pstZoneItem->chGridIndex;
			stCSItemID.chNum = 1;
			
			if ((0 > iAddRefineLevel) && (abs(iAddRefineLevel) > pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpRefineLevel))
			{
				pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpRefineLevel = 0;
			}
			else
			{
				pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stTrumpAttr.bTrumpRefineLevel += iAddRefineLevel;
			}
			
			update_roleitem(pstRole, &stCSItemID, pstZoneItem);
			report_trump_refine(pstRole, pstZoneItem);//通知任务系统
			return 0;
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return -1;
	}
}

int gm_addxp(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	long long llXPAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) llXPAdd = atoll(szTemp);

	if (llXPAdd <= 0)
	{
		if(get_role_xp(pstRole) < -llXPAdd) //不够减
		{
			return -1;
		}
		add_role_xp(pstRole, llXPAdd, GAIN_XP_MODE_GM_CMD, 0);	
	}
	else
	{		
		add_role_xp(pstRole, llXPAdd, GAIN_XP_MODE_GM_CMD, 0);
		//UserLog:经验产出(GM指令直接加经验)
		syslog_role_xp_output(pstRole, llXPAdd, SYSLOG_ROLE_XP_OUTPUT_OTHER);
	}

	sprintf(szTemp, "当前经验值: %d*20亿+%d", pstRole->iHighBitXP, pstRole->iXP);
	system_msg_to_role(pstRole,szTemp);

	return 0;
}
int gm_addhp(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	int iHPAdd;

	iHPAdd = 0;

	if(0 == is_commstat(pstRole, RES_COMMSTAT_DEAD))
	{
		return -1;
	}

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iHPAdd = atoi(szTemp);

	add_role_curhp(pstRole, iHPAdd);

	if (get_role_curhp(pstRole) <= 0)
	{
		
		check_pworld_role_dead_sensor(pstRole,NULL);
		notify_role_killer(pstRole, pstRole->stObject.ulID);
		role_die(pstRole);		
		
	}


	return 0;
}

int gm_addmp(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	int iMPAdd;

	iMPAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iMPAdd = atoi(szTemp);

	add_role_curmp(pstRole, iMPAdd);

	return 0;
}

int gm_addlp(LPROLE pstRole, const char* pszArg)
{
	char szTemp[80];
	int iLPAdd;

	iLPAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iLPAdd = atoi(szTemp);

	add_role_leftpoints(pstRole, iLPAdd);

	return 0;
}

int gm_addep(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iEPAdd;

	iEPAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iEPAdd = atoi(szTemp);

	add_role_curep(pstRole, iEPAdd);

	return 0;
}

int gm_addsp(LPROLE pstRole, const char* pszArg)
{
#if 0
	CSSKILLS stSkillS;
	char szTemp[80];
	int iSPAdd;

	iSPAdd = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iSPAdd = atoi(szTemp);

	if (iSPAdd <= 0) return -1;

	pstRole->nLeftSP += iSPAdd;
	if (pstRole->nLeftSP < 0)
	{
		pstRole->nLeftSP = 0;
	}

	stSkillS.nEno = 0;
	stSkillS.chOp = CS_SKILL_OP_INFO;
	stSkillS.nLeftSP = pstRole->nLeftSP;
	stSkillS.stSkill.chCount = 0;

	reply_server_pkg(pstRole->ulUin, CS_CMD_SKILL, &stSkillS);
#endif

	return 0;
}

int gm_setlevel(LPROLE pstRole, const char* pszArg)
{
	char szTemp[256];
	if(NULL == pstRole)
	{
		return -1;
	}
	int iRoleLevel = get_role_level(pstRole);
	int iSetLevel =0 ;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iSetLevel = atoi(szTemp);
	if (iSetLevel <= iRoleLevel || iSetLevel > RES_MAX_ROLE_LEVEL) 
	{
		system_msg_to_role(pstRole, "设置的等级要比当前等级高");
		return -1;
	}

	LPRESROLELEVEL pstCurRoleLevel = NULL;
	long long llXPAdd = 0;
	int i ;
	for(i = iRoleLevel; i < iSetLevel; ++i)
	{
		pstCurRoleLevel = role_attr_find_level(i, pstRole->chProf);
		if (NULL == pstCurRoleLevel)
		{
			log_info_m(LOG_MODULE_ROLE,LOG_ERR,"%s: fail to find role attr level res def. level:prof (%d:%d)",__FUNCTION__,i,pstRole->chProf);
			return -1;
		}
		llXPAdd += pstCurRoleLevel->iMaxXP;
	}
	
	llXPAdd -= get_role_xp(pstRole);
	add_role_xp(pstRole, llXPAdd, GAIN_XP_MODE_GM_CMD, 0);
	//UserLog:经验产出(GM升等级)
	syslog_role_xp_output(pstRole, llXPAdd, SYSLOG_ROLE_XP_OUTPUT_OTHER);

	
	sprintf(szTemp, "当前经验值: %d*20亿+%d", pstRole->iHighBitXP, pstRole->iXP);
	system_msg_to_role(pstRole,szTemp);
	
	return 0;
}

int gm_addminattack(LPROLE pstRole,const char *pszArg)
{
	char szTemp[80];
	int iMinAttackAdd = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iMinAttackAdd = atoi(szTemp);
	log_info(LOG_DEBUG,"%s: add min attack:%d",__FUNCTION__,iMinAttackAdd);
	change_role_attr(pstRole,ATTR_REVTYPE_ADD,CS_ATTR_MINPHYSATK,iMinAttackAdd);

	return 0;
}

int gm_addattr(LPROLE pstRole,const char *pszArg)
{
	char szTemp[80];
	int iValue = 0;
	int iType = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iType = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iValue = atoi(szTemp);
	
	log_info(LOG_DEBUG,"%s: add attr %d: %d",__FUNCTION__, iType,iValue);
	change_role_attr(pstRole,ATTR_REVTYPE_ADDEX,iType,iValue);

	//上面没法送消息，这儿发送一下，以便单点测试属性
	ATTRREVLIST stRevList;
	stRevList.nEno = CS_ENO_NOERR;
	stRevList.nTotal = 0;
	stRevList.astRev[stRevList.nTotal].chRevType = ATTR_REVTYPE_ADDEX;
	stRevList.astRev[stRevList.nTotal].nAttr = iType;
	stRevList.astRev[stRevList.nTotal].iRevValue = iValue;
	stRevList.nTotal++;
	reply_server_pkg(pstRole->ulUin, CS_CMD_ROLE_REV_ATTR, &stRevList);

	return 0;
}

int gm_addpetattr(LPROLE pstRole,const char *pszArg)
{
	char szTemp[80];
	int iValue = 0;
	int iType = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iType = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iValue = atoi(szTemp);
	
	log_info(LOG_DEBUG,"%s: add attr %d: %d",__FUNCTION__, iType,iValue);
	ATTRREV stRev;
	stRev.nAttr = iType;
	stRev.chRevType = ATTR_REVTYPE_ADDEX;
	stRev.iRevValue =  iValue;
	LPPET pstPet = get_pet_by_role(pstRole);
	if(NULL == pstPet)
	{
		return -1;
	}	
	if( 0 > pet_attr_rev_one_attr(pstPet, &stRev))
		return -1;

	//上面没法送消息，这儿发送一下，以便单点测试属性
	CSPETSATTRREVLISTS stPetRevLists;
	stPetRevLists.nEno = CS_ENO_NOERR;
	stPetRevLists.chTotal = 1;
	stPetRevLists.astAttrRevLists[0].chPetIndex = get_pet_index(pstPet);

	LPATTRREVLIST pstRevList = &stPetRevLists.astAttrRevLists[0].stAttrRevList;
	pstRevList->nEno = CS_ENO_NOERR;
	pstRevList->nTotal = 0;
	pstRevList->astRev[pstRevList->nTotal].chRevType = ATTR_REVTYPE_ADDEX;
	pstRevList->astRev[pstRevList->nTotal].nAttr = iType;
	pstRevList->astRev[pstRevList->nTotal].iRevValue = iValue;
	pstRevList->nTotal++;
	reply_server_pkg(pstPet->ulUin, CS_CMD_PET_REV_ATTR, &stPetRevLists);
	return 0;
}

//给角色身上加钱(4种)
int gm_addmoney(LPROLE pstRole,const char *pszArg)
{
	char szTemp[80];
	int iAddMoney = 0;
	int iAddMoneyCerti = 0;
	int iGoldCerti = 0;
	int iGold = 0;	
	char szMsg[1024];

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iAddMoney = atoi(szTemp);
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iAddMoneyCerti = atoi(szTemp);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iGold = atoi(szTemp);
	

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iGoldCerti = atoi(szTemp);


	snprintf(szMsg,1024,"gm add money: silvermoney(%d) silvercerti(%d) gold(%d) goldcerti(%d)",
				iAddMoney,iAddMoneyCerti,iGold,iGoldCerti);

	system_msg_to_role(pstRole,szMsg);

	if(0 != check_change_role_property(pstRole, iAddMoney, iGold, iGoldCerti, iAddMoneyCerti, LOG_PROPERTY_GM_CMD))
	{
		system_msg_to_role(pstRole,"fail to add money check_change role property fail.");
		return 0;
	}



	int iAddSilver = SYSLOG_ROLE_MONEY_CHANGE_SILVER_INCREASE_GM;
	int iAddSilverCerti = SYSLOG_ROLE_SILVER_CERTI_GENERATE_TYPE_GM;
	int iAddGold = SYSLOG_ROLE_GOLD_GENERATE_TYPE_GM;
	int iAddGoldCerti  = SYSLOG_ROLE_GOLD_CERTI_GENERATE_GM;
	open_userlog_item_save_module();//开
	int iRet = change_role_property(pstRole, iAddMoney, iGold, iGoldCerti, iAddMoneyCerti, LOG_PROPERTY_GM_CMD);
	close_userlog_item_save_module();//关
	if (0 == iRet)
	{
		if (0 > iAddMoney)
		{
			iAddSilver = SYSLOG_ROLE_MONEY_CHANGE_SILVER_DECREASE_GM;

		}
		if (0 > iAddMoneyCerti)
		{
			iAddSilverCerti = SYSLOG_ROLE_MONEY_CERTI_CHANGE_SILVER_DECREASE_GM;
		}
		if (0 > iGold)
		{
			iAddGold = SYSLOG_ROLE_GOLD_CONSUME_TYPE_GM;
		}
		if (0 > iGoldCerti)
		{
			iAddGoldCerti = SYSLOG_ROLE_GOLD_CERTI_CONSUME_GM;
		}
		//UserLog:角色金钱变化(GM)
		syslog_role_money_change(pstRole, get_userlog_global_itemchg(),
		iAddGold, iAddGoldCerti,
		iAddSilver, iAddSilverCerti);
		syslog_role_other_consume_gold_change_to_shop_buy(pstRole, iAddGold, get_userlog_global_itemchg());
	}
	
	return iRet;
}

int gm_createpet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iPetResID;
	int iRet = 0;
	LPITEM pstItem = NULL;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "createpet PetResID");
			return 0;
		}
		iPetResID = atoi(szTemp);
	}else
	{
		return -1;
	}

	
	
	pstItem = new_dropitem(CS_RES_PET,iPetResID, 1);
	if(pstItem == NULL)
	{
		return -1;
	}
	
	LPRESPET pstResPet = get_pet_by_item(&pstItem->stData.stItem);
	if(pstResPet == NULL)
	{
		destroy_dropitem(pstItem);
		return -1;
	}
	
	iRet = create_pet_real(iPetResID, &pstItem->stData.stItem);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "create_pet_real error");
		return iRet;
	}else
	{
		iRet = put_item(pstRole,pstItem,NULL, NULL, 1, 1);
		if(iRet != 0)
		{
			system_msg_to_role(pstRole, "put_item error");
			return iRet;
		};
	}

	return 0;
}

int gm_addpetmp(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	int iMPPoints = 0;
	LPPET pstPet = NULL;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "addpetmp mp_point");
			return 0;
		}
		iMPPoints = atoi(szTemp);
	}else
	{
		return -1;
	}

	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	iRet = add_pet_curmp(pstPet, iMPPoints);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "add_pet_curmp error");
		return iRet;
	}

	return 0;
}

int gm_addpethp(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	int iHPPoints = 0;
	LPPET pstPet = NULL;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "addpethp hp_point");
			return 0;
		}
		iHPPoints = atoi(szTemp);
	}else
	{
		return -1;
	}
	
	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	
	iRet = add_pet_curhp(pstPet, iHPPoints);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "add_pet_curhp error");
		return iRet;
	}
	if (get_pet_curhp(pstPet) <= 0)
	{
		pet_die(pstPet);
	}
	
	return 0;
}

int gm_washpet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "washpet chStoreType chBagIndex chPetIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = wash_pet(pstRole, &stItemID);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "wash_pet error");
		return iRet;
	}

	return 0;
}

int gm_washaptitude(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "washaptitude chStoreType chBagIndex chPetIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = wash_aptitude(pstRole, &stItemID);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "wash_aptitude error");
		return iRet;
	}
	return 0;
}

int gm_maxpetaptitude(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pszArg || NULL == pstRole)
	{
		return -1;
	}
	
	int iIndex = 0;
	char szTemp[256];
	//char szMsg[1024];
	
	CSITEMID stCSItemID;
	stCSItemID.chBagIndex = -1;
	stCSItemID.chType = CS_LISTTYPE_PET_LIST;

	//提取宠物位置
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (0 == szTemp[0])
	{
		system_msg_to_role(pstRole, "Usage:maxpetaptitude <index> Bld | Str | Int | Hab");
		return -1;
	}
	iIndex = atol(szTemp);
	stCSItemID.chItemIndex = iIndex;
	
	//提取资质标识
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (0 == szTemp[0])
	{
		system_msg_to_role(pstRole, "Usage:maxpetaptitude <index> Bld | Str | Int | Hab");
		return -1;
	}
	if (0 == strncmp(szTemp, "Bld", 128))
	{
		set_pet_one_apti_to_max(pstRole, &stCSItemID, "Bld");
	}
	else if (0 == strncmp(szTemp, "Str", 128))
	{
		set_pet_one_apti_to_max(pstRole, &stCSItemID, "Str");
	}
	else if (0 == strncmp(szTemp, "Int", 128))
	{
		set_pet_one_apti_to_max(pstRole, &stCSItemID, "Int");
	}
	else if (0 == strncmp(szTemp, "Hab", 128))
	{
		set_pet_one_apti_to_max(pstRole, &stCSItemID, "Hab");
	}
	else
	{
		system_msg_to_role(pstRole, "Usage:maxpetaptitude <index> Bld | Str | Int | Hab");
		return -1;
	}
	
	return 0;
}

int gm_domespet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "domespet chStoreType chBagIndex chPetIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = domestication_pet(pstRole, &stItemID);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "domestication_pet error");
		return iRet;
	}

	return 0;
}

int gm_petdie(LPROLE pstRole,const char * pszArg)
{
//	char szTemp[80];
	int iRet = 0;
//	char chPetListIndex;
	LPPET pstPet;

/**
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petdie chPetListIndex");
			return 0;
		}
		chPetListIndex = atoi(szTemp);
	}else
	{
		return -1;
	}
*/
	pstPet = get_pet_by_role(pstRole);
	if(NULL ==pstPet)
	{
		return -1;
	}

	iRet = pet_die(pstPet);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "pet_die error");
		return iRet;
	}
	
	return 0;
}

int gm_petfruit(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petfruit chStoreType chBagIndex chPetIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = aptitude_fruit(pstRole, &stItemID, NULL);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "aptitude_fruit error");
		return iRet;
	}

	return 0;
}

int gm_petstrengthen(LPROLE pstRole,const char * pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;
	RESITEM stResItem;
	
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petstrengthen chStoreType chBagIndex chPetIndex nItemGrade");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		stResItem.nItemGrade = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = strengthen_pet(pstRole, &stResItem, &stItemID);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "strengthen_pet error");
		return iRet;
	}

	return 0;
}

int gm_strengthenpet(LPROLE pstRole, const char *pszArg)
{
	int iRet = 0;

	iRet = gm_strengthen_pet(pstRole);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "gm_strengthen_pet error");
		return iRet;
	}
	return 0;
}

int gm_washpointspet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	CSITEMID stItemID;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "washpointspet chStoreType chBagIndex chPetIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{ 
		chPetIndex = atoi(szTemp);
	}
	else
	{
		return -1;
	}
		
	stItemID.chType = chStoreType;
	stItemID.chBagIndex = chBagIndex;
	stItemID.chItemIndex = chPetIndex;

	iRet = wash_points_pet(pstRole, &stItemID);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "wash_points_pet error");
		return iRet;
	}

	return 0;
}

int gm_addpetxp(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	int iXPPoints = 0;
	LPPET pstPet = NULL;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "addpetxp xp_point");
			return 0;
		}
		iXPPoints = atoi(szTemp);
	}else
	{
		return -1;
	}

	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	iRet = add_pet_xp(pstPet, iXPPoints, GAIN_XP_MODE_GM_CMD, 0);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "add_pet_xp error");
		return iRet;
	}
	//UserLog:经验产出(GM加宠物经验)
	syslog_role_xp_output(pstRole, iXPPoints, SYSLOG_ROLE_XP_OUTPUT_OTHER);
	return 0;
}

int gm_awakepet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));

	iRet = awake_pet(pstRole);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "awake_pet error");
		return iRet;
	}

	return 0;
}

int gm_loadpet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	char chPetListIndex;
	CSPETLOAD stPetLoad;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "loadpet chStoreType chBagIndex chPetIndex chPetListIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetListIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stPetLoad.chType = chStoreType;
	stPetLoad.chBagIndex = chBagIndex;
	stPetLoad.chPetIndex = chPetIndex;
	stPetLoad.chPetListIndex = chPetListIndex;

	iRet = load_pet_cmd(pstRole, &stPetLoad);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "load_pet_cmd error");
		return iRet;
	}

	return 0;
}

int gm_unloadpet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chStoreType;
	char chBagIndex;
	char chPetIndex;
	char chPetListIndex;
	CSPETLOAD stPetUnload;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "unloadpet chStoreType chBagIndex chPetIndex chPetListIndex");
			return 0;
		}
		chStoreType = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chBagIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetListIndex = atoi(szTemp);
	}
	else 
	{
		return -1;
	}

	stPetUnload.chType = chStoreType;
	stPetUnload.chBagIndex = chBagIndex;
	stPetUnload.chPetIndex = chPetIndex;
	stPetUnload.chPetListIndex = chPetListIndex;

	iRet = unload_pet_cmd(pstRole, &stPetUnload);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "unload_pet_cmd error");
		return iRet;
	}

	return 0;
}

int gm_calluppet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chPetListIndex;
	CSPETCALL  stPetCallup;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "calluppet chPetListIndex");
			return 0;
		}
		chPetListIndex = atoi(szTemp);
	}else
	{
		return -1;
	}
	
	stPetCallup.chPetListIndex = chPetListIndex;

	iRet = callup_pet(pstRole, &stPetCallup);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "callup_pet error");
		return iRet;
	}
	LPPET pstPet = get_pet_by_role(pstRole);
	if (NULL != pstPet)
	{
		LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
		if (NULL == pstZonePetItem)
		{
			return -1;
		}

		send_sys_notice_msg(pstRole, NULL,CS_CODE_PET_IS_ACTIVATED, pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.szNick, NULL, NULL,NULL);
	}
	return 0;
}

int gm_callbackpet(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	char chPetListIndex;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "callbackpet chPetListIndex");
			return 0;
		}
		chPetListIndex = atoi(szTemp);
	}else
	{
		return -1;
	}
	

	iRet = callback_pet(pstRole, chPetListIndex);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "callback_pet error");
		return iRet;
	}

	return 0;
}

int gm_chg_pet_attr(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}
	char szTmp[128];
	char szMsg[1024];

	CSITEMID stItemID;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chBagIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chItemIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	
	LPZONEITEM pstZoneItem = get_zoneitem(pstRole, &stItemID);
	if(NULL == pstZoneItem)
	{
		log_info(LOG_ERR, "%s: this pos have no item.", __FUNCTION__);
		return -1;
	}

	if (CS_RES_PET != pstZoneItem->chResType)
	{
		snprintf(szMsg, sizeof(szMsg), "指定位置物品不是宠物.");
		log_info(LOG_ERR, "%s: item res error, not pet.", __FUNCTION__);
		return -1;
	}

	int iAttrType = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iAttrType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	if (0 == iAttrType)
	{
		int iCurValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iCurValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}
		short *piFailedTimes = &pstZoneItem->stItemAttr.stPetBaseAttr.stPetAttrMisc.nStrengthenFailedTimes;
		if (0 == iCurValue)
		{

		}	
		else 
		{
			*piFailedTimes += iCurValue;
		}
		
		update_roleitem(pstRole,&stItemID, pstZoneItem);
		
		snprintf(szMsg, sizeof(szMsg), "宠物当前强化祝福值为：%d.", *piFailedTimes);
		
		system_msg_to_role(pstRole,szMsg);
	}
	
	return 0;
}

int gm_petmasterskill(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	LPPET pstPet = NULL;
	int iSkillID = 0;
	LPZONEPETITEM pstZonePetItem = NULL;
	CSITEMID stPetPos;
	char chPetSkillGridIndex = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petmasterskill iSkillid chPetSkillGridIndex");
			return 0;
		}
		iSkillID = atoi(szTemp);
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		chPetSkillGridIndex = atoi(szTemp);
		if((chPetSkillGridIndex < CS_PET_SKILL_GRID_INDEX_MIN) ||(chPetSkillGridIndex > CS_PET_SKILL_GRID_INDEX_MAX))
		{
			return -1;
		}
	}
	else 
	{
		return -1;
	}
	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(pstZonePetItem == NULL)
	{
		return -1;
	}
	stPetPos.chType = CS_LISTTYPE_PET_LIST;
	stPetPos.chBagIndex = -1;
	stPetPos.chItemIndex = pstZonePetItem->stPetItem.chGridIndex;
	stPetPos.chNum = 1;
	
	iRet = pet_learn_skill(pstRole, &stPetPos, iSkillID, chPetSkillGridIndex);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "pet_learn_skill error");
		return iRet;
	}

	return 0;
}
int gm_petskillgriddecap(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	LPPET pstPet = NULL;
	LPZONEPETITEM pstZonePetItem = NULL;
	CSITEMID stPetPos;
	char chPetSkillGridIndex = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petskillgriddecap chPetSkillGridIndex");
			return 0;
		}
		chPetSkillGridIndex = atoi(szTemp);
	}else
	{
		return -1;
	}
	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(pstZonePetItem == NULL)
	{
		return -1;
	}
	stPetPos.chType = CS_LISTTYPE_PET_LIST;
	stPetPos.chBagIndex = -1;
	stPetPos.chItemIndex = pstZonePetItem->stPetItem.chGridIndex;
	stPetPos.chNum = 1;
	
	iRet = pet_decap_skill_grid(pstRole, &stPetPos, chPetSkillGridIndex);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "pet_decap_skill_grid error");
		return iRet;
	}
	return 0;
}
int gm_petskillgridreset(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iRet = 0;
	LPPET pstPet = NULL;
	LPZONEPETITEM pstZonePetItem = NULL;
	CSITEMID stPetPos;
	char chPetSkillGridIndex = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petskillgridreset chPetSkillGridIndex");
			return 0;
		}
		chPetSkillGridIndex = atoi(szTemp);
	}else
	{
		return -1;
	}
	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}
	pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(pstZonePetItem == NULL)
	{
		return -1;
	}
	stPetPos.chType = CS_LISTTYPE_PET_LIST;
	stPetPos.chBagIndex = -1;
	stPetPos.chItemIndex = pstZonePetItem->stPetItem.chGridIndex;
	stPetPos.chNum = 1;
	
	iRet = pet_skill_grid_reset(pstRole, &stPetPos, chPetSkillGridIndex);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "pet_skill_grid_reset error");
		return iRet;
	}
	return 0;
}

int gm_petcloneskill(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iSkillID = 0;
	int iLearnSkillPos = 0;
	LPZONEPETITEM pstZonePetItem = NULL;
	LPPET pstPet = NULL;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "petcloneskill skillid chSkillGridIndex");
			return 0;
		}
		iSkillID = atoi(szTemp);
	}else
	{
		system_msg_to_role(pstRole,"error:petcloneskill <skillid> empty.");
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) 
	{
		iLearnSkillPos = atoi(szTemp);
		if((iLearnSkillPos < CS_PET_SKILL_GRID_INDEX_MIN) ||(iLearnSkillPos > CS_PET_SKILL_GRID_INDEX_MAX))
		{
			return -1;
		}
	}
	else 
	{
		return -1;
	}
	
	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		system_msg_to_role(pstRole,"error:pet not active.");
		return -1;
	}
	pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(pstZonePetItem == NULL)
	{
		system_msg_to_role(pstRole,"error:not find pet item by pet.");
		return -1;
	}
	return pet_clone_skill_by_id(pstRole, pstZonePetItem, iLearnSkillPos, iSkillID);
}

int gm_petshowinfo(LPROLE pstRole, const char *pszArg)
{
	LPPET pstPet = NULL;

	pstPet = get_pet_by_role(pstRole);
	if(pstPet == NULL)
	{
		return -1;
	}

	char szTemp[256];
	sprintf(szTemp, "hp: %d/%d, mp: %d/%d", get_pet_curhp(pstPet), get_pet_maxhp(pstPet), 
								get_pet_curmp(pstPet), get_pet_maxmp(pstPet));

	system_msg_to_role(pstRole, szTemp);

	return 0;
}

int gm_add_pet_list(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iAddPetListNum = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "addpetlist 1/2");
			return 0;
		}
		iAddPetListNum = atoi(szTemp);
	}else
	{
		system_msg_to_role(pstRole,"error:addpetlist 1/2");
		return -1;
	}

	pstRole->stRoleItem.stData.stPetList.chCount += iAddPetListNum;
	if(pstRole->stRoleItem.stData.stPetList.chCount > MAX_PET_LIST)
	{
		pstRole->stRoleItem.stData.stPetList.chCount = MAX_PET_LIST;
	}

	return 0;
}

int gm_report(LPROLE pstRole, const char *pszArg)
{

	char szGMMsgTemp[256];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
		pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szGMMsgTemp);

	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Invalid Cmd Input.");

	char szTemp[80];
	char szCmdType[32]={0};
	gm_get_val(&pszArg,szCmdType,sizeof(szCmdType));

	//任务报告
	if (!strncasecmp(szCmdType, "task", sizeof("task")))
	{
		
		int iParam[4] = {0,0,0,0};
		char chContinueFlag = 0;
		int iRound = 0;
		do{
			chContinueFlag = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iParam[iRound ++ ] = atoi(szTemp);
				chContinueFlag = 1;
			}
		}while(chContinueFlag == 1 && iRound < 4);
		
		MESSAGE stMessage;
		stMessage.enmType = iParam[0];
		stMessage.pstRole = pstDestRole;  
		stMessage.pstMonster = NULL;
		stMessage.iID = iParam[1];
		stMessage.iTargetID = iParam[2];
		stMessage.iNumber = iParam[3];
		stMessage.enmSourceType = ENM_MSG_SOURCE_TYPE_ORIGIN;
		report_message(&stMessage);	
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report A Message To Role[%u %s], Message[%d %d %d %d]",
			pstDestRole->ulUin,pstDestRole->szName,iParam[0],iParam[1],iParam[2],iParam[3]);
		
	}
	//报告副本付费开箱
	else if (!strncasecmp(szCmdType, "openboxpay", sizeof("openboxpay")))
	{
		do{
			int iPworldID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxpay <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <PworldID> Input;");
				break;
			}
			iPworldID = atoi(szTemp);
			
			int iPworldLevel;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxpay <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <PworldLevel> Input;");
				break;
			}
			iPworldLevel = atoi(szTemp);

			int iItemID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxpay <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <ItemID> Input;");
				break;
			}
			iItemID = atoi(szTemp);

			int iAttr = 0;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iAttr = atoi(szTemp);

			}
			
			LPITEM pstItem = dropitem_byresid(iItemID, 1, iAttr, 
					DROP_STATIC_ARM_SRC_PWORLD_PAY_AWARD, ENM_LOOT_CONTROL_CODE_NORMAL);
			if(NULL == pstItem)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxpay <PworldID> <PworldLevel> <ItemID> [Attr]\nCreate Item By ID add Attr Error;");
				break;
			}
			
			report_pworld_openbox_pay(pstDestRole, iPworldID, iPworldLevel, &pstItem->stData.stItem);

			destroy_dropitem(pstItem);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report OpenBox Pay With PwoldID[%d] PworldLevel[%d] ItemID[%d] ItemAttr[%d] OK.",
				iPworldID,iPworldLevel,iItemID,iAttr);
		}while(0);
		
	}
	//报告副本免费开箱
	else if (!strncasecmp(szCmdType, "openboxfree", sizeof("openboxfree")))
	{
		do{
			int iPworldID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxfree <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <PworldID> Input;");
				break;
			}
			iPworldID = atoi(szTemp);
			
			int iPworldLevel;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxfree <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <PworldLevel> Input;");
				break;
			}
			iPworldLevel = atoi(szTemp);

			int iItemID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxfree <PworldID> <PworldLevel> <ItemID> [Attr]\nNo <ItemID> Input;");
				break;
			}
			iItemID = atoi(szTemp);

			int iAttr = 0;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iAttr = atoi(szTemp);
			}
			
			LPITEM pstItem = dropitem_byresid(iItemID, 1, iAttr, 
					DROP_STATIC_ARM_SRC_PWORLD_FREE_AWARD, ENM_LOOT_CONTROL_CODE_NORMAL);
			if(NULL == pstItem)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report openboxfree <PworldID> <PworldLevel> <ItemID> [Attr]\nCreate Item By ID add Attr Error;");
				break;
			}
			
			report_pworld_openbox_free(pstDestRole, iPworldID, iPworldLevel, &pstItem->stData.stItem);

			destroy_dropitem(pstItem);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report OpenBox Free With PwoldID[%d] PworldLevel[%d] ItemID[%d] ItemAttr[%d] OK.",
				iPworldID,iPworldLevel,iItemID,iAttr);
		}while(0);
	}
	//报告抽奖事件
	else if (!strncasecmp(szCmdType, "raffle", sizeof("raffle")))
	{
		do{
			int iTimes;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report raffle <Times> \nNo <Times> Input;");
				break;
			}
			iTimes = atoi(szTemp);			
			
			report_raffle(pstDestRole, iTimes);
			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report Raffle Times[%d] OK.",iTimes);

		}while(0);
	}
	//报告副本得分事件
	else if (!strncasecmp(szCmdType, "pworldscore", sizeof("pworldscore")))
	{
		do{
			int iPworldID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report pworldscore <PworldID> <PworldLevel> <Score>\nNo <PworldID> Input;");
				break;
			}
			iPworldID = atoi(szTemp);
			
			int iPworldLevel;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report pworldscore <PworldID> <PworldLevel> <Score>\nNo <PworldLevel> Input;");
				break;
			}
			iPworldLevel = atoi(szTemp);
			
			int iScore;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report pworldscore <PworldID> <PworldLevel> <Score>\nNo <Score> Input;");
				break;
			}
			iScore = atoi(szTemp);
			
			report_pworld_score_msg(pstDestRole, iPworldID,iPworldLevel,iScore);
			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report pworldscore PworldID[%d] PworldLevel[%d] Score[%d] OK.",iPworldID,iPworldLevel,iScore);

		}while(0);
	}
	
	//报告完成活动事件
	else if (!strncasecmp(szCmdType, "finishact", sizeof("finishact")))
	{
		do{
			int iActID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum>\nNo <ActID> Input;");
				break;
			}
			iActID = atoi(szTemp);
			
			int iScore;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum>\nNo <Score> Input;");
				break;
			}
			iScore = atoi(szTemp);

			int iElapseTime;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum>\nNo <ElapseTime> Input;");
				break;
			}
			iElapseTime = atoi(szTemp);

			int iJoinNum;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum>\nNo <JoinNum> Input;");
				break;
			}
			iJoinNum = atoi(szTemp);

			int iDeadNum;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report finishact <ActID> <Score> <ElapseTime> <JoinNum> <DeadNum>\nNo <DeadNum> Input;");
				break;
			}
			iDeadNum = atoi(szTemp);
			
			report_finish_act(pstDestRole, iActID, iScore, iElapseTime,iJoinNum,iDeadNum);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report finishact With ActID[%d] Score[%d] ElapseTime[%d] JoinNum[%d] DeadNum[%d] OK.",
				iActID, iScore, iElapseTime,iJoinNum,iDeadNum);
		}while(0);
	}
	//报告队伍完成活动事件
	else if (!strncasecmp(szCmdType, "teamfinishact", sizeof("teamfinishact")))
	{
		do{
			int iActID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report teamfinishact <ActID> <Score> <ElapseTime>\nNo <ActID> Input;");
				break;
			}
			iActID = atoi(szTemp);
			
			int iScore;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report teamfinishact <ActID> <Score> <ElapseTime> \nNo <Score> Input;");
				break;
			}
			iScore = atoi(szTemp);

			int iElapseTime;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report teamfinishact <ActID> <Score> <ElapseTime> \nNo <ElapseTime> Input;");
				break;
			}
			iElapseTime = atoi(szTemp);

			report_team_finish_act(pstDestRole, iActID, iScore, iElapseTime);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report teamfinishact With ActID[%d] Score[%d] ElapseTime[%d] OK.",
				iActID, iScore, iElapseTime);
		}while(0);
	}

	//报告活动过轮
	else if (!strncasecmp(szCmdType, "runcycle", sizeof("runcycle")))
	{
		do{
			int iActID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report runcycle <ActID> <Cycle> <HitNum>  <ElapseTime>\nNo <ActID> Input;");
				break;
			}
			iActID = atoi(szTemp);
			
			int iCycle;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report runcycle <ActID> <Cycle> <HitNum>  <ElapseTime>\nNo <Cycle> Input;");
				break;
			}
			iCycle = atoi(szTemp);

			int iHitNum;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report runcycle <ActID> <Cycle> <HitNum>  <ElapseTime>\nNo <HitNum> Input;");
				break;
			}
			iHitNum = atoi(szTemp);

			int iElapseTime;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report runcycle <ActID> <Cycle> <HitNum>  <ElapseTime>\nNo <ElapseTime> Input;");
				break;
			}
			iElapseTime = atoi(szTemp);

			report_act_runcycle(pstDestRole, iActID,0, iCycle,iHitNum, iElapseTime);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report runcycle With ActID[%d] Cycle[%d] HitNum[%d] ElapseTime[%d] OK.",
				iActID, iCycle,iHitNum, iElapseTime);
		}while(0);
	}

	//报告活动后信息
	else if (!strncasecmp(szCmdType, "actinfo", sizeof("actinfo")))
	{
		do{
			int iActID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report actinfo <ActID> <ActLevel> <FoodPoint>  <Coef1>\nNo <ActID> Input;");
				break;
			}
			iActID = atoi(szTemp);
			
			int iActLevel;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report actinfo <ActID> <ActLevel> <FoodPoint>  <Coef1>\nNo <ActLevel> Input;");
				break;
			}
			iActLevel = atoi(szTemp);

			int iFoodPoint;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report actinfo <ActID> <ActLevel> <FoodPoint>  <Coef1>\nNo <FoodPoint> Input;");
				break;
			}
			iFoodPoint = atoi(szTemp);

			int iCoef1;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report actinfo <ActID> <ActLevel> <FoodPoint>  <Coef1>\nNo <Coef1> Input;");
				break;
			}
			iCoef1 = atoi(szTemp);

			report_act_information(pstDestRole, iActID, iActLevel,iFoodPoint, iCoef1);

			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report actinfo With ActID[%d] ActLevel[%d] FoodPoint[%d] Coef1[%d] OK.",
				iActID, iActLevel,iFoodPoint, iCoef1);
		}while(0);
	}


	//报告孵化宠物蛋
	else if (!strncasecmp(szCmdType, "petegg", sizeof("petegg")))
	{
		report_pet_egg(pstDestRole);

		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report petegg OK.");
	}
	//报告增加好友事件
	else if (!strncasecmp(szCmdType, "addfriend", sizeof("addfriend")))
	{
		do{
			int iFriendNum;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report addfriend <FriendNum> \nNo <FriendNum> Input;");
				break;
			}
			iFriendNum = atoi(szTemp);			
			
			report_add_friend(pstDestRole, iFriendNum);
			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report addfriend FriendNum[%d] OK.",iFriendNum);

		}while(0);
	}
	//报告使用物品使用忠义灯事件
	else if (!strncasecmp(szCmdType, "protectlamp", sizeof("protectlamp")))
	{
		do{
			int iItemID;
			szTemp[0] =0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"//report protectlamp <ItemID> \nNo <ItemID> Input;");
				break;
			}
			iItemID = atoi(szTemp);			
			
			report_protect_lamp(pstDestRole, NULL,iItemID);
			snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"Report protectlamp Use ItemID[%d] OK.",iItemID);

		}while(0);
	}
	
	system_msg_to_role(pstRole, szGMMsgTemp);	
	return 0;
	
}


/*
// title list  列出角色的所有已经获得的称号
// title check  <TitleID>  检查角色是否拥有某个称号
// title add  <TitleID>  给角色直接增加某个称号
// title remove <TitleID>  从角色身上移除某个称号
// title info   查看称号的所有辅助信息
// title team  < Num >  设置组队次数，结果为 Num + 1 ，因为设置之后，又通知了一次称号系统,下同
// title redrole  <Num> 设置杀死红名角色数目 结果为Num + 1
// title refine  <Num>  设置精炼操作的次数， 结果为Num + 1
// title sellitem <Num> 设置摆摊卖出的物品数目 ，结果为Num 
// title login  <Num>  设置连续登陆次数，结果为Num

*/
int gm_title(LPROLE pstRole, const char *pszArg)
{


	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
		pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szGMMsgTemp);

#define TMP_TITLE_CMD_LIST 1
#define TMP_TITLE_CMD_CHECK 2
#define TMP_TITLE_CMD_ADD   3
#define TMP_TITLE_CMD_REMOVE 4
#define TMP_TITLE_CMD_INFO 5
#define TMP_TITLE_CMD_SETTIMES 6

#define TMP_TITLE_CMD_RECORD 10
#define TMP_TITLE_CMD_REPORTHY 11
#define TMP_TITLE_CMD_REPORTZJ 12
#define TMP_TITLE_CMD_REPORTTY 13
#define TMP_TITLE_CMD_RECORDNUM 16
#define TMP_TITLE_CMD_REPAIR 18

	char szTemp[80];
	char szTemp1[80];
	short nCmd = 0;
	int i;
	int iTitleID = -1;
	int iParam = 0;
	char szTitleInfo[1024];

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "title list");
			system_msg_to_role(pstRole, "title check TitleID");
			system_msg_to_role(pstRole, "title add TitleID");
			system_msg_to_role(pstRole, "title remove TitleID");
			system_msg_to_role(pstRole, "title info");
			system_msg_to_role(pstRole, "title record");
			system_msg_to_role(pstRole, "title reporthy");
			system_msg_to_role(pstRole, "title reportzj");
			system_msg_to_role(pstRole, "title reportty");
			system_msg_to_role(pstRole, "title recordnum");			
			system_msg_to_role(pstRole, "title repair");
			return 0;
		}
		if(!strncasecmp(szTemp, "list", sizeof("list")))
		{
			nCmd = TMP_TITLE_CMD_LIST;
		}else if(!strncasecmp(szTemp, "check", sizeof("check")))
		{
			nCmd = TMP_TITLE_CMD_CHECK;
		}else if(!strncasecmp(szTemp, "add", sizeof("add")))
		{
			nCmd = TMP_TITLE_CMD_ADD;
		}else if(!strncasecmp(szTemp, "remove", sizeof("remove")))
		{
			nCmd = TMP_TITLE_CMD_REMOVE;
		}else if(!strncasecmp(szTemp, "info", sizeof("info")))
		{
			nCmd = TMP_TITLE_CMD_INFO;
		}
		else if(!strncasecmp(szTemp, "settimes", sizeof("settimes")))
		{
			nCmd = TMP_TITLE_CMD_SETTIMES;
		}
		else if(!strncasecmp(szTemp, "reporthy", sizeof("reporthy")))
		{
			nCmd = TMP_TITLE_CMD_REPORTHY;
		}
		else if(!strncasecmp(szTemp, "reportzj", sizeof("reportzj")))
		{
			nCmd = TMP_TITLE_CMD_REPORTZJ;
		}
		else if(!strncasecmp(szTemp, "reportty", sizeof("reportty")))
		{
			nCmd = TMP_TITLE_CMD_REPORTTY;
		}
		else if(!strncasecmp(szTemp, "recordnum", sizeof("recordnum")))
		{
			nCmd = TMP_TITLE_CMD_RECORDNUM;
		}
		else if(!strncasecmp(szTemp, "repair", sizeof("repair")))
		{
			nCmd = TMP_TITLE_CMD_REPAIR;
		}
	

	}else
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iTitleID = atoi(szTemp);
		gm_get_val(&pszArg,szTemp1,sizeof(szTemp1));
		if(szTemp1[0] != 0)
		{
			iParam = atoi(szTemp1);
			
		}
	}
	
	
	switch(nCmd)
	{
		case TMP_TITLE_CMD_LIST:
		{
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"------Title Num[%d]-----\n",pstDestRole->stAchievement.stAchieveData.stTitleInfo.iCount);	
			for(i = 0; i < pstDestRole->stAchievement.stAchieveData.stTitleInfo.iCount; ++i)
			{
				snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo)  - strlen(szTitleInfo),"[%d]",
					pstDestRole->stAchievement.stAchieveData.stTitleInfo.astTitle[i].wID);	

				if((i + 1) % 30 == 0)
				{
					system_msg_to_role(pstRole, szTitleInfo);
					szTitleInfo[0] = 0;
				}
			}
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo)  - strlen(szTitleInfo),"\nTotalPoint:%d Section:%d",
					pstRole->stAchievement.stAchieveData.stTitleInfo.iTotalAchievePoint,pstDestRole->stAchievement.bAchieveSection);	
			system_msg_to_role(pstRole, szTitleInfo);
			break;	
		}
		case TMP_TITLE_CMD_CHECK:
		{
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role Has Title[%d] ? %s",iTitleID,CHECK_TITLE_FLAG(pstDestRole, iTitleID) == 1 ? "Yes":"NO");
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_ADD:
		{
			if(CHECK_TITLE_FLAG(pstDestRole, iTitleID) == 1)
			{
				snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role Has Title[%d] already",iTitleID);
			}
			else
			{
				if(role_abtain_title(pstDestRole, iTitleID,NULL) < 0)
				{
					snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role abtain Title[%d] failed",iTitleID);
				}
				else
				{
					snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role abtain Title[%d] successful",iTitleID);
				}
			}
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_REMOVE:
		{
			if(CHECK_TITLE_FLAG(pstDestRole, iTitleID) == 0)
			{
				snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role Has no Title[%d].",iTitleID);
			}
			else
			{
				if(role_remove_title(pstDestRole, iTitleID,NULL) < 0)
				{
					snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role remove Title[%d] failed",iTitleID);
				}
				else
				{
					snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role remove Title[%d] successful",iTitleID);
				}
			}
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_SETTIMES:
		{
			if(!strncasecmp(szTemp, "team", sizeof("team")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wMakeTeamTimes = iParam;
				STRNCPY(szTemp,"Make Team",sizeof(szTemp));
				
			}else if(!strncasecmp(szTemp, "refine", sizeof("refine")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wRefineOpTimes = iParam;
				STRNCPY(szTemp,"Refin Fail",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "redrole", sizeof("redrole")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wKillRedRoleTimes = iParam;
				STRNCPY(szTemp,"Kill RedRole In Red Area",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "sellmoney", sizeof("sellmoney")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTradeInfo.ulP2pMoney = iParam;
				STRNCPY(szTemp,"Sell Money",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "freepet", sizeof("freepet")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wFreePetNum = iParam;
				STRNCPY(szTemp," Free Pet",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "login", sizeof("login")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.wLogTimes = iParam;
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastLoginTime = 1;
				STRNCPY(szTemp," Continue Login",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "tower", sizeof("tower")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueTowerNum = iParam;
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastTowerTime = 1;
				STRNCPY(szTemp," Continue tower",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "love", sizeof("love")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueLoveTimes = iParam;
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastLoveTime = 1;
				STRNCPY(szTemp," Continue love",sizeof(szTemp));
			}
			
			else if(!strncasecmp(szTemp, "groupbuy", sizeof("groupbuy")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueGroupBuyNum = iParam;
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastGroupBuyTime = 1;
				STRNCPY(szTemp,"Continue GroupBuy Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "guildtask", sizeof("guildtask")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueGuildTaskNum = iParam;
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastGuildTaskTime = 1;
				STRNCPY(szTemp,"Continue guildtask Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "finger", sizeof("finger")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stBlessInfo.wFingerWinTimes  = iParam;
				STRNCPY(szTemp," Finger Win",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "quiz", sizeof("quiz")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stBlessInfo.wQuizWinTimes = iParam;
				STRNCPY(szTemp," Quiz Win",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "perfectpet", sizeof("perfectpet")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wWashPerfectPetNum = iParam;
				STRNCPY(szTemp," Wash Perfect Pet",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "petegg", sizeof("petegg")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wPetEggNum = iParam;
				STRNCPY(szTemp,"Pet Egg",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "star", sizeof("star")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wGuildStarNum = iParam;
				STRNCPY(szTemp,"Guild Star Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "guildstuff", sizeof("guildstuff")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.dwGuildStuffNum = iParam;
				STRNCPY(szTemp,"Commit Guild Stuff",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "protectlamp", sizeof("protectlamp")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wProtectLamp = iParam;
				STRNCPY(szTemp,"Total ProtectLamp Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "miji", sizeof("miji")))
			{
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wReleaseMijiNum = iParam;
				STRNCPY(szTemp,"Total MiJi Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "petpworld", sizeof("petpworld")))
			{
				reset_title_daily_info(&pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo);
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bDailyPetPworldNum = iParam;
				STRNCPY(szTemp,"DailyFinish Pet Pworld",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "killouter", sizeof("killouter")))
			{
				reset_title_daily_info(&pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo);
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.wDailyKillOuterRoleNum = iParam;
				STRNCPY(szTemp,"Daily Kill Outer",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "wabao", sizeof("wabao")))
			{
				reset_title_daily_info(&pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo);
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bDailyMingShanPworldNum = iParam;
				STRNCPY(szTemp,"Today Wabao Times",sizeof(szTemp));
			}
			else if(!strncasecmp(szTemp, "task", sizeof("task")))
			{
				int iTaskKey = 0;
				gm_get_val(&pszArg,szTemp1,sizeof(szTemp1));
				if(szTemp1[0] != 0)
				{
					iTaskKey = atoi(szTemp1);					
				}

				if(iParam <= 0 )
				{
					STRNCPY(szTemp,"No Task Key Input",sizeof(szTemp));
					break;
				}

				if(iTaskKey <= 0 )
				{					
					STRNCPY(szTemp,"Error Times Input",sizeof(szTemp));
					break;
				}
		
				unsigned int dwKey = 0;
				dwKey = (short)iTaskKey;
				dwKey = dwKey << 16;
				dwKey |= (short)0;

				int i = 0;
				LPASSISINFOTASK pstTaskAssis = NULL;
				for(i = 0 ;i < pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bTaskCount; ++i)
				{
					if( dwKey ==  pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[i].dwTaskKey)
					{
						pstTaskAssis= &pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[i];
						break;
					}
				}

				if(pstTaskAssis == NULL)
				{
					if(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bTaskCount >= MAX_TITLE_RECORD_TASK_FINSHED_NUM)
					{
						system_msg_to_role(pstRole, "Dest Role Record Task Extend Max, Set Error.");
						return 0;
					}
					
					pstTaskAssis= &pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bTaskCount];
					++pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bTaskCount;
					pstTaskAssis->dwTaskKey = dwKey;
					pstTaskAssis->wTimes = 0;
				}
				
				pstTaskAssis->wTimes = iParam;
				snprintf(szTemp,sizeof(szTemp),"TaskKey[%d] Finish Times",iTaskKey);
				
			}
			else
			{
				STRNCPY(szTemp,"UnDefine in GM",sizeof(szTemp));
			}

			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Role[%u %s] <%s> Num Set to[%d].",pstDestRole->ulUin,pstDestRole->szName,szTemp,iParam);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_REPORTHY:
		{
			report_bosomer_chg(pstDestRole,MAIN_TYPE_FOR_BOSOM_BEAUTY,iTitleID);
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Send a hongyan report for [%d].",iTitleID);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_REPORTZJ:
		{
			report_bosomer_chg(pstDestRole,MAIN_TYPE_FOR_BOSOM_INTIMATE,iTitleID);
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Send a zhiji report for [%d].",iTitleID);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_REPORTTY:
		{
			report_tianyuan_chg(pstDestRole,iTitleID);
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Send a tianyuan report for [%d].",iTitleID);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_REPAIR:
		{
			int iRepairNum = repair_role_title(pstDestRole);
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"Repair Role Title Successful, Repair[%d].",iRepairNum);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_RECORDNUM:
		{
			if(iTitleID == 0)
			{
				return system_msg_to_role(pstRole, "Must Input a Title.");
			}
			szTitleInfo[0]='\0';
	
			LPTITLEOPTION pstOption = find_title_option_by_id(iTitleID,0);
			if(NULL == pstOption)
			{
				snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo),"Not In Record ,so No role has this title.") ;
				return system_msg_to_role(pstRole,szTitleInfo);
			}

			pstOption->iAbtainNum += iParam;

			if(pstOption->iAbtainNum < 0)
			{
				pstOption->iAbtainNum = 0;
				pstOption->bRecordNum = 0;
			}
			else if(pstOption->iAbtainNum < pstOption->bRecordNum)
			{
				pstOption->bRecordNum = pstOption->iAbtainNum;
			}
			snprintf(szTitleInfo ,sizeof(szTitleInfo),"Title AbtainNum Change to[%d] RecordRole[%d].",pstOption->iAbtainNum,(int)pstOption->bRecordNum) ;
			system_msg_to_role(pstRole,szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_RECORD:
		{
			if(iTitleID == 0)
			{
				return system_msg_to_role(pstRole, "Must Input a Title.");
			}
			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"-------------Title[%d] Record-------------\n",iTitleID);
			
			LPTITLEOPTION pstOption = find_title_option_by_id(iTitleID,0);
			if(NULL == pstOption)
			{
				snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo),"Not In Record ,so No role has this title.") ;
				return system_msg_to_role(pstRole,szTitleInfo);
			}

			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"AbtainTimes[%d], RecordNum[%d]\n"
				"-------------End-------------",
				pstOption->iAbtainNum,pstOption->bRecordNum);
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		case TMP_TITLE_CMD_INFO:
		{
			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"----------AssisInfo.No1 BaseTimesInfo----------\n");
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"MakeTeam[%d] Refine[%d] KillRole[%d]\n"
				"TotalP2P[%d] FreePet[%d] WashPet[%d]\n"
				"PetEgg[%d] StarTimes[%d] GuildStuff[%d]\n"
				"ProtectLamp[%d] ReleaseMiJi[%d]\n"
				"QuizWin[%d] FingerWin[%d]\n"
				"-------------End-------------",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wMakeTeamTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wRefineOpTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wKillRedRoleTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTradeInfo.ulP2pMoney,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wFreePetNum,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wWashPerfectPetNum,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wPetEggNum,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wGuildStarNum,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.dwGuildStuffNum,				
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wProtectLamp,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wReleaseMijiNum,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stBlessInfo.wQuizWinTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stBlessInfo.wFingerWinTimes				
				);
			
			system_msg_to_role(pstRole, szTitleInfo);


			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"----------AssisInfo.No2 TaskInfo----------\n");
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"任务记录信息\n"
				"LedouBegin[%s]\n"
				"Series1[%d] TotalCount[%d]\n"
				"Task[Key %d : %d]\n"
				"Task[Key %d : %d]\n"
				"Task[Key %d : %d]\n"
				"Task[Key %d : %d]\n"
				"Task[Key %d : %d]\n"
				"Task[Key %d : %d]\n"			
				"-------------End-------------",
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.iLedouBeginTime),
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bSeries1Num,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.bTaskCount,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[0].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[0].wTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[1].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[1].wTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[2].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[2].wTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[3].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[3].wTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[4].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[4].wTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[5].dwTaskKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stTaskInfo.astTaskFinishInfo[5].wTimes	

				);
			
			system_msg_to_role(pstRole, szTitleInfo);

			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"----------AssisInfo.No3 PworldInfo----------\n");
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"副本记录信息[%d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"		
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"Pworld[Key %d : %d]\n"
				"-------------End-------------",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.bCount,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[0].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[0].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[1].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[1].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[2].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[2].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[3].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[3].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[4].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[4].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[5].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[5].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[6].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[6].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[7].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[7].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[8].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[8].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[9].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[9].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[10].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[10].bTimes,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[11].iKey,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stPworldInfo.astPworldInfo[11].bTimes

				);
			
			system_msg_to_role(pstRole, szTitleInfo);

			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"----------AssisInfo.No4 ContinueInfo----------\n");
			
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"Login[%d] Time[%s]\n",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.wLogTimes,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastLoginTime)
			);

			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"GuildTask[%d] Time[%s]\n",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueGuildTaskNum,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastGuildTaskTime)
			);

			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"GroupBuy[%d] Time[%s]\n",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueGroupBuyNum,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastGroupBuyTime)
			);

			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"MiZong[%d] Time[%s]\n",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueMizongNum,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastMizongTime)
			);

			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"Tower[%d] Time[%s]\n",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.bContinueTowerNum,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stContinueLogTimes.ulLastTowerTime)
			);
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,	"-------------End-------------");

			
			system_msg_to_role(pstRole, szTitleInfo);

			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"----------AssisInfo.No5 VisitInfo----------\n");
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"下面的访问地图类型"
				"中原[1]  南荒[2] 冥地[3] 西域[4]  东海[5]\n"
				"以下[%d]项有效\n"
				"Visit Map [Type %d : %d]\n"
				"Visit Map [Type %d : %d]\n"
				"Visit Map [Type %d : %d]\n"
				"Visit Map [Type %d : %d]\n"
				"Visit Map [Type %d : %d]\n"				
				"FasionNum[%d]\n"
				"ID1 [%d] ID2[%d] ID3[%d]\n"
				"ID4 [%d] ID5[%d]\n"
				"-------------End-------------",
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.bCount,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[0].chType,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[0].bTotal,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[1].chType,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[1].bTotal,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[2].chType,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[2].bTotal,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[3].chType,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[3].bTotal,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[4].chType,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.astVisitPlateInfo[4].bTotal,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.bFasionCount,
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.fasionList[0],
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.fasionList[1],
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.fasionList[2],
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.fasionList[3],
				pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stVisitInfo.fasionList[4]
				);
			
			system_msg_to_role(pstRole, szTitleInfo);

			szTitleInfo[0]='\0';
			snprintf(szTitleInfo,sizeof(szTitleInfo) ,"-------------AssisInfo.No6 DailyInfo-------------\n");
			snprintf(szTitleInfo + strlen(szTitleInfo),sizeof(szTitleInfo) -  strlen(szTitleInfo) ,
				"KillMon[%d]\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"DailyTime[%s]\n"
				"DailyKillMon[%d]\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"%d : %d\n"
				"KillOuterNum[%d] PetPworldNum[%d] MingShanNum[%d]\n"
				"-------------End-------------",
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bCount,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[0].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[0].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[1].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[1].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[2].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[2].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[3].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[3].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[4].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astKillMonsterInfo[4].wTimes,
				compactdatetime(pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.iDailyTime),
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bDailyKillCount,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[0].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[0].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[1].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[1].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[2].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[2].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[3].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[3].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[4].iMonsterID,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.astDailyKillMonsterData[4].wTimes,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.wDailyKillOuterRoleNum,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bDailyMingShanPworldNum,
				(int)pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.stKillMonInfo.bDailyPetPworldNum
				);
			
			system_msg_to_role(pstRole, szTitleInfo);
			break;
		}
		default:
			return -1;
	}
	return 0;
}

int gm_market(LPROLE pstRole,const char*pszArg)
{
	
#define TMP_MARKET_CMD_STOCK 1
#define TMP_MARKET_CMD_STOCKSHOUT 2
#define TMP_MARKET_CMD_PRICEWAVE 3


	char szTemp[80];
	short nCmd = 0;
	int iParam1 =0;
	//char szInfo[1024];

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "market stock");
			return 0;
		}
		if(!strncasecmp(szTemp, "stock", sizeof("stock")))
		{
			nCmd = TMP_MARKET_CMD_STOCK;
		}
		else if(!strncasecmp(szTemp, "shout", sizeof("shout")))
		{
			nCmd = TMP_MARKET_CMD_STOCKSHOUT;
		}
		else if(!strncasecmp(szTemp, "wave", sizeof("wave")))
		{
			nCmd = TMP_MARKET_CMD_PRICEWAVE;
		}
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam1 = atoi(szTemp);
	}
	
	switch(nCmd)
	{
		case TMP_MARKET_CMD_STOCK:
		{
			LPMARKETNOTELIST pstMarketList = get_marketnotelist_res();
			if(NULL == pstMarketList)
			{
				return -1;
			}
			pstMarketList->tLastStockOutTime = 0;
			system_msg_to_role(pstRole, "Svr Will be stock out in 10 sec.");
			break;	
		}
		case TMP_MARKET_CMD_STOCKSHOUT:
		{
			LPMARKETNOTELIST pstMarketList = get_marketnotelist_res();
			if(NULL == pstMarketList)
			{
				return -1;
			}
			if(pstMarketList->iLastStockOutListPos < 0)
			{
				return system_msg_to_role(pstRole, "There is no stock out item.");
			}
			pstMarketList->tLastStockOutShotTime = 0;
			pstMarketList->nStockOutShotTimes = 0;
			system_msg_to_role(pstRole, "Npc Will be shout in 10 sec.");
			break;	
		}
		case TMP_MARKET_CMD_PRICEWAVE:
		{
			LPMARKETNOTELIST pstMarketList = get_marketnotelist_res();
			if(NULL == pstMarketList)
			{
				return -1;
			}
			pstMarketList->tLastWaveTime = 0;
			system_msg_to_role(pstRole, "Svr Will be price wave in 10 sec.");
			break;	
		}
		default:
			return -1;
	}
	return 0;
}


#define TMP_TASK_REMOVE_FINISH 2020
#define TMP_TASK_FINISH 2021
#define TMP_TASK_GETACCEPTLIST 2022
#define TMP_TASK_FINISHPPWORLD 2023
#define TMP_TASK_GETPRACTICE_TIME 2024
#define TMP_TASK_ADDPRACTICE_TIME 2025
#define TMP_TASK_LIST_FINISH 2026
#define TMP_TASK_PWORLD_SCORE 2027
#define TMP_TASK_SET_CURCYCLE 2028

int gm_task(LPROLE pstRole, const char *pszArg)
{

	/*提取操作对象*/
	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
		pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szGMMsgTemp);


	CSTASKC stTaskC;
	char szTemp[80];
	short nCmd = 0;
	int iParam0 = -1;
	int iParam1 = -1;
	int iParam2 = -1;
	char szTaskInfo[1024];
	memset(szTaskInfo,0,sizeof(szTaskInfo));

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//task accept <TaskID> <CycleID>");
		system_msg_to_role(pstRole, "//task submit <TaskID>");
		system_msg_to_role(pstRole, "//task remove <TaskID>");
		system_msg_to_role(pstRole, "//task getinfo <TaskID>");
		system_msg_to_role(pstRole, "//task removefinish <TaskID>");
		system_msg_to_role(pstRole, "//task addfinish <TaskID>");
		system_msg_to_role(pstRole, "//task getacceptlist <TaskID>");
		system_msg_to_role(pstRole, "//task finishpworld <PworldID> <Difficult>");
		system_msg_to_role(pstRole, "//task pworldscore <PworldID> <Difficult> <score>");
		system_msg_to_role(pstRole, "//task getpracticetime 1");
		system_msg_to_role(pstRole, "//task addpracticetime <Time(s)>");
		system_msg_to_role(pstRole, "//task setcycle <TaskID> <Num>");
		system_msg_to_role(pstRole, "//task listfinish");
		return 0;
	}
	if(!strncasecmp(szTemp, "accept", sizeof("accept")))
	{
		nCmd = CS_TASK_ACCEPT;
	}else if(!strncasecmp(szTemp, "submit", sizeof("submit")))
	{
		nCmd = CS_TASK_SUBMIT;
	}else if(!strncasecmp(szTemp, "remove", sizeof("remove")))
	{
		nCmd = CS_TASK_REMOVE;
	}else if(!strncasecmp(szTemp, "getinfo", sizeof("getinfo")))
	{
		nCmd = CS_TASK_GET_TASK_INFO;
	}else if(!strncasecmp(szTemp, "removefinish", sizeof("removefinish")))
	{
		nCmd = TMP_TASK_REMOVE_FINISH;
	}else if(!strncasecmp(szTemp, "addfinish", sizeof("addfinish")))
	{
		nCmd = TMP_TASK_FINISH; 
	}
	else if(!strncasecmp(szTemp,"getacceptlist",sizeof("getacceptlist")))
	{
		nCmd = TMP_TASK_GETACCEPTLIST;
	}
	else if(!strncasecmp(szTemp,"finishpworld",sizeof("finishpworld")))
	{
		nCmd = TMP_TASK_FINISHPPWORLD;
	}
	else if(!strncasecmp(szTemp,"getpracticetime",sizeof("getpracticetime")))
	{
		nCmd = TMP_TASK_GETPRACTICE_TIME;
	}
	else if(!strncasecmp(szTemp,"addpracticetime",sizeof("addpracticetime")))
	{
		nCmd = TMP_TASK_ADDPRACTICE_TIME;
	}
	else if(!strncasecmp(szTemp,"setcycle",sizeof("setcycle")))
	{
		nCmd = TMP_TASK_SET_CURCYCLE;
	}
	else if(!strncasecmp(szTemp,"listfinish",sizeof("listfinish")))
	{
		nCmd = TMP_TASK_LIST_FINISH;
	}
	else if(!strncasecmp(szTemp,"pworldscore",sizeof("pworldscore")))
	{
		nCmd = TMP_TASK_PWORLD_SCORE;
	}
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam0 = atoi(szTemp);
		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0)
		{
			iParam1 = atoi(szTemp);
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iParam2 = atoi(szTemp);
			}
		}
	}

	
	
	memset(&stTaskC, 0, sizeof(stTaskC));
	stTaskC.chTaskMsgType = nCmd;
	stTaskC.iTaskID = iParam0;
	switch(nCmd)
	{
		case CS_TASK_ACCEPT:
			break;
		case CS_TASK_SUBMIT:
			stTaskC.stData.stTaskSubmit.chSelectNumber = 0;
			stTaskC.stData.stTaskSubmit.nSubmitNumber = 0;
			stTaskC.stData.stTaskSubmit.ulNPCID = 0;
			break;
		case CS_TASK_REMOVE:
			break;
		case CS_TASK_GET_TASK_INFO:
			break;
		case TMP_TASK_REMOVE_FINISH:
		case TMP_TASK_PWORLD_SCORE:
		case TMP_TASK_FINISH:
		case TMP_TASK_GETACCEPTLIST:
		case TMP_TASK_FINISHPPWORLD:
		case TMP_TASK_GETPRACTICE_TIME:
		case TMP_TASK_ADDPRACTICE_TIME:
		case TMP_TASK_LIST_FINISH:
		case TMP_TASK_SET_CURCYCLE:
			break;
		default:
			return -1;
	}
	switch(nCmd)
	{
		case CS_TASK_ACCEPT:
			oss_accept_task(pstDestRole,iParam0,iParam1);
			break;
		case CS_TASK_SUBMIT:
		case CS_TASK_REMOVE:
		case CS_TASK_GET_TASK_INFO:
			task_cmd(pstDestRole, &stTaskC);
			break;
		case TMP_TASK_REMOVE_FINISH:
			return task_remove_finished_from_permanence(&pstDestRole->stTaskData.stTaskManagement.stTaskPermanence, iParam0);
			break;
		case TMP_TASK_FINISH:
			return record_finish_task_permanence(&pstDestRole->stTaskData.stTaskManagement, iParam0, TASK_TYPE_MASTERSTROKE);
		case TMP_TASK_GETACCEPTLIST:
		{
			char szInfo[1024];
			char chTaskNum = pstDestRole->stTaskData.stTaskManagement.chTaskNumber;
			snprintf(szInfo,1024,"task num:%d",chTaskNum);	
			system_msg_to_role(pstRole,szInfo);
			int i = 0;
			for( ; i < chTaskNum; i++)
			{
				snprintf(szInfo,1024,"task id:%d",pstDestRole->stTaskData.stTaskManagement.astTasks[i].iID);
				system_msg_to_role(pstRole,szInfo);
			}
			break;
		}
		case TMP_TASK_FINISHPPWORLD:
		{
			PWORLDINST stTmpPworldInst;
			stTmpPworldInst.ullID = 0x0000000000000000;
			stTmpPworldInst.ullID = iParam0;
			stTmpPworldInst.ullID = stTmpPworldInst.ullID << 16; 
			stTmpPworldInst.ullID |= 1;
			stTmpPworldInst.ullID = stTmpPworldInst.ullID << 32; 
			stTmpPworldInst.ullID |= 1;
			stTmpPworldInst.stPworldStat.chLevel = iParam1;
			stTmpPworldInst.iSetLevelTime = time(NULL) - iParam2;
			stTmpPworldInst.iCreateTime = stTmpPworldInst.iSetLevelTime;
			stTmpPworldInst.stPworldStat.wMiniGameID = 0;
				
			report_pworld_finish_msg(pstDestRole, &stTmpPworldInst);
			break;
		}
		case TMP_TASK_PWORLD_SCORE:
		{
			report_pworld_score_msg(pstDestRole, iParam0, iParam1, iParam2);
			break;
		}
		case TMP_TASK_GETPRACTICE_TIME:
		{
			int i =0;
			time_t tCurTime = 0;
			time(&tCurTime);
			LPTASK pstTask = NULL;
			for(; i < pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.nCycleTaskNumber; ++i)
			{
				if(pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.astCycleTasks[i].chTaskType == TASK_TYPE_PRACTICE)
				{
					pstTask = task_get(&pstDestRole->stTaskData.stTaskManagement, pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.astCycleTasks[i].iCycleTaskID);
					if(NULL == pstTask)
					{
						continue;
					}
					sprintf(szTaskInfo+strlen(szTaskInfo), "practice task [%d].\n",pstTask->iID);
					sprintf(szTaskInfo+strlen(szTaskInfo),  "practice task accept time [%s].\n",ctime((time_t *)&pstTask->ulAcceptTime));
					sprintf(szTaskInfo+strlen(szTaskInfo),  "当前系统时间 [%s].",ctime(&tCurTime));
					system_msg_to_role(pstRole, szTaskInfo);
					break;
				}
			}
			system_msg_to_role(pstRole, "No practice task.");
			break;
		}
		case TMP_TASK_ADDPRACTICE_TIME:
		{
			int i =0;
			time_t tCurTime = 0;
			time(&tCurTime);
			LPTASK pstTask = NULL;
			for(; i < pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.nCycleTaskNumber; ++i)
			{
				if(pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.astCycleTasks[i].chTaskType == TASK_TYPE_PRACTICE)
				{
					pstTask = task_get(&pstDestRole->stTaskData.stTaskManagement, pstDestRole->stTaskData.stTaskManagement.stCycleTaskList.astCycleTasks[i].iCycleTaskID);
					if(NULL == pstTask)
					{
						continue;
					}
					sprintf(szTaskInfo+strlen(szTaskInfo),  "practice task [%d].\n",pstTask->iID);
					sprintf(szTaskInfo+strlen(szTaskInfo),  "Before: practice task accept time [%s].\n",ctime((time_t *)&pstTask->ulAcceptTime));
					
					pstTask->ulAcceptTime += iParam0;
					
					sprintf(szTaskInfo+strlen(szTaskInfo), "After : practice task accept time [%s].",ctime((time_t *)&pstTask->ulAcceptTime));
					sprintf(szTaskInfo+strlen(szTaskInfo),  "当前系统时间 [%s].",ctime(&tCurTime));
					system_msg_to_role(pstRole, szTaskInfo);
					break;
				}
			}
			system_msg_to_role(pstRole, "No practice task.");
			break;
		}
		case TMP_TASK_SET_CURCYCLE:
		{
			LPZONECYCLETASK pstCycleTask = get_cycle_task(&pstDestRole->stTaskData.stTaskManagement.stCycleTaskList,iParam0);
			if(NULL == pstCycleTask)
			{
				sprintf(szTaskInfo+strlen(szTaskInfo),  "您没有这个循环任务[%d].\n",iParam0);
				system_msg_to_role(pstRole, szTaskInfo);
				return 0;
			}
			if(pstCycleTask->chTaskType == TASK_TYPE_CYCLE)
			{
				if(iParam1 >= 0 && iParam1 <= CS_TASK_MAX_NUMBER_A_CYCLE)
				{
					pstCycleTask->chCurrentCycleNumber = iParam1;
				}
			}
			else if(pstCycleTask->chTaskType == TASK_TYPE_PRACTICE)
			{
				if(iParam1 >= 0 && iParam1 <= CS_TASK_MAX_NUMBER_A_PRACTICE)
				{
					pstCycleTask->chCurrentCycleNumber = iParam1;
				}
			}
			else if(pstCycleTask->chTaskType == TASK_TYPE_POLICE_DAILY)
			{
				if(iParam1 >= 0 && iParam1 <= CS_TASK_MAX_CYCLE_NUMBER_POLICE_DAILY)
				{
					pstCycleTask->chCurrentCycleNumber = iParam1;
				}
			}
			else
			{
				sprintf(szTaskInfo+strlen(szTaskInfo),  "非循环或试炼任务[%d]，没有环数可设.\n",iParam0);
				system_msg_to_role(pstRole, szTaskInfo);
				return 0;
			}
			
			sprintf(szTaskInfo+strlen(szTaskInfo),  "任务[%d] 的当前环数为[%d].\n",iParam0,pstCycleTask->chCurrentCycleNumber);
			system_msg_to_role(pstRole, szTaskInfo);
			break;
		}
		case TMP_TASK_LIST_FINISH:
		{
			int i = 0;
			szTaskInfo[0]='\0';
			LPTASKPERMANENCE pstTaskFinshed = &pstDestRole->stTaskData.stTaskManagement.stTaskPermanence;
			sprintf(szTaskInfo+strlen(szTaskInfo),  "Finshed Task, UseByte[%d]\n",pstTaskFinshed->stCommonTaskList.wUsedByteNum);
			for(i = 1; i < CS_MAX_TASK_ID; ++i)
			{
				if(CHECK_TASK_FINISH_FLAG(pstTaskFinshed, i) == 1)
				{
					sprintf(szTaskInfo+strlen(szTaskInfo),  "%d-",i);
				}
				if((int)((i + 7)/8) > pstTaskFinshed->stCommonTaskList.wUsedByteNum)
					break;
			}
			system_msg_to_role(pstRole, szTaskInfo);
			break;
		}
		default:
			return -1;
	}
	return 0;
}

int gm_login(LPROLE pstRole,const char *pszArg)
{
	char szInfo[1024];
	szInfo[0]='\0';
	char szCmd[32];
	char szParamID[32];
	int iParam1 = 1000;
	gm_get_val(&pszArg,szCmd,sizeof(szCmd));
	if( !szCmd[0] )
	{
		return -1;
	}
	gm_get_val(&pszArg,szParamID,sizeof(szParamID));
	
	if( szParamID[0] )
	{
		iParam1 = atoi(szParamID);
	}

	if(!strncasecmp(szCmd, "show", sizeof("show")))
	{
		int iTestNum = 0;
		char chTestFlag = test_login_queue_num(&iTestNum);
		
		snprintf(szInfo,1024,"==========Zone Login Queue =========");
		system_msg_to_role(pstRole, szInfo);	
		snprintf(szInfo,1024,"Alloc[%d] Check[%s] TestNum[%d]",(int)get_cur_loginqueue_lenth(),chTestFlag == 0 ? "OK" : "Fail",iTestNum);
		system_msg_to_role(pstRole, szInfo);	
		snprintf(szInfo,1024,"================ End ================" );
		system_msg_to_role(pstRole, szInfo);	
	}
	else if(!strncasecmp(szCmd, "setmax", sizeof("setmax")))
	{
		set_max_loginqueue_lenth(iParam1);
		snprintf(szInfo,1024,"Set Zone Max Login Queue Lenth to [%d]",get_max_loginqueue_lenth());
		system_msg_to_role(pstRole, szInfo);	
	}
	else if(!strncasecmp(szCmd, "info", sizeof("info")))
	{
		int i =0;
		int iNum = 0;
		LPWHITELIST pstList = get_whitelist();
		if(NULL == pstList)
		{
			return -1;
		}
		
		snprintf(szInfo,1024,"==========Login And Jump ZoneID[%d]=========",(int)get_sys_zoneid());
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"RolePool大小[%d] 系统最大允许登陆人数 [%d] ShuntFence[%d]",MAX_ROLE,get_sys_rolelimit(),get_shunt_fence_num());
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"系统预留人数 [%d]",MAX_ROLE_REVERSE_NUM);
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"其他服可登入的最大人数 [%d]",get_zone_max_allow());
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"-----------当前在线人数[%d]---------------",get_rolepoll_num());
		system_msg_to_role(pstRole, szInfo);

		szInfo[0] = 0;
		iNum = 0;
		for(i= 0; i < CS_MAX_ZONE_NUMBER; ++i)
		{
			if(i == get_sys_zoneid())
			{
				continue;
			}

			snprintf(szInfo + strlen(szInfo),1024 - strlen(szInfo),"-[%d] %d-",i,pstList->awOtherZoneLogin[i]);
			
			iNum += pstList->awOtherZoneLogin[i];
		}
		snprintf(szInfo + strlen(szInfo),1024 - strlen(szInfo),"-[Self] %d-",get_rolepoll_num() - iNum);
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"-------- 加入本服白名单人数[%d]------",pstList->iCount);
		system_msg_to_role(pstRole, szInfo);
		szInfo[0] = 0;
		for(i= 0; i < CS_MAX_ZONE_NUMBER; ++i)
		{
			if(i == get_sys_zoneid())
			{
				continue;
			}

			snprintf(szInfo + strlen(szInfo),1024 - strlen(szInfo),"-[%d] %d-",i,pstList->awOtherZoneInWhite[i]);
		}
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"-------- 本服在其他线人数[%d]------",get_outside_role_num(-1));
		system_msg_to_role(pstRole, szInfo);
		szInfo[0] = 0;
		for(i= 0; i < CS_MAX_ZONE_NUMBER; ++i)
		{
			if(i == get_sys_zoneid())
			{
				continue;
			}

			snprintf(szInfo + strlen(szInfo),1024 - strlen(szInfo),"-[%d] %d-",i,get_outside_role_num(i));
		}
		system_msg_to_role(pstRole, szInfo);
		system_msg_to_role(pstRole, "===========================================");	
	}
	else
	{
		system_msg_to_role(pstRole, "//login show");
		system_msg_to_role(pstRole, "//login info");
		system_msg_to_role(pstRole, "//login setmax <Num>");
	}

	return 0;

}

int gm_whitelist(LPROLE pstRole,const char *pszArg)
{
	char szInfo[1024];
	szInfo[0]='\0';
	char szCmd[32];
	gm_get_val(&pszArg,szCmd,sizeof(szCmd));
	if( !szCmd[0] )
	{
		return -1;
	}
	
	char szZoneID[32];
	gm_get_val(&pszArg,szZoneID,sizeof(szZoneID));
	int iZoneID = 100;
	if( szZoneID[0] )
	{
		iZoneID = atoi(szZoneID);
	}

	
	
	if(!strncasecmp(szCmd, "add", sizeof("add")))
	{
		if(iZoneID < 0 || iZoneID > CS_MAX_ZONE_NUMBER)
		{
			return -1;
		}
		char szUin[32];
		gm_get_val(&pszArg,szUin,sizeof(szUin));
		unsigned int ulUin = 0;
		if(szUin[0])
		{
			ulUin = atoll(szUin);
		}

		// ulUin != 0 则可以加别的UIN到其他ZONE白名单
		return add_zone_whitelist(pstRole,iZoneID,ulUin);
	}
	else if(!strncasecmp(szCmd, "del", sizeof("del")))
	{
		if(iZoneID < 1 || iZoneID > CS_MAX_ZONE_NUMBER)
		{
			return -1;
		}
		
		char szUin[32];
		gm_get_val(&pszArg,szUin,sizeof(szUin));
		unsigned int ulUin = 0;
		if(szUin[0])
		{
			ulUin = atoll(szUin);
		}

		// ulUin != 0 则可以加别的UIN到其他ZONE白名单
		return del_zone_whitelist(pstRole,iZoneID,ulUin);
	}
	else if(!strncasecmp(szCmd, "list", sizeof("list")))
	{
		LPWHITELIST pstList = get_whitelist();
		if(NULL == pstList)
		{
			return -1;
		}
		snprintf(szInfo,1024,"==========Zone White List =========");
		system_msg_to_role(pstRole, szInfo);	
		snprintf(szInfo,1024,"----ZoneID[%d] WhitelistNum[%d]---",(int)get_sys_zoneid(),pstList->iCount);
		system_msg_to_role(pstRole, szInfo);	
		int i = 0;
		for(; i < CS_MAX_ZONE_NUMBER; ++i)
		{
			if(i == get_sys_zoneid())
			{
				snprintf(szInfo,1024,
					"%d) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",	i);
			}
			else
			{
				snprintf(szInfo,1024,
					"%d) Zone[%d] White[%d] Login [%d] Seat[%d] Enter[%d]",
					i,i,pstList->awOtherZoneInWhite[i],pstList->awOtherZoneLogin[i],pstList->awOtherZoneLastSeat[i],pstList->awOtherZoneLastEnter[i]);
			}
			
			system_msg_to_role(pstRole, szInfo);	
		}
		snprintf(szInfo,1024,"=====================End================" );
		system_msg_to_role(pstRole, szInfo);	
	}
	else if(!strncasecmp(szCmd, "setmax", sizeof("setmax")))
	{
	
		set_zone_max_allow(iZoneID);
		
		snprintf(szInfo,1024,"Set Zone Max Allow to [%d]",get_zone_max_allow());
		system_msg_to_role(pstRole, szInfo);	
	}
	else if(!strncasecmp(szCmd, "queue", sizeof("queue")))
	{
		LPQUEUEMANAGE pstQueue = NULL;
		snprintf(szInfo,1024,"==========Zone Queue Manage =========");
		system_msg_to_role(pstRole, szInfo);
		snprintf(szInfo,1024,"----ZoneID[%d] ---",(int)get_sys_zoneid());
		system_msg_to_role(pstRole, szInfo);	
		int i = 0;
		for(; i < CS_MAX_ZONE_NUMBER; ++i)
		{
			pstQueue = get_queue_manage(i);
			if(pstQueue == NULL)
			{
				return system_msg_to_role(pstRole, "Invalid ZoneID");
			}

			if(i == get_sys_zoneid())
			{
				snprintf(szInfo,1024,
					"%d) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",	i);
			}
			else
			{
			
				snprintf(szInfo,1024,
					"%d) Head[%d] Tail[%d] Seat[%d] Notify[%d] Wait[%d] Enter[%d]",
					i,pstQueue->nHeadPos,pstQueue->nTailPos,pstQueue->wSeatNum,pstQueue->wNotifyNum,pstQueue->wWaitNum,pstQueue->wEnterNum);
			}
			system_msg_to_role(pstRole, szInfo);	
		}
		snprintf(szInfo,1024,"=====================End================" );
		system_msg_to_role(pstRole, szInfo);	
	}
	else if(!strncasecmp(szCmd, "checkqueue", sizeof("checkqueue")))
	{
		LPQUEUEMANAGE pstQueue = get_queue_manage(iZoneID);
		if(pstQueue == NULL)
		{
			return system_msg_to_role(pstRole, "Invalid ZoneID");
		}

		LPWHITELIST pstList = get_whitelist();
		if(NULL == pstList)
		{
			return -1;
		}

		int iInstNum = get_zone_queue_member_num(iZoneID);
		int iRecordNum = get_wait_queue_lenth(iZoneID);
		int iAllocNum = pstList->stZoneQueue.stWait.iAlloc;
		
		snprintf(szInfo + strlen(szInfo),1024 - strlen(szInfo),"Zone[%d] RecordNum[%d] InstNum[%d] AllocNum[%d]",iZoneID,iRecordNum,iInstNum,iAllocNum);
		system_msg_to_role(pstRole, szInfo);	
	}
	else
	{
		system_msg_to_role(pstRole, "//whitelist add zoneid uin");
		system_msg_to_role(pstRole, "whitelist list zoneid");
	}

	return 0;

}

int gm_addrepu(LPROLE pstRole, const char *pszArg)
{
	char szRepuID[32];
	gm_get_val(&pszArg,szRepuID,sizeof(szRepuID));
	if(!szRepuID[0])
	{
		return -1;
	}
	int iRepuID = atoi(szRepuID);
	
	char szRepuValue[32];
	gm_get_val(&pszArg,szRepuValue,sizeof(szRepuValue));
	int iAddRepuValue = 0;
	if(szRepuValue[0])
	{
		iAddRepuValue = atoi(szRepuValue);
	}

	add_role_reputation(pstRole,iRepuID,iAddRepuValue);
	
	return 0;
}


//通过GM命令让角色跳入到一个平行世界中
int gm_pworld(LPROLE pstRole, const char *pszArg)
{
	char szID[32];
	char szMapID[32];
	gm_get_val(&pszArg,szID,sizeof(szID));
	gm_get_val(&pszArg,szMapID,sizeof(szMapID));
	if(!szID[0])
	{
		//需要提供PWORLDID
		system_msg_to_role(pstRole,"Usage://pworld <pworldid> [<mapid> <posx> <posy>]");
		return -1;
	}
	else
	{
		if(strncmp(szID,"debug",sizeof(szID))== 0)
		{
			//可以切换
			//todo: 真正发布需要删掉
			gm_set_debug_status();
			return 0;
		}
		int iID = atoi(szID);
		if(!szMapID[0])
		{
			//没有提供地图ID
			if(iID != 0)
			{
				if(0 == is_role_at_pworld(pstRole))
				{

					if(iID == 999)
					{
						short wPworldID = iID;	
        					LPPWORLDINDEX pstPworldIndex = find_pworld_index(wPworldID,NULL);
        					if(NULL == pstPworldIndex)
        					{
							// 查找平行世界配置信息失败
							return -1;
						}

					 	role_enter_pworld_by_pworldid(pstRole,wPworldID,pstPworldIndex->stSetting.chPworldType,get_role_level(pstRole)/16,0,0,0);
						return 0;
					}

					role_change_pworldmap(pstRole,iID,0,NULL,-1,-1);

				}
				else
				{

					system_msg_to_role(pstRole,"you are already at pworld now. cann't enter pworld again..");
				}

			}
			else
			{
				role_exit_pworld(pstRole,0,0,0,0,__FUNCTION__);
			}
		}
		else
		{
			int iMapID = atoi(szMapID);
			// 在平行世界内部地图跳转
			POSITION stPos;
			char szTmpPos[32];
			gm_get_val(&pszArg,szTmpPos,sizeof(szTmpPos));
			if(!szTmpPos[0])
				stPos.x = 400;
			else
				stPos.x = atoi(szTmpPos);
			gm_get_val(&pszArg,szTmpPos,sizeof(szTmpPos));
			if(!szTmpPos[0])
				stPos.y = 1000;
			else
				stPos.y = atoi(szTmpPos);
			role_change_pworldmap(pstRole,iID,iMapID,&stPos,-1,-1);
		//	role_enter_new_pworldmap(pstRole,iMapID,&stPos,-1,-1);
		}
		
	}

	return 0;
}


int gm_transtime(LPROLE pstRole, const char *pszArg)
{
	char szInfo[1024];
	char szTime[32];
	time_t iTime = 0;
	memset(szInfo, 0, sizeof(szInfo));
	if(NULL == pszArg)
	{
		return -1;
	}
	/*确定要打印仇恨的对象*/
	gm_get_val(&pszArg,szTime,sizeof(szTime));
	if(szTime[0])
	{
		iTime = atoi(szTime);
	}
	else
	{
		time(&iTime);
	}
	snprintf(szInfo,1024,"系统时间转换:\ntime_t [%d]\nGMT :%s",(int)iTime,ctime(&iTime));
	system_msg_to_role(pstRole, szInfo);
	return 0;

}
int gm_taunt(LPROLE pstRole, const char *pszArg)
{
	char szTauntInfo[4096];
	char szID[32];
	int i, j;
	unsigned int ulID;
	LPTAUNTREF pstTauntRef;
	LPROLE pstTRole, pstTTRole;
	LPMONSTER pstTMonster;
	LPPET pstTPet,pstTTPet;

	memset(szTauntInfo, 0, sizeof(szTauntInfo));
	memset(szID, 0, sizeof(szID));

	if(NULL == pszArg)
	{
		return -1;
	}
	/*确定要打印仇恨的对象*/
	gm_get_val(&pszArg,szID,sizeof(szID));
	if(!szID[0])
	{
		sprintf(szTauntInfo, "必须指定一个打印仇恨的对象\n打印角色自己//taunt 1\n打印其他目标,请用鼠标选定后，//taunt");
		system_msg_to_role(pstRole, szTauntInfo);
		return -1;
	}
	ulID = atoll(szID);

	/*打印角色自身的仇恨列表*/
	if(ulID == 1)
	{
		sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s]的被仇恨列表: Total = %d\n",pstRole->szName,pstRole->iTotalTauntRef);
		for (i = 0; i < pstRole->iTotalTauntRef; i++)
		{
			pstTauntRef = pstRole->astTauntRef+i;
			sprintf(szTauntInfo+strlen(szTauntInfo), "%d) ",i + 1);
			switch (zid_to_type(pstTauntRef->ulID))
			{
				case OBJ_ROLE:
					pstTTRole = zid_to_role(pstTauntRef->ulID);
					if (NULL == pstTTRole) break;
					sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s] ",pstTTRole->szName);
					break;
				case OBJ_PET:
					pstTTPet = zid_to_pet(pstTauntRef->ulID);
					if (NULL == pstTTPet) break;
					pstTTRole = get_role_by_pet(pstTTPet);
					if (NULL == pstTTRole) break;
					sprintf(szTauntInfo+strlen(szTauntInfo), "宠物[%s] ",pstTTRole->szName);
					break;
				default:
					sprintf(szTauntInfo+strlen(szTauntInfo), "怪物[%u] ",pstTauntRef->ulID);
					break;
			}
			sprintf(szTauntInfo+strlen(szTauntInfo), " UpdataTime = %s",ctime(&pstTauntRef->tUpdate));
		}
	}
	else
	{
		switch (zid_to_type(ulID))
		{
			case OBJ_ROLE:
				pstTRole = zid_to_role(ulID);
				if (NULL == pstTRole) break;
				sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s]的被仇恨列表: Total = %d\n",pstTRole->szName,pstTRole->iTotalTauntRef);
				if(pstTRole->iTotalTauntRef > ROLE_MAX_TAUNTREF)
				{
					break;
				}
				for (j = 0; j < pstTRole->iTotalTauntRef; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "%d) ",j + 1);
					switch (zid_to_type(pstTRole->astTauntRef[j].ulID))
					{
						case OBJ_ROLE:
							pstTTRole = zid_to_role(pstTRole->astTauntRef[j].ulID);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s] ",pstTTRole->szName);
							break;
						case OBJ_PET:
							pstTTPet = zid_to_pet(pstTRole->astTauntRef[j].ulID);
							if (NULL == pstTTPet) break;
							pstTTRole = get_role_by_pet(pstTTPet);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "宠物[%s] ",pstTTRole->szName);
							break;
						default:
							sprintf(szTauntInfo+strlen(szTauntInfo), "怪物[%u] ",pstTRole->astTauntRef[j].ulID);
							break;
					}
					sprintf(szTauntInfo+strlen(szTauntInfo), " UpdataTime = %s",ctime(&pstTRole->astTauntRef[j].tUpdate));
					
				}
				break;
			case OBJ_MONSTER:
				pstTMonster = zid_to_monster(ulID);
				if (NULL == pstTMonster) break;
				sprintf(szTauntInfo+strlen(szTauntInfo), "怪物[%u]的仇恨列表: Total = %d\n",pstTMonster->stObject.ulID,pstTMonster->iTotalTaunt);
				for (j = 0; j < pstTMonster->iTotalTaunt; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "%d) ",j + 1);
					switch (zid_to_type(pstTMonster->astTaunt[j].ulID))
					{
						case OBJ_ROLE:
							pstTTRole = zid_to_role(pstTMonster->astTaunt[j].ulID);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s] ",pstTTRole->szName);
							break;
						case OBJ_PET:
							pstTTPet = zid_to_pet(pstTMonster->astTaunt[j].ulID);
							if (NULL == pstTTPet) break;
							pstTTRole = get_role_by_pet(pstTTPet);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "宠物[%s] ",pstTTRole->szName);
							break;
						default:
							sprintf(szTauntInfo+strlen(szTauntInfo), "怪物[%u]",pstTMonster->astTaunt[j].ulID);
							break;
					}
					sprintf(szTauntInfo+strlen(szTauntInfo), " Value = %d Damage = %d\n  UpdataTime = %s",pstTMonster->astTaunt[j].iValue,pstTMonster->astTaunt[j].iDamage,ctime(&pstTMonster->astTaunt[j].tUpdate));
				}
				sprintf(szTauntInfo+strlen(szTauntInfo), "\n自杀时间 Time = %s", ctime(&pstTMonster->tSuicidalTime));
				break;
			case OBJ_PET:
				pstTPet = zid_to_pet(ulID);
				if (NULL == pstTPet) break;
				pstTTRole = get_role_by_pet(pstTPet);
				if (NULL == pstTTRole) break;
				sprintf(szTauntInfo+strlen(szTauntInfo), "宠物[%s]的被仇恨列表: Total = %d\n",pstTTRole->szName,pstTPet->iTotalTauntRef);
				if(pstTPet->iTotalTauntRef > PET_MAX_TAUNTREF)
				{
					break;
				}
				for (j = 0; j < pstTPet->iTotalTauntRef; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "%d) ",j + 1);
					switch (zid_to_type(pstTPet->astTauntRef[j].ulID))
					{
						case OBJ_ROLE:
							pstTTRole = zid_to_role(pstTPet->astTauntRef[j].ulID);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "角色[%s] ",pstTTRole->szName);
							break;
						case OBJ_PET:
							pstTTPet = zid_to_pet(pstTPet->astTauntRef[j].ulID);
							if (NULL == pstTTPet) break;
							pstTTRole = get_role_by_pet(pstTTPet);
							if (NULL == pstTTRole) break;
							sprintf(szTauntInfo+strlen(szTauntInfo), "宠物[%s] ",pstTTRole->szName);
							break;
						default:
							sprintf(szTauntInfo+strlen(szTauntInfo), "怪物[%u] ",pstTPet->astTauntRef[j].ulID);
							break;
					}
					sprintf(szTauntInfo+strlen(szTauntInfo), " UpdataTime = %s", ctime(&pstTPet->astTauntRef[j].tUpdate));
				}
				break;
			default:
				sprintf(szTauntInfo+strlen(szTauntInfo), "指定目标未找到\n");
				break;
		}
	}
#if 0
	for (i = 0; i < pstRole->iTotalTauntRef; i++)
	{
		pstTauntRef = pstRole->astTauntRef+i;
		sprintf(szTauntInfo+strlen(szTauntInfo), "%d) %u@%u : ", i+1, pstTauntRef->ulID, pstTauntRef->tUpdate);
		switch (zid_to_type(pstTauntRef->ulID))
		{
			case OBJ_ROLE:
				pstTRole = zid_to_role(pstTauntRef->ulID);
				if (NULL == pstTRole) break;
				for (j = 0; j < pstTRole->iTotalTauntRef; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "[%u, -]@%u ",
							pstTRole->astTauntRef[j].ulID, pstTRole->astTauntRef[j].tUpdate);
				}
				break;
			case OBJ_MONSTER:
				pstTMonster = zid_to_monster(pstTauntRef->ulID);
				if (NULL == pstTMonster) break;
				for (j = 0; j < pstTMonster->iTotalTaunt; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "[%u, %d]@%u ",
							pstTMonster->astTaunt[j].ulID, pstTMonster->astTaunt[j].iValue, pstTMonster->astTaunt[j].tUpdate);
				}
				break;
			case OBJ_PET:
				pstTPet = zid_to_pet(pstTauntRef->ulID);
				if (NULL == pstTPet) break;
				for (j = 0; j < pstTPet->iTotalTauntRef; j++)
				{
					sprintf(szTauntInfo+strlen(szTauntInfo), "[%u, -]@%u ",
							pstTPet->astTauntRef[j].ulID, pstTPet->astTauntRef[j].tUpdate);
				}
				break;
			default:
				break;
		}
		sprintf(szTauntInfo+strlen(szTauntInfo), "\n");
	}
#endif
	time_t ttmnow;
 	time(&ttmnow);
	sprintf(szTauntInfo+strlen(szTauntInfo), "\n当前系统时间 Time = %s", ctime(&ttmnow));
	system_msg_to_role(pstRole, szTauntInfo);

	return 0;
}
/** comment:ac
int gm_ac(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	char szHelp[4096];
	sprintf(szHelp,  "//ac agent -- 直接触发离线自动战斗\n"
				"//ac num -- 当前离线战斗的人数\n"
	 		       "//ac online -- 返回在线状态\n"
	 		      //  "//ac sitdown -- 测试一下坐下\n"
	 		      //  "//ac move x y -- 测试一下移动到目标\n"
	 		       "//ac setting -- 默认设置全部选项(战士)\n"
	 		        "//ac setting print -- 打印自动战斗设置\n"
	 		       "//ac setting pick $Flag $color -- 自动拾取设置$flag[0,1] $color[1~4]\n"
	 		       "//ac setting hp $Flag $percent $resid -- 生命药\n"
 		               "//ac setting mp $Flag $percent $resid -- 法力药\n"
 		               "//ac setting repair $Flag $resid -- 修理装备 \n"
 		               "//ac setting ac $Flag $distance $skill1 $skill2 $skill3 $skill4 $skill5 -- 自动战斗\n"
 		    //           "//ac setting buff $Flag -- buff技能战斗\n"
 		               "//ac setting offlineac $Flag $time-- 是否离线战斗\n"
 		               "//ac setting autopay $Flag -- 是否自动充值"
 		               "//ac offtime $uin $addtime -- 给角色添加离线时间$uin=0表示自己"
	 		      );	
	
	char szTemp[80];
	LPCSAUTOCOMBATSETTING pstACSetting = &pstRole->stAutoCombat.stSave.stSetting;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}	
	if(!strncasecmp(szTemp, "move", sizeof("move")))
	{
		POSITION stPos;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		stPos.x = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		stPos.y = atoi(szTemp);

		//role_agent_move其实只能在离线战斗的时候调用，这儿测试，为了能瞬移，需要设置一下offlinepos和nAutoRange
		memcpy(&pstRole->stAutoCombat.stSave.stSetting.stCenterPoint, &stPos, sizeof(POSITION));
		pstRole->stAutoCombat.stSave.stSetting.nAutoRange = 200;
		return ac_agent_move(pstRole, &stPos);
	}	
#ifndef _OPEN_VISION_
	else if(!strncasecmp(szTemp, "vision", sizeof("vision")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iNewValue = atoi(szTemp);
		if(iNewValue < 0) 
		{
			system_msg_to_role(pstRole, "min=0");
		}
		set_send_vision_num(iNewValue);
		sprintf(szHelp, "CurValue=%d", get_send_vision_num());
		system_msg_to_role(pstRole, szHelp);
		return 0;
	}
#endif
else if(!strncasecmp(szTemp, "testvision", sizeof("testvision"))) 
	{
		int iVisionNum; //视野基数
		int iOprNum; //随机插入删除的次数
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		iVisionNum = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		iOprNum = atoi(szTemp); 
		unsigned int zid = 0;
		
		struct timeval stBefore1;
		struct timeval stBefore2;

		//老视野
		int iVCare = 0;
		unsigned int aulVCare[MAX_CARE];
		VISION stVision; //新视野
		init_object_vision_value(&stVision);
		int i = 0;
		
		gettimeofday(&stBefore1, NULL); 
		for(i = 0; i < iVisionNum;i++)
		{
			zid = RAND()%1000000;
			 my_binsert(&zid, aulVCare, &iVCare, (int)sizeof(unsigned int), 1, cmp_zid);
		}
		for(i = 0; i < iOprNum; i++)
		{
			zid = RAND()%1000000;
			 my_binsert(&zid, aulVCare, &iVCare, (int)sizeof(unsigned int), 1, cmp_zid);
			 my_bdelete(&zid, aulVCare, &iVCare, (int)sizeof(unsigned int), cmp_zid);
		}
		gettimeofday(&stBefore2, NULL);
		sprintf(szHelp, "Old:visionnum=%d:%d, Oprnum=%d, time_us=%lld.", iVisionNum, iVCare, iOprNum, us_pass(&stBefore1, &stBefore2));
		system_msg_to_role(pstRole, szHelp);	
		log_info_m(LOG_MODULE_VISION, LOG_DEBUG, "%s", szHelp);

		gettimeofday(&stBefore1, NULL); 
		for(i = 0; i < iVisionNum;i++)
		{
			zid = RAND()%1000000;
			add_object_to_vision(zid, &stVision);
		}
		for(i = 0; i < iOprNum; i++)
		{
			zid = RAND()%1000000;
			add_object_to_vision(zid, &stVision);
			delete_object_from_vision(zid, &stVision);
		}
		gettimeofday(&stBefore2, NULL);
		sprintf(szHelp, "New:visionnum=%d:%d, Oprnum=%d, time_us=%lld.", iVisionNum, iVCare, iOprNum, us_pass(&stBefore1, &stBefore2));
		system_msg_to_role(pstRole, szHelp);		
		log_info_m(LOG_MODULE_VISION, LOG_DEBUG, "%s", szHelp);
		return 0;
	}	
	else if(!strncasecmp(szTemp, "num", sizeof("num")))
	{
		sprintf(szHelp, "Agent Role num=%d.", get_ac_role_num());
		system_msg_to_role(pstRole, szHelp);
		return 0;
	}
#ifdef _NEW_MULT_SRV_PKG_
	else if(!strncasecmp(szTemp, "newmsg", sizeof("newmsg")))
	{
		char chGmValue = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		chGmValue = atoi(szTemp);
		if(0 == chGmValue)
		{
			set_new_msg_stat_data(szHelp);
			system_msg_to_role(pstRole, szHelp);
		}
		else if(1 == chGmValue)
		{
			set_new_msg_stat_data(NULL); //空参数，表示清掉内部数据
		}
		return 0;
	}
#endif
	else if(!strncasecmp(szTemp, "speed", sizeof("speed")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iAddMoveSpeed = atoi(szTemp);
		ATTRREVLIST stRevList;
		stRevList.nTotal = 0;
		stRevList.astRev[stRevList.nTotal].chRevType = ATTR_REVTYPE_ADD;
		stRevList.astRev[stRevList.nTotal].nAttr = CS_ATTR_MOVESPEED;
		stRevList.astRev[stRevList.nTotal].iRevValue = iAddMoveSpeed;  	
		stRevList.nTotal++;
		set_role_movespeed(pstRole, &stRevList, 0);
		reply_server_pkg(pstRole->ulUin, CS_CMD_ROLE_REV_ATTR, &stRevList); 
		return 0;		
	}
	else if(!strncasecmp(szTemp, "offtime", sizeof("offtime")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		LPROLE pstCurRole = NULL;
		unsigned int ulUin = atoi(szTemp);
		if(0 == ulUin)
		{
			pstCurRole = pstRole;
		}
		else
		{
			pstCurRole = uin_to_role(ulUin);
			if(NULL == pstCurRole)
			{
				system_msg_to_role(pstRole, "Uin is not online.");
				return -1;
			}
		}
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iOffTime = atoi(szTemp);

		pstCurRole->stAutoCombat.stSave.stSetting.iOffAgentTime += iOffTime;
		log_info_m(LOG_MODULE_COMBAT, LOG_DEBUG, "%s: gm role(%u) add offtime =%d ok.", 
											__FUNCTION__, ulUin, iOffTime);
		CSMISCS stMiscS;
		stMiscS.chReq = CS_MISC_REQ_AUTO_COMBAT_SETTING;
		stMiscS.nEno = CS_CODE_NOERR;
		memcpy(&stMiscS.stData.stAutoCombatSetting , &pstRole->stAutoCombat.stSave.stSetting, sizeof(CSAUTOCOMBATSETTING));
		reply_server_pkg(pstRole->ulUin, CS_CMD_MISC, &stMiscS);
	
		return 0;		
	}
	else if(!strncasecmp(szTemp, "speed", sizeof("speed")))
	{
		sprintf(szHelp, "MoveSpeed=%d.", get_role_movespeed(pstRole));
		system_msg_to_role(pstRole, szHelp);
		return 0;		
	}
	else if(!strncasecmp(szTemp, "bench", sizeof("bench")))
	{
		struct timeval stCurr;	
		gettimeofday(&stCurr, NULL);
		CSBENCHTIME stBenchTime;
		stBenchTime.iBenchTimeSec = stCurr.tv_sec;
		stBenchTime.iBenchTimeUSec = stCurr.tv_usec;
		reply_server_pkg(pstRole->ulUin, CS_CMD_GET_BENCHTIME, &stBenchTime);
		sprintf(szHelp, "SysTime[%u,%06lu] bench[%d].", stCurr.tv_sec, stCurr.tv_usec, only_get_bench_time(&pstRole->stBench));
		//system_msg_to_role(pstRole, szHelp);
		log_info(LOG_DEBUG, "benchtest:%s", szHelp);
		return 0;
	}
	else if(!strncasecmp(szTemp, "sitdown", sizeof("sitdown")))
	{
		CSMISCC stMiscC;
		stMiscC.chReq = CS_MISC_REQ_SITDOWN;		
		return process_misc_behavior(pstRole, &stMiscC);	
	}
	else if(!strncasecmp(szTemp, "agent", sizeof("agent")))
	{
		//为了测试，gm在这设置的，实际上这个点应该是client自动战斗时的点
		pstACSetting->stCenterPoint.x = pstRole->stObject.stPos.x;
		pstACSetting->stCenterPoint.y = pstRole->stObject.stPos.y;
	
		int iRet = enter_ac_agent(pstRole);
		sprintf(szHelp, "enter_ac_agent return =%d", iRet);
		system_msg_to_role(pstRole, szHelp);
		return 0;
	}
	else if(!strncasecmp(szTemp, "online", sizeof("online")))
	{
		 pstRole->stAutoCombat.chStat = AUTO_COMBAT_STAT_ONLINE;
		 return 0;
	}
	else if(!strncasecmp(szTemp, "setting", sizeof("setting")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			LPITEM pstItem = NULL;
			pstACSetting->chSettingFlag = 255; //全1
			pstACSetting->skills[0] = 31100101;
			pstACSetting->skills[1] = 31100201;
			pstACSetting->skills[2] = 31100301;
			pstACSetting->skills[3] = 0;
			pstACSetting->skills[4] = 31101201;			
			int i = 0;
			for(i = 0; i <AUTO_COMBAT_MAX_SKILL;i++) //确保已经学习
			{
				if(0 >= pstACSetting->skills[i])
				{
					continue;
				}
				role_clone_skill(pstRole, pstACSetting->skills[i]);
			}			
			pstACSetting->iOffAgentTime = 3600; //一个小时

			//送几个物品，不判断失败，只是辅助措施
			pstItem = dropitem_byresid(pstACSetting->iHPResID,10, 0, 
					DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL); 
			put_item(pstRole, pstItem, NULL, NULL, 1, 1);
			pstItem = dropitem_byresid(pstACSetting->iMPResID,10, 0, 
					DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL); 
			put_item(pstRole, pstItem, NULL, NULL, 1, 1);
			pstItem = dropitem_byresid(pstACSetting->iRepairResID,10, 0, 
					DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL); 
			put_item(pstRole, pstItem, NULL, NULL, 1, 1);
			
			return 0;
		}
		else if(!strncasecmp(szTemp, "print", sizeof("print")))
		{
			sprintf(szHelp,  "Positon: %d %d\n"
				"Pick: %d %d\n"
				 "HP: %d %d %d\n"
				 "MP: %d %d %d\n"
				  "Repair: %d %d\n"
				  "AutoCombat: %d %d, skill=%d %d %d %d %d\n"
				//  "BuffSkill: %d \n"
				  "OffAgent: %d Time:%d \n"
				  "AutoPay: %d", 
				 pstACSetting->stCenterPoint.x,  pstACSetting->stCenterPoint.y,
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_PICK), pstACSetting->chLowPickColor,
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_HP),pstACSetting->chLowHPPercent,pstACSetting->iHPResID,
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_MP),pstACSetting->chLowMPPercent,pstACSetting->iMPResID,				
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_REPAIR), pstACSetting->iRepairResID,
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_ATTACK), pstACSetting->nAutoRange , 
						pstACSetting->skills[0], pstACSetting->skills[1],pstACSetting->skills[2],pstACSetting->skills[3],pstACSetting->skills[4],
				//get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_BUFF),
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_OFFAGENT), pstACSetting->iOffAgentTime,
				get_ac_setting_flag(pstACSetting->chSettingFlag, AUTO_COMBAT_SETTING_AUTOPAY));
			system_msg_to_role(pstRole, szHelp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "pick", sizeof("pick")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_PICK, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->chLowPickColor = atoi(szTemp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "hp", sizeof("hp")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_HP, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->chLowHPPercent = atoi(szTemp);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->iHPResID = atoi(szTemp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "mp", sizeof("mp")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_MP, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->chLowMPPercent = atoi(szTemp);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->iMPResID = atoi(szTemp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "repair", sizeof("repair")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_REPAIR, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->iRepairResID = atoi(szTemp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "ac", sizeof("ac")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_ATTACK, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			pstACSetting->nAutoRange = atoi(szTemp);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
			int i = 0;
			for(i = 0; i < AUTO_COMBAT_MAX_SKILL; i++)
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));			
				pstACSetting->skills[i] = atoi(szTemp);
			}
			return 0;
		}
		//else if(!strncasecmp(szTemp, "buff", sizeof("buff")))
		//{
		//	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		//	set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_BUFF, atoi(szTemp));
		//	return 0;
		//}
		else if(!strncasecmp(szTemp, "offlineac", sizeof("offlineac")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_OFFAGENT, atoi(szTemp));
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			pstACSetting->iOffAgentTime = atoi(szTemp);
			return 0;
		}
		else if(!strncasecmp(szTemp, "autopay", sizeof("autopay")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			set_ac_setting_flag(pstRole, AUTO_COMBAT_SETTING_AUTOPAY, atoi(szTemp));
			return 0;
		}
		return -1;
		
	}	
	else
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	return 0;
}
**/


int gm_ai(LPROLE pstRole, const char *pszArg)
{
	LPMONSTER pstMon = NULL;
	LPRESMONSTER pstMonDef = NULL;
	char szAiInfo[4096];
	szAiInfo[0] = 0;
	char szHelp[4096];
	sprintf(szHelp, " 若没有选中摸个怪物，下面的参数怪物ID是需要的，若选中可省略怪物ID输入\n "
				" //ai pause [怪物ID] ；怪物暂停Ai处理\n "
				" //ai monsterattr [怪物ID] ；怪物的常用属性\n "
				"//ai resume [怪物ID] ；怪物继续Ai处理\n "
				"//ai printskill [怪物ID] ；打印怪物技能列表和当前选择技能\n"
				"//ai skill 技能ID [怪物ID] ；怪物释放某个指定技能\n"
				"//ai distance  [怪物ID] ；打印怪物和角色的位置，以及之间的距离\n"
				"//ai stat  [怪物ID] ；打印怪物的ai状态\n"
				"//ai setpos X Y  [怪物ID] ；强制设置怪物的位置\n"
				"//ai camp  [怪物ID] ；打印一下目标的阵营值\n"
				"//ai smash  [怪物ID] ；直接秒杀任何选中目标，太可怕了。。\n");
	char szTemp[80];
	char chCmd = -1;
	int i;
	unsigned int ulID;
	int iSkillID = 0;
	POSITION stBeginPos={0};
	POSITION stEndPos  ={0};	
	POSITION stSetPos  ={0};

	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	if(!strncasecmp(szTemp, "pause", sizeof("pause")))
	{
		chCmd = 1;
	}else if(!strncasecmp(szTemp, "resume", sizeof("resume")))
	{
		chCmd = 0;
	}else if(!strncasecmp(szTemp, "printskill", sizeof("printskill")))
	{
		chCmd = 2;
	}
	else if(!strncasecmp(szTemp, "skill", sizeof("skill")))
	{
		chCmd = 3;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp)); 
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iSkillID = atoi(szTemp); //取技能ID
	}
	else if(!strncasecmp(szTemp, "distance", sizeof("distance")))
	{
		chCmd = 4;		
	}
	else if(!strncasecmp(szTemp, "movetest", sizeof("movetest")))   //怪物移动测试用
	{
		chCmd = 5;	
		gm_get_val(&pszArg,szTemp,sizeof(szTemp)); 		
		stBeginPos.x= atoi(szTemp); 
		gm_get_val(&pszArg,szTemp,sizeof(szTemp)); 		
		stBeginPos.y= atoi(szTemp); 
		gm_get_val(&pszArg,szTemp,sizeof(szTemp)); 		
		stEndPos.x= atoi(szTemp); 
		gm_get_val(&pszArg,szTemp,sizeof(szTemp)); 		
		stEndPos.y= atoi(szTemp); 
	}
	else if(!strncasecmp(szTemp, "stat", sizeof("stat")))
	{
		chCmd = 6;		
	}
	else if(!strncasecmp(szTemp, "setpos", sizeof("setpos")))
	{
		chCmd = 7;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		stSetPos.x = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		stSetPos.y = atoi(szTemp);
	}
	else if(!strncasecmp(szTemp, "attr", sizeof("attr")))
	{
		chCmd = 8;
	}
	else if(!strncasecmp(szTemp, "camp", sizeof("camp")))
	{
		chCmd = 9;		
	}
	else if(!strncasecmp(szTemp, "monsterattr", sizeof("monsterattr")))
	{
		chCmd = 10;		
	}
	else if(!strncasecmp(szTemp, "smash", sizeof("smash")))
	{
		chCmd = 11;
	}
	else
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] == 0)
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	ulID = atoll(szTemp);

	CSOBJECTATTRLISTC stObjAttr;
	stObjAttr.ulObjectID = ulID;
	stObjAttr.nTotal = 3;
	stObjAttr.astAttr[0].nAttr = CS_ATTR_CURHP;
	stObjAttr.astAttr[1].nAttr = CS_ATTR_CURMP;
	stObjAttr.astAttr[2].nAttr = CS_ATTR_CUREP;

	char chObjType = zid_to_type(ulID);
	switch (chObjType)
	{
		case OBJ_MONSTER:
			pstMon = zid_to_monster(ulID);
			if (NULL == pstMon) break;
			pstMonDef = find_monster_def(pstMon->iID,&pstMon->iDefPos);
			if(pstMonDef == NULL)
				break;
			if(chCmd == 2)
			{
				sprintf(szAiInfo, "该怪物[%d]配置的技能有:", pstMon->iID);
				for (i = 0; pstMonDef->astOptionSkill[i].iID != 0 && i < RES_MAX_OPTION_SKILL; ++i)
				{
					sprintf(szAiInfo+strlen(szAiInfo), "[%d] %d ",i + 1, pstMonDef->astOptionSkill[i].iID);
				}
				sprintf(szAiInfo+strlen(szAiInfo), "\n该怪物拥有的技能有:");
				for(i = 0;i < pstMon->iSkill; ++i)
				{
					sprintf(szAiInfo+strlen(szAiInfo), "[%d] %d ",i + 1,pstMon->astSkill[i].iID);
				}
				sprintf(szAiInfo+strlen(szAiInfo), "\n当前选定的技能为: %d\n",pstMon->iChosenSkill);
			}
			else if(chCmd == 3) //怪物释放技能
			{
				LPRESSKILL pstSkillDef = find_skill_def(iSkillID);
				if (NULL == pstSkillDef) 
				{
					sprintf(szAiInfo, "技能资源错误\n");
					break;
				}
				unsigned int ulTarget = 0;
				if(RES_SKILL_RANGE_TYPE_SINGLE == get_skill_range_type(pstSkillDef))
				{
					if(pstSkillDef->wTarget == 1)
					{
						ulTarget = pstMon->stObject.ulID;
					}
					else
					{
						ulTarget = get_role_zid(pstRole);
					}
				}
				int iRet = object_attack(&pstMon->stObject, iSkillID, ulTarget, 0);
				if (0 != iRet) 
				{
					sprintf(szAiInfo, "怪物发起攻击失败，iRet=%d\n", iRet);
					break;
				}
			}
			else if(chCmd == 0 || chCmd == 1)
			{
				pstMon->stAIInfo.chAiCtrlTag = chCmd;
				sprintf(szAiInfo, "该怪物的AI设置为  [%s]\n",chCmd == 1?"暂停":"启动");
			}
			else if(chCmd == 4)
			{		
				sprintf(szAiInfo, "distance:%d, Target(%u) pos[%d, %d], Role(%u) pos[%d,%d]\n",
					distance(&pstMon->stObject.stPos, &pstRole->stObject.stPos),
					pstMon->stObject.ulID, pstMon->stObject.stPos.x, pstMon->stObject.stPos.y,
					pstRole->stObject.ulID, pstRole->stObject.stPos.x, pstRole->stObject.stPos.y);
			}
			else if(chCmd == 5) //怪物移动测试用
			{
				pstMon->stAIInfo.chAiCtrlTag = 1; //先暂停掉怪物AI，使之不受新移动消息的影响
				
				CSOTHERMOVES stMove;	
				stMove.ulObjectID =	pstMon->stObject.ulID;
				stMove.chMoveType = CS_MOVE_WALK;
				stMove.nMoveSpeed = get_monster_movespeed(pstMon);
				stMove.x = stBeginPos.x;
				stMove.y = stBeginPos.y;
				stMove.stData.stWalk.chTotal = 1;
				stMove.stData.stWalk.astPoints[0].x = stEndPos.x;
				stMove.stData.stWalk.astPoints[0].y = stEndPos.y;
				reply_server_pkg(pstRole->ulUin, CS_CMD_OTHER_MOVE, &stMove); //就发给GM的执行者即可
				return 0;
			}
			else if(chCmd == 6)
			{		
				sprintf(szAiInfo, "Target(%u) ai stat [%d]\n",
					pstMon->stObject.ulID,pstMon->chBrainLogic);
			}
			else if (chCmd == 7)
			{
				force_set_monster_pos(pstMon, &stSetPos);
				return 0;
			}
			else if (chCmd == 8)
			{
				return cu_object_attr_cmd(pstRole, &stObjAttr);
			}
			else if (chCmd == 9)
			{
				sprintf(szAiInfo, "Target(%u) monster camp is [%d]\n", ulID, get_monster_campid(pstMon));
			}
			else if (chCmd == 10)
			{
				snprintf(szAiInfo , sizeof(szAiInfo), "查询怪物[%u][%d]的属性: \n"
				"1)最大生命[AttrID=%d]:%d \n"
				"2)最大法力[AttrID=%d]:%d\n"
				"3)当前生命:%d \n"  
				"4)当前法力:%d\n"
				"5)物理攻击[AttrID=%d-%d]:%d-%d\n"
				"6)物理防御[AttrID=%d]:%d\n"
				"7)法术攻击[AttrID=%d-%d]:%d-%d\n"
				"8)法术防御[AttrID=%d]:%d\n",		
				pstMon->stObject.ulID, pstMon->iID,
				CS_ATTR_MAXHP, attr_get_value(&pstMon->stAttr, CS_ATTR_MAXHP),
				CS_ATTR_MAXMP, attr_get_value(&pstMon->stAttr, CS_ATTR_MAXMP),
				get_monster_curhp(pstMon),get_monster_curmp(pstMon),
				CS_ATTR_MINPHYSATK, CS_ATTR_MAXPHYSATK,
				attr_get_value(&pstMon->stAttr, CS_ATTR_MINPHYSATK), attr_get_value(&pstMon->stAttr, CS_ATTR_MAXPHYSATK),
				CS_ATTR_PHYSDEF, attr_get_value(&pstMon->stAttr, CS_ATTR_PHYSDEF),
				CS_ATTR_MINMAGICATK, CS_ATTR_MAXMAGICATK,
				attr_get_value(&pstMon->stAttr, CS_ATTR_MINMAGICATK), attr_get_value(&pstMon->stAttr, CS_ATTR_MAXMAGICATK),
				CS_ATTR_MAGICDEF, attr_get_value(&pstMon->stAttr, CS_ATTR_MAGICDEF));
			}
			else if (chCmd == 11)
			{
				monster_die(pstMon, MONSTER_DIE_MODE_SYS_RECALL);
			}
			else
			{
				sprintf(szAiInfo, "错误的参数\n");
			}
			break;
		case OBJ_ROLE:
		case OBJ_PET:
		{
			LPOBJECT pstObj = zid_to_object(ulID, NULL);			
			if(NULL == pstObj)
			{
				return -1;
			}
			LPROLE pstTRole = NULL;
			LPPET pstTPet = NULL;
			if(chCmd == 4)
			{		
				sprintf(szAiInfo, "distance:%d, Target(%u) pos[%d, %d], Role(%u) pos[%d,%d]\n",
					distance(&pstObj->stPos, &pstRole->stObject.stPos),
					pstObj->ulID, pstObj->stPos.x, pstObj->stPos.y,
					pstRole->stObject.ulID, pstRole->stObject.stPos.x, pstRole->stObject.stPos.y);
			}
			else if (chCmd == 8)
			{
				return cu_object_attr_cmd(pstRole, &stObjAttr);
			}
			else if (chCmd == 9)
			{
				if(chObjType == OBJ_ROLE)
				{
					sprintf(szAiInfo, "Target(%u) role camp is [%d]\n", ulID, get_role_campid(zid_to_role(ulID)));
				}
				else if(chObjType == OBJ_PET)
				{
					sprintf(szAiInfo, "Target(%u) pet camp is [%d]\n", ulID, get_pet_campid(zid_to_pet(ulID)));
				}
			}
			else if (chCmd == 11)
			{
				if(chObjType == OBJ_ROLE)
				{
					pstTRole = OBJECT_TO_ROLE(pstObj);
					add_role_curhp(pstTRole, (-1)*get_role_maxhp(pstTRole));
					role_die(pstTRole);
				}
				else if(chObjType == OBJ_PET)
				{
					pstTPet = OBJECT_TO_PET(pstObj);
					add_pet_curhp(pstTPet, (-1)*get_pet_maxhp(pstTPet));
					pet_die(pstTPet);
				}
			}
			break;
		}
		default:
			sprintf(szAiInfo, "目标必须是怪物\n");
			break;
	}

	if(0 != strlen(szAiInfo))
	{
		system_msg_to_role(pstRole, szAiInfo);
	}
	return 0;
}
/**
int gm_mascot(LPROLE pstRole,const char*pszArg)  //add by lcs for mascot
{
	char szHelp[4096];
	sprintf(szHelp, "//mascot addpoint $value -- 增减请神符点 \n"
		"//mascot setmas1 $mascotid -- 将待选福神列表中第一个神设置成对应的福神，以便请神 \n"
		"//mascot setcha1 $challengeid -- 将待选挑战列表中第一个挑战设置成对应的挑战，以便选择挑战 \n"
		"//mascot clearmascotused -- 清掉本次挑战中使用的神列表，以便用神比如重置等达到最终挑战的目的\n");

	char szTemp[128];
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(!strncasecmp(szTemp, "addpoint", sizeof("addpoint")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		int iPoint = atoi(szTemp);
		return chg_mascot_ask_point(pstRole, iPoint);
	}
	else if(!strncasecmp(szTemp, "setmas1", sizeof("setmas1")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		int iMascotID = atoi(szTemp);
		LPROLEMASCOTSAVEDATA pstMascotSave = &pstRole->stMascotData.stSave;
		pstMascotSave->masCotToAskList[0] = iMascotID;
		CSMASCOTC stMascotC;
		stMascotC.chOpCmd = CS_MASCOT_QUERY_TO_ASK;
		return mascot_query_to_ask(pstRole, &stMascotC);
	}
	else if(!strncasecmp(szTemp, "setcha1", sizeof("setcha1")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		int iChalID = atoi(szTemp);
		LPROLEMASCOTSAVEDATA pstMascotSave = &pstRole->stMascotData.stSave;
		pstMascotSave->toChallengeList[0] = iChalID;
		CSMASCOTC stMascotC;
		stMascotC.chOpCmd = CS_MASCOT_QUERY_TO_CHALLENGE;
		return mascot_query_to_challenge(pstRole, &stMascotC, 0);
	}
	else if(!strncasecmp(szTemp, "clearmascotused", sizeof("clearmascotused")))
	{
		LPCHALLENGEMASCOTTRANSACTION pstTransAction = &pstRole->stMascotData.stTransaction;
		pstTransAction->chMasCotUsedNum = 0; 
		return send_mascot_challenge_transaction(pstRole);
	}
	else
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}	
	return 0;
}
*/

int gm_transfer(LPROLE pstRole,const char*pszArg) 
{
	char szTemp[128];
	CSTRANSFERC stTransferC;
	stTransferC.chOperation = CS_TRANSFER_EXECUTE;

	// transfer Transferid transferitemindex
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stTransferC.iTransferID = (unsigned int)atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stTransferC.iTransferItemIndex = atoi(szTemp);
	else return -1;

	set_log_module(LOG_MODULE_MOVE);
	int iRet = process_transfer_cmd(pstRole, &stTransferC);
	if(CS_ENO_NOERR != iRet)
	{
		return -1;
	}	
	log_info_m(LOG_MODULE_ROLE, LOG_DEBUG, "BEFORE resume_log_module"); //仅为借助测试
	resume_log_module();	
	log_info_m(LOG_MODULE_MOVE, LOG_DEBUG, "AFTER1 resume_log_module"); //仅为借助测试
	log_info_m(LOG_MODULE_TRADE, LOG_DEBUG, "AFTER2 resume_log_module"); //仅为借助测试
	
	return 0;

}

int gm_camp(LPROLE pstRole,const char*pszArg) 
{
	//camp optype CampID
	char szTemp[128];
	unsigned char bCampID = CAMP_ROLE_DEFAULT;
	char bOpType = 0;

	char sTmpStr[4096];

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) 
	{
		bOpType = atoi(szTemp);
	}
	else 
	{
		snprintf(sTmpStr,sizeof(sTmpStr),"Usage://camp 0 -- query role campid. //camp 1 <campid> --setcampid.//camp 2 <campid> --setteamcampid. //camp 3 <campid> --setmaprolecampid.");
		system_msg_to_role(pstRole,sTmpStr);
		return -1;
	}

	if(0 != bOpType)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) bCampID = atoi(szTemp);
		else return -1;
	}

	int iRet = 0;
	switch(bOpType)
	{
		case 0: //getcamp			
			sprintf(sTmpStr, "role(uin=%u) campid=%d",  get_role_uin(pstRole), get_role_campid(pstRole));
			log_info(LOG_DEBUG, sTmpStr);
			system_msg_to_role(pstRole, sTmpStr);
			break;
		case 1: // changecamp
			iRet = set_role_campid(pstRole, bCampID);
			break;
		case 2: // changeteamcamp
			iRet = set_role_team_campid(pstRole, bCampID);
			break;
		case 3: // changemapcamp
			iRet = set_role_map_campid(&pstRole->stObject.stMapInstIndex, bCampID);
			break;
		default:
			return -1;
	}	
	return iRet;
}


int gm_fly(LPROLE pstRole,const char*pszArg) 
{
	//fly id
	char szTemp[128];
	int iFlyID = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iFlyID = atoi(szTemp);
	else return -1;

	int iFailHandleMode = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iFailHandleMode = atoi(szTemp);
	
	int iRet = role_fly_move(pstRole, iFlyID, iFailHandleMode);
	
	return iRet;
}


int gm_sys_notice(LPROLE pstRole, const char*pszArg) 
{
	
	char szTemp[4096];
	int iID = 0;
	int iRet = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(!strncasecmp(szTemp, "loot", sizeof("loot")))
	{
		int iSysNoticeID = 0;
		int iSysNoticeProb = 1000;
		int iLootSceen = LOOT_SOLUTION_CALL_SENCE_DEFAULT;
		int iItemId = 20403042;
		//系统提示ID

		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (!szTemp[0]) 
		{
			system_msg_to_role(pstRole,"//sysnotice loot <NoticeID> <LootSceen> [ItemID].");
			return -1;
		}
		iSysNoticeID = atoi(szTemp);

		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (!szTemp[0]) 
		{
			system_msg_to_role(pstRole,"//sysnotice loot <NoticeID> <LootSceen> [ItemID].");
			return -1;
		}
		iLootSceen = atoi(szTemp);

		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) 
		{
			iItemId = atoi(szTemp);
		}
		
		
		LOOTITEMS astDropItems[2];
		astDropItems[0].ulResID = iItemId;
		astDropItems[0].iBestNotice = iSysNoticeID;
		astDropItems[0].iNoticeProb = iSysNoticeProb;
		astDropItems[1].ulResID = 14410103;
		astDropItems[1].iBestNotice = iSysNoticeID;
		astDropItems[1].iNoticeProb = iSysNoticeProb;
		int iDropItemNum = 2;
		int iBeforeDropItemNum = 0;

		LPITEM pstItem =  dropitem_byresid(iItemId,1,888,
				DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL);			
		item_loot_sysnotice(pstRole, astDropItems, iDropItemNum,iBeforeDropItemNum, iLootSceen,pstItem);
		destroy_dropitem(pstItem);
		
	}
	else //sysnotice ID
	{	
		if (szTemp[0]) iID = atoi(szTemp);
		else return -1;	

		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if(szTemp[0]) //有内容
		{
			SYSNOTICEMSG stSysNoticeMsg;
			memset(&stSysNoticeMsg, 0, sizeof(stSysNoticeMsg));
			stSysNoticeMsg.iID = iID;
			//由于gm不能输入空格，因此多参数时，gm输入 | ，程序将这些替换成空格
			char *p = szTemp;
			while(NULL != (p = strstr(p, "|")))
			{
				p[0] = ' ';
				p++;
			}
			set_sys_notice_str_var(&stSysNoticeMsg, szTemp); // 字符串参数
			iRet = direct_send_sys_notice_msg(pstRole, NULL, &stSysNoticeMsg,NULL,0, NULL);
		}
		else //无内容
		{
			iRet = send_sys_notice_msg(pstRole,NULL, iID, NULL, NULL, NULL,NULL);	
		}
	}
	return iRet;
}

int gm_execscript(LPROLE pstRole,const char*pszArg)
{
	char szFileName[256];
	char szFuncName[256];
	gm_get_val(&pszArg,szFileName,sizeof(szFileName));
	if(!szFileName[0])	
	{
		system_msg_to_role(pstRole,"fail to get script filename.");
		return -1;
	}
	gm_get_val(&pszArg,szFuncName,sizeof(szFuncName));
	if(!szFuncName[0])
	{
		system_msg_to_role(pstRole,"fail to get script funcname.");
		return -1;
	}

	char szTemp[10];
	int iVar1 = 0;
	int iVar2 = 0;
	int iVar3 = 0;
	char chVarNum = 0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) 
	{
		iVar1 = atoi(szTemp);
		chVarNum++;
	}
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) 
	{
		iVar2 = atoi(szTemp);
		chVarNum++;
	}
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) 
	{
		iVar3 = atoi(szTemp);
		chVarNum++;
	}
	
	init_script_env();
	set_script_env_role(pstRole);
	LPMAPINST pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	set_script_env_mapinst(pstMapInst);
	LPPWORLDINST pstPworldInst = find_pworld_inst(pstMapInst->ullPworldInstID,&pstMapInst->iPworldInstIndexPos);
	set_script_env_pworldinst(pstPworldInst);

	if (1 == chVarNum)
	{
		if(new_exec_script(szFileName,szFuncName,"%d",iVar1)>=0)
		{
			system_msg_to_role(pstRole,"success exec script.");
			return 0;
		}
	}
	else if (2 == chVarNum)
	{
		if(new_exec_script(szFileName,szFuncName,"%d%d",iVar1,iVar2)>=0)
		{
			system_msg_to_role(pstRole,"success exec script.");
			return 0;
		}
	}
	else if (3 == chVarNum)
	{
		if(new_exec_script(szFileName,szFuncName,"%d%d%d",iVar1,iVar2,iVar3)>=0)
		{
			system_msg_to_role(pstRole,"success exec script.");
			return 0;
		}
	}
	else
	{
		if(new_exec_script(szFileName,szFuncName,NULL)>=0)
		{
			system_msg_to_role(pstRole,"success exec script.");
			return 0;
		}
	}
	system_msg_to_role(pstRole,"fail exec script.");
	return -1;
}

int gm_role_act_data(LPROLE pstRole,const char*pszArg) 
{
	char szTemp[128];
	char chType = 0;//get,set
	int iActID = -1;
	int iVarID = -1;
	int iValue = -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) chType = atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iActID = atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iVarID = atoi(szTemp);
	else return -1;
	
	if (iVarID<0 || iVarID >= ACT_DATA_FOR_ROLE_VALUE_MAX)
		return -1;

	if (chType == 0)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iValue = atoi(szTemp);
		else return -1;
	}

	if (chType == 0)//set
	{
		return set_role_act_event_var(pstRole, iActID, iVarID, iValue);
	}
	else if(chType == 1)//get
	{
		int iRet = get_role_act_event_var(pstRole, iActID, iVarID, &iValue);
		if (iRet != 0)
		{
			return -1;
		}
		sprintf(szTemp, "role: act[%d]var[%d]is%d", iActID, iVarID, iValue);
		system_msg_to_role(pstRole, szTemp);
	}

	return 0;
}



int gm_commdata_info(LPROLE pstRole,const char *pszArg)
{

	int iActID = -1;

	char szTemp[128];

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iActID = atoi(szTemp);
	else return -1;

	switch(iActID)
	{

		case MINIGAME_CHARGE_SHOP_ACT_ID:
		{
			char chType = 0;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) chType = atoi(szTemp);
			else return -1;
			if(chType == 1)  //查询排行
			{
				//查询充值活动积分排行
				int iTopNum = 0;
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (szTemp[0]) iTopNum = atoi(szTemp);
				else return -1;
		
				if(iTopNum > CHARGE_RANK_NUM)
				{
					iTopNum = CHARGE_RANK_NUM;
				}
			
				LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_ACT_CHARGE);
				if(pstCommData == NULL)
				{
					return -1;
				}

				LPCOMMCHARGEACTDATA pstActData = &pstCommData->stChargeActData;	
				system_msg_to_role(pstRole,"Rank Num:%d",pstActData->bRankNum);

				int i= 0;
				for( i=0; i< iTopNum && i < pstActData->bRankNum; i++)
				{
					system_msg_to_role(pstRole,"Rank:%d Historyscore:%d uin:%u rolename:%s curscore:%d",
						i+1,pstActData->astRankData[i].iChargeValue, 
						pstActData->astRankData[i].ulUin,
						pstActData->astRankData[i].szRoleName,					
						pstActData->astRankData[i].iChargeCurValue);

				}	
			}
			else if(chType == 2)
			{

				//查询角色当前的积分情况
				
				int iChargeScore = 0;
				int iTotalScore = 0;
				if (get_role_act_event_var(pstRole, MINIGAME_CHARGE_SHOP_ACT_ID, 0, &iChargeScore) != 0)
				{
					return -1;
				}

				if (get_role_act_event_var(pstRole, MINIGAME_CHARGE_SHOP_ACT_ID, 1, &iTotalScore) != 0)
				{
					return -1;
				}
				system_msg_to_role(pstRole,"current role charge score:%d history score:%d",
						iChargeScore,iTotalScore);
			
			}
			else if(chType == 3)
			{
				//手工加积分
				int iChargeValue = 0;
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (szTemp[0]) iChargeValue = atoi(szTemp);
				else return -1;
				if (!is_act_running(MINIGAME_CHARGE_GIFT_ACT_ID))//活动未开启  
				{
					return -1;
				}	
				if(!is_act_running(MINIGAME_CHARGE_SHOP_ACT_ID))
				{
					return -1;
				}
				//0 号 ID 代表 可消耗积分
				//1 号 ID 代表 历史积分	

				add_role_act_event_var(pstRole,MINIGAME_CHARGE_SHOP_ACT_ID,0,iChargeValue);
				add_role_act_event_var(pstRole,MINIGAME_CHARGE_SHOP_ACT_ID,1,iChargeValue);		
				insert_charge_act_rank(pstRole);
				system_msg_to_role(pstRole,"add score success.");
			}
			else if(chType == 4)
			{

				if (!is_act_running(MINIGAME_CHARGE_GIFT_ACT_ID))//活动未开启  
				{
					return -1;
				}	
				if(!is_act_running(MINIGAME_CHARGE_SHOP_ACT_ID))
				{
					return -1;
				}

				LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_ACT_CHARGE);
				if(pstCommData == NULL)
				{
					return -1;
				}

				LPCOMMCHARGEACTDATA pstActData = &pstCommData->stChargeActData;	
				system_msg_to_role(pstRole,"Rank Num:%d",pstActData->bRankNum);

				pstActData->bRankNum = 0;
				system_msg_to_role(pstRole,"clear ok Rank Num:%d",pstActData->bRankNum);

			}
			else if(chType == 5)
			{
				//给指定QQ在线角色增减积分
				if (!is_act_running(MINIGAME_CHARGE_GIFT_ACT_ID))//活动未开启  
				{
					return -1;
				}	
				if(!is_act_running(MINIGAME_CHARGE_SHOP_ACT_ID))
				{
					return -1;
				}

				unsigned int ulUin = 0;
				int iChargeValue = 0;
				int iIfUpRank = 1;

				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (szTemp[0]) 
					ulUin = atoll(szTemp);
				else 
					return -1;
				LPROLE pstTargetRole = uin_to_role(ulUin);
				if(NULL == pstTargetRole)
				{
					system_msg_to_role(pstRole, "目标不在线");
					return -1;
				}
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (szTemp[0]) 
					iChargeValue = atoi(szTemp);
				else 
					return -1;
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (szTemp[0]) 
					iIfUpRank = atoi(szTemp);

				//0 号 ID 代表 可消耗积分
				//1 号 ID 代表 历史积分	
				add_role_act_event_var(pstTargetRole,MINIGAME_CHARGE_SHOP_ACT_ID,0,iChargeValue);
				add_role_act_event_var(pstTargetRole,MINIGAME_CHARGE_SHOP_ACT_ID,1,iChargeValue);		

				if (iIfUpRank)
					insert_charge_act_rank(pstTargetRole);

				system_msg_to_role(pstRole,"add score success.");
			}
			break;

		} 
		default:
			break;

	}

	return 0;
}


int gm_comm_act_data(LPROLE pstRole,const char*pszArg) 
{
	char szTemp[128];
	char chType = 0;//get,set
	int iActID = -1;
	int iVarID = -1;
	int iValue = -1;
	
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) chType = atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iActID = atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) iVarID = atoi(szTemp);
	else return -1;
	
	if (iVarID<0 || iVarID >= PER_ACT_COMMDATA_MAX)
		return -1;

	if (chType == 0)
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iValue = atoi(szTemp);
		else return -1;
	}

	if (chType == 0)//set
	{
		return set_comm_act_event_var(iActID, iVarID, iValue);
	}
	else if(chType == 1)//get
	{


		int iRet = get_comm_act_event_var(iActID, iVarID, &iValue);
		if (iRet != 0)
		{
			return -1;
		}
		sprintf(szTemp, "commact: act[%d]var[%d]is%d", iActID, iVarID, iValue);
		system_msg_to_role(pstRole, szTemp);
	}

	return 0;
}

int gm_worldcup(LPROLE pstRole,const char *pszArg)
{
	char szTemp[80];

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (strcmp(szTemp, "display") == 0)
	{
		int iSeq = 0;
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iSeq = atoi(szTemp);
		if (iSeq < 1 || iSeq > MAX_WORLD_CUP_MATCH)
		{
			system_msg_to_role(pstRole, "match seq should between [1, 64]");
			return -1;
		}
		LPACTCOMMDATA pstCommActData = get_comm_act_data_by_actid(MINIGAME_WORLD_CUP_ACT_ID, 1);
		if (NULL == pstCommActData)
		{
			system_msg_to_role(pstRole, "act data not found and create fail, maybe act not opened!");
			return -1;
		}
		if (pstCommActData->stPerActData.stWorldCup.chMatchNum < iSeq)
		{
			system_msg_to_role(pstRole, "seq too large, cur match num %d", pstCommActData->stPerActData.stWorldCup.chMatchNum);
			return -1;
		}
		LPMATCH pstMatch = &pstCommActData->stPerActData.stWorldCup.astMatchData[iSeq-1];
		system_msg_to_role(pstRole, "seq[%d]: team A[%d]to B[%d], score A[%d] to B[%d]", 
			pstMatch->bSeq, pstMatch->bPlayerA, pstMatch->bPlayerB, pstMatch->bScoreA, pstMatch->bScoreB);
	}
	else if (strcmp(szTemp, "set") == 0)
	{
		int iSeq = 0;
		int iTeamA = 0;
		int iTeamB = 0;
		int iScoreA = 0;
		int iScoreB = 0;
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iSeq = atoi(szTemp);
		if (iSeq < 1 || iSeq > MAX_WORLD_CUP_MATCH)
		{
			system_msg_to_role(pstRole, "match seq should between [1, 64]");
			return -1;
		}
		
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iTeamA = atoi(szTemp);
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iTeamB = atoi(szTemp);
		
		if (iTeamA < 0 || iTeamA > MAX_WORLD_CUP_TEAM || iTeamB < 0 || iTeamB > MAX_WORLD_CUP_TEAM)
		{
			system_msg_to_role(pstRole, "team should between [1, 32]");
			return -1;
		}
		
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iScoreA = atoi(szTemp);
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iScoreB = atoi(szTemp);
		
		if (iScoreA < 0 || iScoreB < 0)
		{
			system_msg_to_role(pstRole, "score should >= 0");
			return -1;
		}
		
		LPACTCOMMDATA pstCommActData = get_comm_act_data_by_actid(MINIGAME_WORLD_CUP_ACT_ID, 1);
		if (NULL == pstCommActData)
		{
			system_msg_to_role(pstRole, "act data not found and create fail, maybe act not opened!");
			return -1;
		}
		if (pstCommActData->stPerActData.stWorldCup.chMatchNum < iSeq-1)
		{
			system_msg_to_role(pstRole, "please set match in order!");
			return -1;
		}

		if (0 == iTeamA || 0 == iTeamB)//想要删掉这场比赛及之后的所有比赛
		{
			pstCommActData->stPerActData.stWorldCup.chMatchNum = iSeq - 1;
			return 0;
		}
		LPMATCH pstMatch = &pstCommActData->stPerActData.stWorldCup.astMatchData[iSeq-1];
		pstMatch->bSeq = iSeq;
		pstMatch->bPlayerA = iTeamA;
		pstMatch->bPlayerB = iTeamB;
		pstMatch->bScoreA = iScoreA;
		pstMatch->bScoreB = iScoreB;
		if (pstCommActData->stPerActData.stWorldCup.chMatchNum == iSeq-1)
		{
			pstCommActData->stPerActData.stWorldCup.chMatchNum = iSeq;//新增了一场
		}
		init_world_cup_data(pstCommActData);
		
	}
	else if (strcmp(szTemp, "setall") == 0)
	{
		int iNum = 64;
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iNum = atoi(szTemp);
		iNum = CLAMP(iNum, 0, MAX_WORLD_CUP_MATCH);
		
		LPACTCOMMDATA pstCommActData = get_comm_act_data_by_actid(MINIGAME_WORLD_CUP_ACT_ID, 1);
		if (NULL == pstCommActData)
		{
			system_msg_to_role(pstRole, "act data not found and create fail!");
			return -1;
		}
	
		pstCommActData->stPerActData.stWorldCup.chMatchNum = fo2_rl_xload("fo2_worldcupresult","WorldCupResultTab",
				(char*)pstCommActData->stPerActData.stWorldCup.astMatchData,MAX_WORLD_CUP_MATCH*sizeof(MATCH) , sizeof(MATCH));
	
		if (pstCommActData->stPerActData.stWorldCup.chMatchNum <= 0)
		{
			system_msg_to_role(pstRole, "fail to load match res");
			return -1;
		}
		
#if 0
		FILE *fp;
		int j = 0;
		if((fp = fopen("worldcup.txt","w")) != NULL)
		{
			for(j = 0; j < pstCommActData->stWorldCup.chMatchNum; j++)
			{
				LPMATCH pstMatch =pstCommActData->stWorldCup.astMatchData+j;
				fprintf(fp,"%d %d %d %d %d\n",pstMatch->bSeq,pstMatch->bPlayerA,pstMatch->bPlayerB,pstMatch->bScoreA,pstMatch->bScoreB);
			}
			fclose(fp);
		}
#endif
		pstCommActData->stPerActData.stWorldCup.chMatchNum = iNum;
		init_world_cup_data(pstCommActData);
	
	}
	else
	{
		system_msg_to_role(pstRole, "Undefined cmd. cmd: display/set/setall");
	}

	return 0;
}

int gm_act_loot(LPROLE pstRole, const char*pszArg)
{
	char szTemp[128];
	int iType = 0;
	int iSulutionID = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	if(!strncasecmp(szTemp, "disable", sizeof("disable")))
	{
		set_act_loot_disable(1);
	}
	else if(!strncasecmp(szTemp, "enable", sizeof("enable")))
	{
		set_act_loot_disable(0);
	}
	else if(!strncasecmp(szTemp, "insert", sizeof("insert")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iType = atoi(szTemp);
		else return -1;
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iSulutionID = atoi(szTemp);
		else return -1;
	
		insert_act_loot_solution(iType, iSulutionID);
	}
	else if(!strncasecmp(szTemp, "delete", sizeof("delete")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iType = atoi(szTemp);
		else return -1;
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iSulutionID = atoi(szTemp);
		else return -1;
		
		del_act_loot_solution(iType, iSulutionID);
	}
	else if(!strncasecmp(szTemp, "print", sizeof("print")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if (szTemp[0]) iType = atoi(szTemp);
		else return -1;
		
		char szMsg[512];
		print_act_loot_by_type(iType, szMsg, 512);
		system_msg_to_role(pstRole, szMsg);
	}
	else
	{
		system_msg_to_role(pstRole, "undefined cmd");
	}
	

	return 0;
}

int gm_deal(LPROLE pstRole,const char*pszArg) 
{
	
	char szTemp[128];
	char szFileName[128];
	CSDEALC stDealC;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stDealC.chOperation = atoi(szTemp);
	else return -1;

	// deal CmdID Selllist filepath+name
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stDealC.iSellListID = (unsigned int)atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) strcpy(szFileName, szTemp);
	else return -1;

	// 文件格式
	//num 个数
	//    char chResType;                       	/*   0 CS_RES_ITEM/1 CS_RES_ARM/ 2 /CS_RES_CARD-none */
	//    int iResID;
	//    char chPosType;                       	/*   销售物品所在的储存类型 */
	//    char chBagIndex;                      	/*   销售物品所在背包的位置索引 */
	//    char chItemIndex;                     	/*   销售物品在储物格中的索引ID  */
	//    char chTmpIndex;                      	/*   物品在P2P交易框(或回购框)中的位置（从0开始行向排号，满后再新一行继续编号） */
	//    int iNumber;

	FILE* fp = fopen(szFileName, "r");
	if(NULL == fp)
		return -1;
	fgets(szTemp, 128, fp);
	stDealC.chTotal = atoi(szTemp);
	int i = 0;
	for(; i < (int)stDealC.chTotal; i++)
	{
		LPCSDEALITEM pitem = &stDealC.astItems[i];
		fgets(szTemp, 128, fp);
		pitem->chResType = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->iResID = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chPosType = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chBagIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chItemIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chTmpIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->iNumber = atoi(szTemp);
	}
	fclose(fp);

	int iRet = process_deal_cmd(pstRole, &stDealC, NULL, NULL);
	if(CS_ENO_NOERR != iRet)
	{
		return -1;
	}
	return 0;

}

int gm_exchange(LPROLE pstRole,const char*pszArg) 
{
	// exchange CmdID Rolezid filepath+name
	char szTemp[128];
	char szFileName[128];
	CSEXCHANGEC stExhangeC;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stExhangeC.chOperation = atoi(szTemp);
	else return -1;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stExhangeC.ulYourID = atoll(szTemp);
	else return -1;
	if(0 == stExhangeC.ulYourID) // 打印一下自己的zid
	{
		char sTmpStr[1024];
		sprintf(sTmpStr, "role(uin=%u) zid=%u", get_role_uin(pstRole), get_role_zid(pstRole));
		system_msg_to_role(pstRole, sTmpStr);
		log_info(LOG_ERR, sTmpStr);
		return -1;
	}
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) strcpy(szFileName, szTemp);
	else return -1;

	// 文件格式
	// money 交易金额
	//num 个数
	//    char chResType;                       	/*   0 CS_RES_ITEM/1 CS_RES_ARM/ 2 /CS_RES_CARD-none */
	//    int iResID;
	//    char chPosType;                       	/*   销售物品所在的储存类型 */
	//    char chBagIndex;                      	/*   销售物品所在背包的位置索引 */
	//    char chItemIndex;                     	/*   销售物品在储物格中的索引ID  */
	//    char chTmpIndex;                      	/*   物品在P2P交易框(或回购框)中的位置（从0开始行向排号，满后再新一行继续编号） */
	//    int iNumber;

	FILE* fp = fopen(szFileName, "r");
	if(NULL == fp)
		return -1;
	fgets(szTemp, 128, fp); // money
	stExhangeC.stData.iMoney = atoi(szTemp);
	fgets(szTemp, 128, fp);
	stExhangeC.stData.chTotal = atoi(szTemp); // sum
	int i = 0;
	for(; i < (int)stExhangeC.stData.chTotal; i++)
	{
		LPCSDEALITEM pitem = &stExhangeC.stData.astExchanges[i];
		fgets(szTemp, 128, fp);
		pitem->chResType = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->iResID = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chPosType = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chBagIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chItemIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->chTmpIndex = atoi(szTemp);
		fgets(szTemp, 128, fp);
		pitem->iNumber = atoi(szTemp);
	}
	fclose(fp);

	int iRet = process_exchange_cmd(pstRole, &stExhangeC);
	if(CS_ENO_NOERR != iRet)
	{
		return -1;
	}
	return 0;

}

int gm_exchanger(LPROLE pstRole,const char*pszArg) 
{
	// exchanger CmdID 
	char szTemp[128];

	CSEXCHANGEROPRC stExchangerOprC;
	
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0]) stExchangerOprC.chOperation = atoi(szTemp);
	else return -1;

	switch(stExchangerOprC.chOperation)
	{
		case CS_EXCHANGER_OPR_QUREY_ORDERS:
			break;
		case CS_EXCHANGER_OPR_QUREY_MY_ORDERS:
			break;
		case CS_EXCHANGER_OPR_POST_ORDER: // + type + unitprice + sum
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) stExchangerOprC.stData.stOrderItem.chType = atoi(szTemp);  
			else return -1;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) stExchangerOprC.stData.stOrderItem.iUintPrice = atoi(szTemp);  
			else return -1;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) stExchangerOprC.stData.stOrderItem.iSum = atoi(szTemp);  
			else return -1;
			break;
		case CS_EXCHANGER_OPR_CANCEL_ORDER: // + type + gid
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) stExchangerOprC.stData.stOrderItem.chType = atoi(szTemp);  
			else return -1;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0]) stExchangerOprC.stData.stOrderItem.ullSeqGID = strtoull(szTemp, NULL, 10);  
			else return -1;
			break;
		case 100:
		{	//进行tick的测试
			char chType = 0;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));			
			if (szTemp[0]) chType = atoi(szTemp);
			else return -1;
			return tick_exchanger_opr(chType);
		}
		case 101:
		{
			return print_exchanger_info(pstRole);
		}
		case 102: //强制关闭交易所
		{
			set_exchanger_state(EXCHANGER_DATA_STATE_STOP);
			break;	
		}
		case 103: //恢复交易所
		{
			set_exchanger_state(EXCHANGER_DATA_STATE_OK);
			break;
		}
		default:
			return -1;
	}	
	return process_exchanger_opr_cmd(pstRole, &stExchangerOprC);	
}

int gm_skill(LPROLE pstRole, const char *pszArg)
{
	char szHelp[4096];
	sprintf(szHelp, "//skill prac $value -- 设置每释放一次技能，熟练度增加$value\n"
			      "//skill setprac $skillid $value -- 直接设置指定技能的熟练度数值为$value\n"
			      "//skill modify $ID $ArrayIndex $EffectID $Prob $Unit $Value $Target -- 直接修改技能效果属性\n"
			       "//skill reload --重新加载技能表格，用于修复上面modify指令被修改的部分\n"
			       "//skill guildskill $initValue $effectid --家族技能效果修正查询，输入原始值和效果值，获得结果值打印，效果ID列表找程序提供。"
			      );
	char szTemp[80];
	int iSkillid = 0;
	//int iValue = 0;
	

	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	if(!strncasecmp(szTemp, "prac", sizeof("prac")))
	{
		return -1;
		/*
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iValue = atoi(szTemp);
		if(iValue<= 0)
		{
			iValue = 1;
		}
		
		pstRole->nPracAdd = iValue;
		sprintf(szHelp, "PracAdd=%d, 当前每释放一次技能，技能熟练度增加%d\n", iValue, iValue);
		system_msg_to_role(pstRole, szHelp);
		*/
	}	
	else if(!strncasecmp(szTemp, "setprac", sizeof("setprac")))
	{
		return -1;
		/*
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iSkillid = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iValue = atoi(szTemp);
		if(iValue< 0)
		{
			iValue = 0;
		}	

		LPZONESKILL pstZoneSkill = find_skill_ignore_level(pstRole->astSkill, pstRole->iSkill, iSkillid);
		if(NULL == pstZoneSkill)
		{
			system_msg_to_role(pstRole, "技能没有学习.");
			return -1;
		}
		LPRESSKILL pstResSkill = find_skill_def(pstZoneSkill->iID);
		if(NULL == pstResSkill)
		{
			system_msg_to_role(pstRole, "技能不存在.");
			return -1;
		}		
		if(iValue > pstResSkill->iPracMax) //修改一下最大值
		{
			iValue = pstResSkill->iPracMax;
		}
		
		pstZoneSkill->iPrac = iValue; //设置值

		role_query_skill(pstRole); 
		
		sprintf(szHelp, "技能(%d) 当前的熟练度为%d\n", iSkillid, iValue);
		system_msg_to_role(pstRole, szHelp);
		*/
	}
	else if(!strncasecmp(szTemp, "modify", sizeof("modify")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iSkillid = atoi(szTemp);
		LPRESSKILL pstResSkill = find_skill_def(iSkillid);
		if(NULL == pstResSkill)
		{
			system_msg_to_role(pstRole, "技能不存在.");
			return -1;
		}
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		int iArrayIndex = atoi(szTemp);
		if(iArrayIndex <0 || iArrayIndex >= RES_MAX_SKILL_EFFECT)
		{
			system_msg_to_role(pstRole, "技能效果位置不存在.");
			return -1;
		}
		if(iArrayIndex >= pstResSkill->chTotalEffect)
		{
			pstResSkill->chTotalEffect++;
		}		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		pstResSkill->astEffect[iArrayIndex].nEffectID = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		pstResSkill->astEffect[iArrayIndex].chProb = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		pstResSkill->astEffect[iArrayIndex].chUnit = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		pstResSkill->astEffect[iArrayIndex].iValue= atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		pstResSkill->astEffect[iArrayIndex].chTarget = atoi(szTemp);
		return 0;		
	}
	else if(!strncasecmp(szTemp, "reload", sizeof("reload")))
	{
		return init_skill_pool(get_skillpool(), 0);		
	}
	else if(!strncasecmp(szTemp, "guildskill", sizeof("guildskill")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iInitValue = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{		
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iEffectID = atoi(szTemp);
		int iValue = role_guild_skill_cond_effect_revise(pstRole, RES_COND_EFFECT_TYPE_SUC, iEffectID, iInitValue, 0);
		if(iValue == iInitValue) //gm就先做简单处理了
		{
			iValue = role_guild_skill_cond_effect_revise(pstRole, RES_COND_EFFECT_TYPE_MONEY, iEffectID, iInitValue, 0);
		}
		sprintf(szHelp, "初始值:%d，修正后的值:%d", iInitValue, iValue);
		system_msg_to_role(pstRole, szHelp);
		return 0;			
	}
	else if(!strncasecmp(szTemp, "zakocomp", sizeof("zakocomp")))
	{
		CSSKILLC stSkillC;
		stSkillC.chOp = CS_SKILL_OP_ZAKO_COMP;
		stSkillC.stOtherSkillInfo.stItemIDList.chTotal = 4; //固定用前4个即可
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[0].chType = CS_LISTTYPE_COMMITEM;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[0].chItemIndex = 0;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[1].chType = CS_LISTTYPE_COMMITEM;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[1].chItemIndex = 1;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[2].chType = CS_LISTTYPE_COMMITEM;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[2].chItemIndex = 2;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[3].chType = CS_LISTTYPE_COMMITEM;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[3].chItemIndex = 3;
		return role_skill_zako_comp(pstRole, &stSkillC);
	}
	else if(!strncasecmp(szTemp, "zakodecomp", sizeof("zakodecomp")))
	{
		CSSKILLC stSkillC;
		stSkillC.chOp = CS_SKILL_OP_ZAKO_DECOMP;
		stSkillC.stOtherSkillInfo.stItemID.chType = CS_LISTTYPE_COMMITEM;
		stSkillC.stOtherSkillInfo.stItemIDList.astItems[0].chItemIndex = 0;
		return role_skill_zako_decomp(pstRole, &stSkillC);
	}

	return 0;
}

int gm_masterskill(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	int iSkillID;
	short nEno;
	char szErrMsg[][128]={
		"剩余技能点不足",
		"职业需求不符",
		"没有该等级技能的定义信息",
		"该等级技能已掌握",
		"已经达到技能等级上限",
		"等级要求不符",
		"前置点数不足",
		"前置技能不符",
		"删除技能失败",
		"增加技能失败",
		"没有掌握该等级技能所需的技能书",
		"技能只能递增逐级掌握",
		"没有足够的金钱",
		"没有足够的经验值",
		"技能系别错误",
	};

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	iSkillID = 0;
	if (szTmp[0])
	{
		iSkillID = atoi(szTmp);
	}

	if (iSkillID <= 0)
	{
		return -1;
	}

	role_master_skill(pstRole, iSkillID, NULL, CS_SKILL_OP_LEARN);
	nEno = get_skill_system_eno();
	if (nEno == CS_ENO_NOERR)
	{
		return 0;
	}
	else
	{
		//nEno -= CS_CODE_COMBAT_MIN;
		if (nEno >= 0 && nEno < sizeof(szErrMsg)/sizeof(szErrMsg[0]))
		{
			system_msg_to_role(pstRole, szErrMsg[nEno]);
		}
		else
		{
			//sprintf(szTmp, "未知错误:%d，请查fo2_cs.xml的错误码列表", nEno+CS_CODE_COMBAT_MIN);
			sprintf(szTmp, "未知错误:%d，请查fo2_cs.xml的错误码列表", nEno);
			system_msg_to_role(pstRole, szTmp);
		}
		return -1;
	}
}

int gm_masterfamilyskill(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	int iSkillID;
	short nEno;
	char szErrMsg[][128]={
		
		"剩余技能点不足",
		"职业需求不符",
		"没有该等级技能的定义信息",
		"该等级技能已掌握",
		"已经达到技能等级上限",
		"等级要求不符",
		"前置点数不足",
		"前置技能不符",
		"删除技能失败",
		"增加技能失败",
		"没有掌握该等级技能所需的技能书",
		"技能只能递增逐级掌握",
		"没有足够的金钱",
		"没有足够的经验值",
		"技能系别错误",
	};

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	iSkillID = 0;
	if (szTmp[0])
	{
		iSkillID = atoi(szTmp);
	}

	if (iSkillID <= 0)
	{
		return -1;
	}

	//role_master_family_skill(pstRole, iSkillID, NULL, CS_SKILL_OP_LEARN);
	role_master_skill(pstRole, iSkillID, NULL, CS_SKILL_OP_LEARN);
	nEno = get_skill_system_eno();
	if (nEno == CS_ENO_NOERR)
	{
		return 0;
	}
	else
	{
		//nEno -= CS_CODE_COMBAT_MIN;
		if (nEno >= 0 && nEno < sizeof(szErrMsg)/sizeof(szErrMsg[0]))
		{
			system_msg_to_role(pstRole, szErrMsg[nEno]);
		}
		else
		{
			//sprintf(szTmp, "未知错误:%d，请查fo2_cs.xml的错误码列表", nEno+CS_CODE_COMBAT_MIN);
			sprintf(szTmp, "未知错误:%d，请查fo2_cs.xml的错误码列表", nEno);
			system_msg_to_role(pstRole, szTmp);
		}
		return -1;
	}

}

int gm_cloneskill(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	int iSkillID;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	iSkillID = 0;
	if (szTmp[0])
	{
		iSkillID = atoi(szTmp);
	}

	if (iSkillID <= 0)
	{
		return -1;
	}

	return role_clone_skill(pstRole, iSkillID);
}

int gm_forgetskill(LPROLE pstRole, const char *pszArg)
{
	return role_forget_skill(pstRole);
}

int gm_batchskill(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	int iBatchID;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (!szTmp[0])
	{
		return -1;
	}
	if(!strncasecmp(szTmp, "prof", sizeof("prof")))
	{
		iBatchID = 0;	
	}
	else
	{
		iBatchID = atoi(szTmp);
		if (iBatchID <= 0)
		{
			return -1;
		}		
	}
	return role_batch_clone_skill(pstRole, iBatchID);;	
}


int gm_stat(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	short nID = 0;
	if (szTmp[0])
	{
		nID = atoi(szTmp);
	}
	char chIs = 0;
	if(nID < RES_STAT_EFFECT_MIN) //普通状态
	{
		if(0 == is_commstat(pstRole, nID))
		{
			chIs = 1;
		}
	}
	else //特殊状态
	{
		if(NULL != find_specstat(&pstRole->stSpecStatList,  nID))
		{
			chIs = 1;
		}		
	}
	if(1 == chIs)
	{
		system_msg_to_role(pstRole, "You are in this stat.");
	}
	else
	{
		system_msg_to_role(pstRole, "You are not in this stat.");
	}
	return 0;
}

int gm_applystat(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	short nID;
	int iLevel;
	unsigned int ulZID;
	LPROLE pstTRole;
	LPMONSTER pstTMon;
	LPPET pstTPet;
	CU stGiver;
	CU stTarget;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	nID = 0;
	if (szTmp[0])
	{
		nID = atoi(szTmp);
	}

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	iLevel = 1; //默认是加1级
	if (szTmp[0])
	{
		iLevel = atoi(szTmp);
	}

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	ulZID = 0;
	if (szTmp[0])
	{
		ulZID = atoll(szTmp);
	}

#if 1 //新加逻辑，针对于非选择对象的额外处理，用nLevel的负数值来支持 --- 主要是用来测试的
	if (iLevel == -1)
	{
		return role_specstat_client_timeout(pstRole, nID);
	}
	else if (iLevel == -100)
	{
		return role_remove_specstat_by_pile(pstRole, nID, 1);  //移走其中某个buff的一个层次
	}
	else if (iLevel < -4000) //取消某个角色的特殊状态(当前只支持在线)
	{
		unsigned int ulUin = -iLevel;   //-iLevel 代表的是QQ号码
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			return -1;
		}				
		return role_remove_specstat(pstTargetRole, nID);
	}
#endif	

	if (0 > init_cu_by_zid(&stGiver, pstRole->stObject.ulID))
	{
		return -1;
	}

	switch (zid_to_type(ulZID))
	{
		case OBJ_ROLE:
			pstTRole = zid_to_role(ulZID);
			if (NULL == pstTRole)
			{
				return -1;
			}
			
			if (iLevel > 0)
			{
				if (0 > init_cu_by_zid(&stTarget, pstTRole->stObject.ulID))
				{
					return -1;
				}
				return cu_apply_specstat(&stTarget, nID, iLevel,0, &stGiver, NULL, 0);
			}
			else
			{
				return role_remove_specstat(pstTRole, nID);
			}
			break;
		case OBJ_MONSTER:
			pstTMon = zid_to_monster(ulZID);
			if (NULL == pstTMon)
			{
				return -1;
			}
			if (iLevel > 0)
			{
				if (0 > init_cu_by_zid(&stTarget, pstTMon->stObject.ulID))
				{
					return -1;
				}
				return cu_apply_specstat(&stTarget, nID, iLevel,0, &stGiver, NULL, 0);
			}
			else
			{
				return monster_remove_specstat(pstTMon, nID);
			}
			break;
		case OBJ_PET:
			pstTPet = zid_to_pet(ulZID);
			if (NULL == pstTPet)
			{
				return -1;
			}

			if (iLevel > 0)
			{
				if (0 > init_cu_by_zid(&stTarget, pstTPet->stObject.ulID))
				{
					return -1;
				}
				return cu_apply_specstat(&stTarget, nID, iLevel,0, &stGiver, NULL, 0);
			}
			else
			{
				return pet_remove_specstat(pstTPet, nID);
			}
			break;
		default:
			if (iLevel > 0)
			{
				if (0 > init_cu_by_zid(&stTarget, pstRole->stObject.ulID))
				{
					return -1;
				}
				return cu_apply_specstat(&stTarget, nID, iLevel,0, &stGiver, NULL, 0);
			}
			else
			{
				return role_remove_specstat(pstRole, nID);
			}
	}

}

int gm_setprof(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	char chProf;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

//	chProf = RES_PROF_NEWBIE_WARRIOR;
	chProf = RES_PROF_WARRIOR;
	if (szTmp[0])
	{
		chProf = atoi(szTmp);
	}

	return set_role_prof(pstRole, chProf);
}

int gm_clear_loot_control(LPROLE pstRole, const char *pszArg)//added by yanbinchen
{
	char szTmp[128];
	int iItemID = 0;
	int iCtlCode = 0;
	char szOp[128];

	gm_get_val(&pszArg, szOp, sizeof(szOp));
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iItemID = atoi(szTmp);
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iCtlCode = atoi(szTmp);
	}

	if (iItemID <= 0)
	{
		return -1;
	}
	
	LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_LOOT_CONTROL);
	CHECK_PARAM_RET(pstCommData, -1);

	if (!strcasecmp(szOp, "clear"))
	{
		log_info(LOG_INFO, "%s:uin[%u] operator use gm to clear loot control count [itemid[%d] code[%d]].", 
			__FUNCTION__,
			pstRole->ulUin, iItemID, iCtlCode);
		return clear_loot_control(iItemID, iCtlCode);
	}
	else if (!strcasecmp(szOp, "show"))
	{
		LPRESLOOTCONTROL pstDef = find_loot_control_def(iItemID, iCtlCode, NULL);
		if (NULL == pstDef)
		{
			system_msg_to_role(pstRole, "ItemId[%d] no exist in loot control res.", iItemID);
			return 0;
		}

		LOOTCONTROLITEMDATA stData;
		stData.iItemID = iItemID;
		stData.iCtlCode = iCtlCode;
		int iEqu = 0;
		int iPos = my_bsearch(&stData, pstCommData->stLootControl.astList, pstCommData->stLootControl.iCount, 
			sizeof(pstCommData->stLootControl.astList[0]), &iEqu, loot_control_data_comp); 
		if (iPos < 0 || !iEqu)
		{
			log_info_m(LOG_MODULE_ITEM, LOG_ERR, "%s: find item[%d] loot control data from commdata error.", __FUNCTION__, iItemID); 
			return -1;
		}

		LPLOOTCONTROLITEMDATA  pstData = &pstCommData->stLootControl.astList[iPos]; 

		system_msg_to_role(pstRole,"ItemID[%d] hour[%d:%d] day[%d:%d] week[%d:%d] month[%d:%d].", 
			iItemID, 
			pstDef->iHourControlCount, pstData->iHourLootCount, 
			pstDef->iDayControlCount,pstData->iDayLootCount, 
			pstDef->iWeekControlCount, pstData->iWeekLootCount, 
			pstDef->iMonthControlCount, pstData->iMonthLootCount); 
		
		return 0;
	}
	else if (!strcasecmp(szOp, "set"))
	{
		char szType[128];
		char szCount[32];

		LOOTCONTROLITEMDATA stData;
		stData.iItemID = iItemID;
		stData.iCtlCode = iCtlCode;
		int iEqu = 0;
		int iPos = my_bsearch(&stData, pstCommData->stLootControl.astList, pstCommData->stLootControl.iCount, 
			sizeof(pstCommData->stLootControl.astList[0]), &iEqu, loot_control_data_comp); 
		if (iPos < 0 || !iEqu)
		{
			log_info_m(LOG_MODULE_ITEM, LOG_ERR, "%s: find item[%d] loot control data from commdataerror.", __FUNCTION__, iItemID); 
			return -1;
		}

		LPLOOTCONTROLITEMDATA  pstData = &pstCommData->stLootControl.astList[iPos]; 

		gm_get_val(&pszArg, szType, sizeof(szType));
		gm_get_val(&pszArg, szCount, sizeof(szCount));
		int iCount = atoi(szCount);
		if (!strcasecmp(szType, "hour"))
		{
			pstData->iHourLootCount = iCount;
		}
		else if (!strcasecmp(szType, "day"))
		{
			pstData->iDayLootCount = iCount;
		}
		else if (!strcasecmp(szType, "week"))
		{
			pstData->iWeekLootCount = iCount;
		}
		else if (!strcasecmp(szType, "month"))
		{
			pstData->iMonthLootCount = iCount;
		}
		else
		{
			return -1;
		}
		return 0;
	}

	return -1;
}

int gm_item_gid(LPROLE pstRole, const char *pszArg) // added by lcs for gid
{
	if(NULL == pstRole)
	{
		return -1;
	}
	unsigned long long ullGID = 0;
	char szTmp[128];
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	int iCmdID = 0;
	if (szTmp[0])
	{
		iCmdID = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	if(iCmdID == 0) // 0=生成一个GID，打印一下
	{
		ullGID = get_new_item_gid();
		char sTmpStr[1024];
		sprintf(sTmpStr, "ullGID=%lld, detail(%lld,%lld,%lld,%lld,%lld),cursystime=%d",
			ullGID,
			(ullGID >> 56) & 0x00000000000000FF,
			(ullGID >> 52) & 0x000000000000000F,
			(ullGID >> 48) & 0x000000000000000F,
			(ullGID >> 32) & 0x000000000000FFFF,
			ullGID & 0x00000000FFFFFFFF, (int)time(NULL));
		system_msg_to_role(pstRole, sTmpStr);
		log_info(LOG_ERR, sTmpStr);
		return 0;
	}
	CSITEMID stItemID;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chBagIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chItemIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	LPZONEITEM pstZoneItem = get_zoneitem(pstRole, &stItemID);
	if(NULL == pstZoneItem)
	{
		log_info(LOG_ERR, "%s: this pos have no item.", __FUNCTION__);
		return -1;
	}	
	if(iCmdID == 1) // 1=打印一下指定位置物品的GID
	{		
		char sTmpStr[1024];
		sprintf(sTmpStr, "gid=%"PRIu64" with resid=%d and restype=%d and ITEMID(type=%d,bagindex=%d,itemindex=%d,num=%d)", 
			pstZoneItem->ullGID,
			pstZoneItem->iResId,
			pstZoneItem->chResType,
			stItemID.chType,
			stItemID.chBagIndex,
			stItemID.chItemIndex,
			pstZoneItem->chNumber);
		system_msg_to_role(pstRole, sTmpStr);
		log_info(LOG_ERR, sTmpStr);
	}
	else if (iCmdID == 2)  // 2=为指定位置的物品重新分配新的GID
	{
		ullGID = pstZoneItem->ullGID;
		pstZoneItem->ullGID = get_new_item_gid();
		char sTmpStr[1024];
		sprintf(sTmpStr, " gid from %llu to %"PRIu64" with resid=%d and restype=%d and ITEMID(type=%d,bagindex=%d,itemindex=%d,num=%d)", 
			ullGID,
			pstZoneItem->ullGID,
			pstZoneItem->iResId,
			pstZoneItem->chResType,
			stItemID.chType,
			stItemID.chBagIndex,
			stItemID.chItemIndex,
			pstZoneItem->chNumber);
		system_msg_to_role(pstRole, sTmpStr);
		log_info(LOG_ERR, sTmpStr);
	}
	else if (iCmdID == 3)  // 3=用传入的GID参数作为指定位置的物品的GID 
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			ullGID = strtoull(szTmp, NULL, 10);
		}
		else
		{
			return -1;
		}
		unsigned long long ullTmpGID = pstZoneItem->ullGID;
		pstZoneItem->ullGID = ullGID;
		char sTmpStr[1024];
		sprintf(sTmpStr, "gid from %lld to %"PRIu64" with resid=%d and restype=%d and ITEMID(type=%d,bagindex=%d,itemindex=%d,num=%d)", 
			ullTmpGID,
			pstZoneItem->ullGID,
			pstZoneItem->iResId,
			pstZoneItem->chResType,
			stItemID.chType,
			stItemID.chBagIndex,
			stItemID.chItemIndex,
			pstZoneItem->chNumber);
		system_msg_to_role(pstRole, sTmpStr);
		log_info(LOG_ERR, sTmpStr);
	}
	else
	{
		return -1;
	}
	

	return 0;

}

int gm_finish_pworld(LPROLE pstRole, const char *pszArg)
{

	RESMONSTER stMonster;

	stMonster.chIsTriggerPworldEnd = 1;
	check_pworld_finished(pstRole,&stMonster);
	return 0;

}

int gm_smash(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	char chArg;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}

	return pstRole->chSmash = chArg;
}

int gm_strong(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	char chArg;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}

	return pstRole->chStrong = chArg;
}
int gm_hide(LPROLE pstRole, const char *pszArg)
{ //多发退出视野消息没什么，为了保证清晰，退出视野发消息的时候，不检查是否曾经发过进入视野消息
	char szTmp[128];
	char chArg;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	if(is_role_at_pworld(pstRole))
	{
		system_msg_to_role(pstRole, "副本中不能操作。");
		return -1; //副本中不让操作
	}

	int iRet = 0;
	chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}
	char chOldGmHide = pstRole->chGmHide;	
	pstRole->chGmHide = chArg;

	//force_set_role_pet_stat_no_act(pstRole); //方便处理，不能带宠物
	char chCurrPetIndex = get_current_active_pet(pstRole);
	if (-1 != chCurrPetIndex)
	{
		set_role_pet_stat(pstRole, chCurrPetIndex, ROLE_PET_STAT_NO_ACT);
	}

	//一下流程，都走一下改变地图的逻辑，(借助流程，不发视野)
	int iHideChange = TRUE;
	int iFuncFlag = 0;
	char chIsChange = 0;
	if(1 == chOldGmHide && 0 == pstRole->chGmHide)
	{ //从隐身变成不隐身
		chIsChange = 1;
		iHideChange = FALSE;
	}
	else if(0 == chOldGmHide && 1 == pstRole->chGmHide)
	{ //从不隐身变成隐身
		chIsChange = 1;
		iHideChange = TRUE;
	}	
	if(1 == chIsChange)
	{
		LPMAPINST pstMapInstDst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
		POSITION stPosDst;
		stPosDst.x  = pstRole->stObject.stPos.x + 1; //object_change_map内部如果坐标没变，不变更，稍微动一点
		stPosDst.y  = pstRole->stObject.stPos.y;
		iRet = object_change_map(&pstRole->stObject, pstMapInstDst, &stPosDst,NULL);
		if (0 != iRet)
		{
			return iRet;
		}
		else
		{
			send_sys_notice_msg(pstRole, NULL, CS_CODE_GM_HIDE, &iFuncFlag, &iHideChange, NULL,NULL);
		}
	}

	return 0;
}

/*
=====表现：
进入附身状态，就可以去以该玩家的视角看到他的视野、
信息包括：主角属性、身上装备
背包
仓库
宠物
好友
家族
技能
=====说明：
1，附身命令只能对当前在线，与使用命令的GM登录在同一个zone的玩家有效。
2，需要进入附身状态、取消附身状态，两个命令。
3，取消附身状态，就回到本人视野
4，附身状态是一次性的，只在当前登陆的时候有效
*/
int send_role_game_data(LPROLE pstRole, LPROLE pstTargetRole)
{

	//CLIENT根据状态，限制一下操作，由于GM是自己人，所以Srv就不用限制行为了 - 先发标记，以便Client可以方便处理下面的消息
	CSMISCS stMiscS;
	stMiscS.chReq = CS_MISC_REQ_PROC_ATTR;
	stMiscS.nEno = CS_CODE_NOERR;
	LPCSOBJPROCATTR pstObjProcAttr = &stMiscS.stData.stObjProcAttr;	
	pstObjProcAttr->ulObjectID = 0;
	pstObjProcAttr->nTotal = 0 ;
	pstObjProcAttr->astAttr[pstObjProcAttr->nTotal].nAttr = CS_PROC_ATTR_ROLE_FOLLOW; 
	pstObjProcAttr->astAttr[pstObjProcAttr->nTotal].iValue = pstTargetRole->ulUin;
	pstObjProcAttr->nTotal++;
	reply_server_pkg(pstRole->ulUin, CS_CMD_MISC, &stMiscS);


	ROLEINDB stRoleData;
	memset(&stRoleData,0,sizeof(stRoleData));
	pack_role_info(&stRoleData, pstTargetRole);

	LPFN_ROLE_LOGIN_INIT_DATA pFn = get_role_login_init_data();
	if(NULL== pFn)
		return -1;

	ROLE stRole;
	memcpy(&stRole, pstTargetRole, sizeof(ROLE)); //不能改变pstRole本身的值
	stRole.ulUin = pstRole->ulUin; //只有Uin是不变的，因为是要发消息的
	
	if( 0 != pFn(&stRole, &stRoleData))
	{
		return -1;
	}

	return 0;
}

int gm_follow(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	//if(is_role_at_pworld(pstRole))
	//{
	//	system_msg_to_role(pstRole, "副本中不能操作。");
	//	return -1; //副本中不让操作
	//}
	LPPLAYER pstPlayer = uin_to_player(pstRole->ulUin);
	if (NULL == pstPlayer)
	{
		return -1;
	}

	unsigned int ulUin = 0;
	if (szTmp[0])
	{
		ulUin = atoll(szTmp);
	}

	if(1 == ulUin) //查看一下附身谁
	{
		sprintf(szTmp, "你当前正在附身Uin[%u]。" , pstPlayer->ulFollowUin);
		system_msg_to_role(pstRole, szTmp);
		return 0;
	}
	
	if(pstPlayer->chFollowFlag == FOLLOW_TYPE_NONE) //还没附过身
	{
		if(0 == ulUin) 
		{
			system_msg_to_role(pstRole, "并没有附任何角色身，无需取消。");
			return -1;
		}  //else 正常附身逻辑

		if(ulUin == pstRole->ulUin) 
		{
			system_msg_to_role(pstRole, "为啥要附自己的身，没意义。");
			return -1;
		}
		
		LPPLAYER pstTargetPlayer = uin_to_player(ulUin);
		LPROLE pstTargetRole = NULL;
		if (pstTargetPlayer)
		{
			pstTargetRole = player_to_role(pstTargetPlayer);
		}
		if(pstTargetRole == NULL)
		{			
			system_msg_to_role(pstRole, "目标不在线或者不是在本Zone登陆。");
			return -1;
		}
		if(pstTargetPlayer->chFollowFlag == FOLLOW_TYPE_NORMAL_ROLE) 
		{
			sprintf(szTmp, "Uin[%u] 正在被GM Uin[%u]附身中，不能重复附身。" , 
				pstTargetRole->ulUin, pstTargetPlayer->ulFollowUin);
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		else if (pstTargetPlayer->chFollowFlag == FOLLOW_TYPE_GM_ROLE)
		{
			sprintf(szTmp, "Uin[%u] 是GM，他正在附Uin[%u]的身。" , 
				pstTargetRole->ulUin, pstTargetPlayer->ulFollowUin);
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		
		//实现思路: 当前角色定身，禁止除GM外的一切操作
		//		  拼装和发送被附身角色的数据给GM 
		//	所有被附身的SERVER响应协议，都要拷贝一份给附身的GM
		//	被附身的角色移动请求协议，转发给主角色一份	
		//   最后绑定双方的关系
		if(0 != send_role_game_data(pstRole, pstTargetRole))
		{
			return -1;
		}

		//最后再赋值关系，以防止过程中根据这个关系发送过数据包
		pstPlayer->chFollowFlag = FOLLOW_TYPE_GM_ROLE; 
		pstPlayer->ulFollowUin = pstTargetRole->ulUin; 
		pstRole->chStrong = 2; //全无敌+隐身
		pstRole->chGmHide = 1; 
		
		pstTargetPlayer->chFollowFlag = FOLLOW_TYPE_NORMAL_ROLE;
		pstTargetPlayer->ulFollowUin = pstRole->ulUin; 

		log_info(LOG_INFO, "%s : uin[%u] gm_follow [%u].", __FUNCTION__,
				pstRole->ulUin, pstTargetRole->ulUin);
		
	}
	else if(pstPlayer->chFollowFlag == FOLLOW_TYPE_GM_ROLE) //正在附另外一个角色的身
	{
		if(0 != ulUin) 
		{
			sprintf(szTmp, "正在附角色Uin[%u]的身，请先取消。" , pstPlayer->ulFollowUin);
			system_msg_to_role(pstRole, szTmp);
			return -1;
		} //else 取消附身逻辑

		LPPLAYER pstTargetPlayer = uin_to_player(pstPlayer->ulFollowUin);
		if(pstTargetPlayer != NULL)
		{
			pstTargetPlayer->chFollowFlag = FOLLOW_TYPE_NONE; //取消掉附身关系			
		}
		pstPlayer->chFollowFlag = FOLLOW_TYPE_NONE; //自己的也取消
		
		//为了简化处理，直接解除绑定附身关系后，强制下线，等待下次登录
		LPSYSENV  pstEnv = get_sys_env();
		LPPLAYER pstPlayer = uin_to_player(pstRole->ulUin);
		if(NULL == pstEnv || NULL == pstPlayer)
		{
			return -1;
		}		
		LPFN_DEAL_STOP_PKG pfnStopPkg = get_deal_stop_pkg();
		if(pfnStopPkg == NULL)
		{
			return -1;
		}	
		pfnStopPkg(pstPlayer, ENM_LOGOUT_REASON_NORMAL,__FUNCTION__); 	
	}
	else if(pstPlayer->chFollowFlag == FOLLOW_TYPE_NORMAL_ROLE) //被被人附身
	{ //GM之间的附身，可以直接提示，没有风险
		sprintf(szTmp, "你当前被Uin[%u]附身,请联系他取消。" , pstPlayer->ulFollowUin);
		system_msg_to_role(pstRole, szTmp);
		return -1;
	}
	
	return 0;
}

int gm_suite(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	
#if 0
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	char chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}

	if (chArg)
	{
		pstRole->chGmAuxFlag |= GM_AUX_FLAG_3_PHASE;
		snprintf(szTmp, sizeof(szTmp)-1, "您已切换为套路模式\n");
	}
	else
	{
		pstRole->chGmAuxFlag &= ~GM_AUX_FLAG_3_PHASE;
		snprintf(szTmp, sizeof(szTmp)-1, "您已切换为兼容模式\n");
	}
#endif

	snprintf(szTmp, sizeof(szTmp)-1, "技能系统已经正式切换到套路模式，不再支持兼容模式。");
	system_msg_to_role(pstRole, szTmp);
	return 0;
}

int gm_cd(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	char chArg;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if(!strncasecmp(szTmp, "reset", sizeof("reset"))) //清空角色的CD
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		unsigned int ulUin = atoll(szTmp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "no target role");
			return -1;
		}
		memset(pstTargetRole->astCooldown, 0, sizeof(COOLDOWN)*CS_MAX_ROLE_COOLDOWN); //暂时不用通知Client，重新登陆即可
		return 0;
	}

	chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}
	memset(pstRole->astCooldown, 0, sizeof(COOLDOWN)*CS_MAX_ROLE_COOLDOWN); //清空掉已经存在的CD

	LPPET pstPet = get_pet_by_role(pstRole);
	LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(NULL != pstPet && NULL != pstZonePetItem)
	{
		memset(pstZonePetItem->astCooldown, 0, sizeof(COOLDOWN)*CS_MAX_PET_COOLDOWN); 
	}	

	return pstRole->chCD = chArg;
}

int gm_team(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	CSTEAMC stTeamOp;
	if(!strncasecmp(szTmp, "publish", sizeof("publish")))
	{	
		stTeamOp.chOperation = CS_TEAM_PUBLISH_TEAM_CALLIN_INFO;
		stTeamOp.stData.stPlatformInfo.nTargetID = 1001;
		strcpy(stTeamOp.stData.stPlatformInfo.szDesc, "gm's");
		process_teamop_cmd(pstRole, &stTeamOp);
		return 0;
	}
	else if(!strncasecmp(szTmp, "cancel", sizeof("cancel")))
	{
		stTeamOp.chOperation = CS_TEAM_CANCEL_TEAM_CALLIN_INFO;
		process_teamop_cmd(pstRole, &stTeamOp);
		return 0;
	}
	else if(!strncasecmp(szTmp, "querymy", sizeof("querymy"))) 
	{	
		stTeamOp.chOperation = CS_TEAM_QUERY_MY_TEAM_CALLIN_INFO;
		process_teamop_cmd(pstRole, &stTeamOp);
		return 0;
	}
	else if(!strncasecmp(szTmp, "queryall", sizeof("queryall"))) 
	{	
		stTeamOp.chOperation = CS_TEAM_QUERY_TEAM_CALLIN_INFO;
		stTeamOp.stData.stCallInQueryReq.nTargetID = 0;
		stTeamOp.stData.stCallInQueryReq.nBeginPos = 0;
		process_teamop_cmd(pstRole, &stTeamOp);
		return 0;
	}
	else if(!strncasecmp(szTmp, "querybrief", sizeof("querybrief")))
	{
		LPZONETEAM pstTeam = get_role_team(pstRole);
		if(NULL != pstTeam)
		{
			stTeamOp.chOperation = CS_TEAM_QUERY_TEAM_BRIEF_INFO;
			stTeamOp.stData.stBriefQueryReq.chType = TEAM_CALLIN_PUBLISHER_TYPE_TEAM;			
			stTeamOp.stData.stBriefQueryReq.ullGID = pstTeam->stIndex.ullGID;
			process_teamop_cmd(pstRole, &stTeamOp);
		}
		return 0;
	}
	else if(!strncasecmp(szTmp,"teamjoin",sizeof("teamjoin")))
	{

		// teamjoin  system join player Uina Uinb to one team.
		gm_get_val(&pszArg,szTmp,sizeof(szTmp));
		if(!szTmp[0])
		{		
			system_msg_to_role(pstRole, "Usage:team teamjoin <actid>");
			return -1;
		}
		unsigned int actid = atol(szTmp);
		
		auto_team_join_req(pstRole,actid,0);
		return 0;
		
	}
	else if(!strncasecmp(szTmp,"autoteam", sizeof("autoteam")))
	{
		gm_get_val(&pszArg,szTmp,sizeof(szTmp));
		if(!szTmp[0])
		{		
			system_msg_to_role(pstRole, "Usage:team autoteam");
			return -1;
		}
		if(!strncasecmp(szTmp,"single",sizeof("single")))
		{
			gm_get_val(&pszArg,szTmp,sizeof(szTmp));
			if(!szTmp[0])
			{		
				system_msg_to_role(pstRole, "Usage:team autoteam");
				return -1;
			}
			dump_auto_single_list(atoi(szTmp));
		}	
		else
		{

			gm_get_val(&pszArg,szTmp,sizeof(szTmp));
			if(!szTmp[0])
			{		
				system_msg_to_role(pstRole, "Usage:team autoteam");
				return -1;
			}
	
			dump_auto_team_list(atoi(szTmp));

		}		
		return 0;
	
	}
	else
	{
		system_msg_to_role(pstRole, "//team  publish/cancel/querymy/querybrief/queryall.");
	}
	
	return -1;

}


int gm_assisdata(LPROLE pstRole, const char * pszArg)
{
	char szTmp[128];
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if(!strncasecmp(szTmp, "query", sizeof("query")))
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		char type  = atoi(szTmp);
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		int iValue  = atoi(szTmp);
		CSGETSERVERASSISDATA stData;
		stData.chType = type;
		stData.iKey = iValue;
		return query_server_assis_data(pstRole, &stData);
	}
	else
	{
		return -1;
	}

	return 0;
}
int gm_systimectrl(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (0 == strlen(szTmp))
	{
		system_msg_to_role(pstRole, "systimectrl $systemtype show/nextok/reset");
		return -1;
	}
	char chSystemType = atoi(szTmp);
	LPSYSTIMECTRLOUTPUT pstCtrl = get_systime_ctrl_mem_head(chSystemType);
	if(NULL == pstCtrl)
	{
		system_msg_to_role(pstRole, "no systimectrl data.");
		return -1;
	}
	
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	char sTmpBuff[512];
	int i = 0;
	if(!strncasecmp(szTmp, "show", sizeof("show"))) //查看当前的产出日程
	{
		sprintf(sTmpBuff, "TotalNum=%d,LeftNum=%d,NextBeginRandTime=%s", 
			pstCtrl->iCurTotalNum,pstCtrl->iLeftNum,
			ctime((time_t*)&pstCtrl->iNextBeginRandTime));
		sTmpBuff[strlen(sTmpBuff)-1] = 0; //去掉最后的回车符
		system_msg_to_role(pstRole, sTmpBuff);
		for(i = pstCtrl->iLeftNum-1; i >=0; i--)
		{
			sprintf(sTmpBuff, "outputtime[%d]=%s", i, ctime((time_t*)&pstCtrl->timeList[i]));
			sTmpBuff[strlen(sTmpBuff)-1] = 0; //去掉最后的回车符
			system_msg_to_role(pstRole, sTmpBuff);
		}
	}
	else if(!strncasecmp(szTmp, "nextok", sizeof("nextok"))) //让下一个就可以命中
	{
		if(pstCtrl->iLeftNum > 0)
		{
			pstCtrl->timeList[pstCtrl->iLeftNum-1] = time(NULL)-1;
		}
		else
		{
			pstCtrl->iLeftNum = 1;
			pstCtrl->timeList[0] = time(NULL)-1;
		}
		save_systime_ctrl_data(); //回写回去
	}
	else if(!strncasecmp(szTmp, "reset", sizeof("reset"))) //让下一个就可以命中
	{		
		init_systime_ctrl_for_system(1, chSystemType);
	}
	else
	{
		system_msg_to_role(pstRole, "systimectrl $systemtype show/nextok/reset");
		return -1;
	}
	
	return 0;
	
}

int gm_xp2(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	char szBeginTime[128];
	char szHelp[2048];
	sprintf(szHelp, "usage: //xp2 $开始时间(14) $结束时间(14) $增加倍数(1倍，就是双倍经验) , \n for example:  //xp2 20090530150000  20090530170000 1\n"
		"	//xp2 setweekpresent $value(分钟)  - 只对本线生效，系统重启后也会失效\n"
		"	//xp2 resetme -重新赠送自己的周赠送双倍时间，几秒钟后赠送\n"
		"	//xp2 open $openhour(开启模式，-2只是查询，-1永久，0关闭，其他时间)\n"
		"	//xp2 add $usertime (分钟)\n"
		"	//xp2 info \n"
		);

	gm_get_val(&pszArg, szBeginTime, sizeof(szBeginTime));
	
	if(!strncasecmp(szBeginTime, "setweekpresent", sizeof("setweekpresent")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		int iMin = atoi(szTemp);
		return set_system_xp2_week_present_value(iMin);
	}
	else if(!strncasecmp(szBeginTime, "resetme", sizeof("resetme")))
	{
		pstRole->stRoleXP2Info.stRoleXP2.iSetSysTime = 0; //把时间修改后，下次tick即可生效
		return 0;
	}
	else if(!strncasecmp(szBeginTime, "open", sizeof("open")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		char chOpenHour = atoi(szTemp);
		return deal_misc_open_xp2time(pstRole, chOpenHour);
	}
	else if(!strncasecmp(szBeginTime, "add", sizeof("add")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		int iMin = atoi(szTemp);
		use_item_to_add_xp2time(pstRole, iMin);
		return 0;
	}
	else if(!strncasecmp(szBeginTime, "info", sizeof("info")))
	{
		sprintf(szTemp, "%s", ctime((time_t*)&pstRole->stRoleXP2Info.stRoleXP2.iOpenXP2Time)); //一个格式化串中只能有一个ctime
		sprintf(szHelp, "Role: chOpenHour=%d; iOpenXP2Time=[%d,%s], iSetSysTime=[%d,%s], iSysLeftTime=%d, iUserLeftTime=%d.",
			pstRole->stRoleXP2Info.stRoleXP2.chOpenHour, 
			pstRole->stRoleXP2Info.stRoleXP2.iOpenXP2Time, szTemp, 
			pstRole->stRoleXP2Info.stRoleXP2.iSetSysTime, ctime((time_t*)&(pstRole->stRoleXP2Info.stRoleXP2.iSetSysTime)), 
			pstRole->stRoleXP2Info.stRoleXP2.iSysLeftTime, 
			pstRole->stRoleXP2Info.stRoleXP2.iUserLeftTime);
		system_msg_to_role(pstRole, szHelp);

		LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_SYSTEM_XP_N);
		if(NULL == pstCommData)
		{//数据库还未返回数据
			return 0;
		}
		sprintf(szTemp, "%s", ctime((time_t*)&pstCommData->stSystimeXPN.iKillMonsterXP2BeginTime));
		sprintf(szHelp, "System: [%s, %s] : %d",szTemp, ctime((time_t*)&(pstCommData->stSystimeXPN.iKillMonsterXP2EndTime)), 
			pstCommData->stSystimeXPN.chKillMonsterXP2BuffLevel);
		system_msg_to_role(pstRole, szHelp);
		
		return 0;
	} //else 设置开始和结束时间	

	//20090530150000
	if (strlen(szBeginTime) != 14)
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	char szEndTime[128];	
	gm_get_val(&pszArg, szEndTime, sizeof(szEndTime));
	//20090530170000
	if (strlen(szEndTime) != 14)
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	char chLevel = atoi(szTemp);
	if(chLevel < 1)
	{
		system_msg_to_role(pstRole, "倍数错误");
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	//为了确保表格也已经配置了，这儿查一下表格中是否存在这个BUFF等级	
	if(NULL == find_specstat_def(get_killmonster_xp2_stat_id(), chLevel))
	{
		system_msg_to_role(pstRole, "倍数错误，不存在对应的BUFF配置");
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	if(0 != set_killmonster_xp2_time(szBeginTime, szEndTime, chLevel))
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	return 0;
}

int gm_item_attr(LPROLE pstRole, const char *pszArg) 
{
	if(NULL == pstRole)
	{
		return -1;
	}
	char szTmp[128];

	CSITEMID stItemID;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chBagIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chItemIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	
	LPZONEITEM pstZoneItem = get_zoneitem(pstRole, &stItemID);
	if(NULL == pstZoneItem)
	{
		log_info(LOG_ERR, "%s: this pos have no item.", __FUNCTION__);
		return -1;
	}

	int iAttrType = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iAttrType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	if(0 == iAttrType)
	{
		int iAttrValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iAttrValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}
		int iMax=-1;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iMax = atoi(szTmp);
		}

		
		LPRESARM pstArmDef = find_arm_def_by_zoneitem(pstZoneItem);
		if(NULL == pstArmDef)
		{			
			return -1;
		}
		//if(pstZoneItem->stItemAttr.stArmAttr.iMaxDurableDegree == -1)
		//{
		//	return -1;
		//}
		if(pstZoneItem->stItemAttr.stArmAttr.iMaxDurableDegree < iAttrValue)
		{
			return -1;
		}					
		
		if (iMax == -1)//不变
		{
			iMax = pstZoneItem->stItemAttr.stArmAttr.iMaxDurableDegree;
		}
		
		change_arm_durabledegree(pstRole, pstZoneItem, &stItemID, 
				iAttrValue - pstZoneItem->stItemAttr.stArmAttr.iCurDurableDegree, 
				iMax-pstZoneItem->stItemAttr.stArmAttr.iMaxDurableDegree, 0, NULL);
		update_roleitem(pstRole, &stItemID, pstZoneItem); //通知Client的，耐久度属性的变更
	}
	else if(1 == iAttrType)
	{
		char sTmpStr[1024];
		sprintf(sTmpStr, "durabledegree=%d, maxdurabledegree=%d",  pstZoneItem->stItemAttr.stArmAttr.iCurDurableDegree,
			pstZoneItem->stItemAttr.stArmAttr.iMaxDurableDegree);
		log_info(LOG_DEBUG, sTmpStr);
		system_msg_to_role(pstRole, sTmpStr);		
	}
	else if(2 == iAttrType)
	{	
		 gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		 if (!szTmp[0])
		 {
			sprintf(szTmp, "bukenengquta"); 
		 }
		 update_roleitem(pstRole,&stItemID, pstZoneItem);
	}
	else if (3== iAttrType)
	{
		int iLeftTime = 0;

		unsigned char* pbTimeType = NULL;
		int* piBeginTime = NULL;
		int* piDeadLine = NULL;
		int* piLeftTime = NULL;
		get_item_timer_attr_ptr(pstZoneItem, &pbTimeType,  &piBeginTime, &piDeadLine, &piLeftTime);
		if(NULL == pbTimeType)
		{
			sprintf(szTmp, "物品[%d]无计时属性", pstZoneItem->iResId); 
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		
		if(CS_ITEM_TIME_NOLIMIT_TYPE == *pbTimeType)
		{
			sprintf(szTmp, "无限时物品[%d]", pstZoneItem->iResId); 
		}		
		else if(0 != check_item_timer(pstZoneItem, &iLeftTime))
		{
			sprintf(szTmp, "物品[%d]已经过期", pstZoneItem->iResId); 
		}
		else
		{
			sprintf(szTmp, "物品[%d]剩余时间:%d秒", pstZoneItem->iResId, iLeftTime);
		}
		system_msg_to_role(pstRole, szTmp);

		int iAttrValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iAttrValue = atoi(szTmp);
            *piLeftTime = iAttrValue;
            update_roleitem(pstRole,&stItemID, pstZoneItem);
		}
        
	}
	else if(4 == iAttrType)
	{
		int iRefineNum = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iRefineNum = atoi(szTmp);
		}
		else
		{
			return -1;
		}

		if(iRefineNum < 0 || iRefineNum > MAX_REFINEBASE_TIMES)
		{
			sprintf(szTmp, "精炼次数只能在 0 - %d 之间", MAX_REFINEBASE_TIMES);
			system_msg_to_role(pstRole, szTmp);
			return 0;
		}
		if(stItemID.chType != CS_LISTTYPE_COMMITEM)
		{
			sprintf(szTmp, "修改精炼次数时，物品只能置于行囊或背包中");
			system_msg_to_role(pstRole, szTmp);
		}
		else
		{
			LPREFINEBASELIB pstRefineLib = find_refine_base_lib_by_refine_num(iRefineNum);
			RESARM *pstArmDef = find_arm_def_by_zoneitem(pstZoneItem);
			if(pstArmDef != NULL && pstRefineLib != NULL)
			{
				// 精练的物品必须是武器或者副手的大类
				if(pstArmDef->chCanRefineBase == 1)
				{
					pstZoneItem->stItemAttr.stArmAttr.chRefineNum = (char)iRefineNum;
					//change_arm_need_level_i(pstZoneItem,pstArmDef);
					change_arm_basevalue_i(pstZoneItem,0);
					//重算孔数
					if (((pstZoneItem->stItemAttr.stArmAttr.chHoleNum - pstArmDef->chHole) < pstRefineLib->chHoleAdded)
						&& (pstZoneItem->stItemAttr.stArmAttr.chHoleNum < CS_MAX_ARM_OWN_CARD))
					{
						pstZoneItem->stItemAttr.stArmAttr.chHoleNum = 
							min(pstZoneItem->stItemAttr.stArmAttr.chHoleNum + pstRefineLib->chHoleAdded, CS_MAX_ARM_OWN_CARD);
					}
					update_roleitem(pstRole,&stItemID, pstZoneItem);
					sprintf(szTmp, "精炼次数被修改为 [%d]",iRefineNum);
					system_msg_to_role(pstRole, szTmp);
				}
			}
		
		}
	}
	else if(5 == iAttrType)
	{
		int iHoleNum = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iHoleNum = atoi(szTmp);
		}
		else
		{
			return -1;
		}

		if(iHoleNum < 0 || iHoleNum > 3)
		{
			sprintf(szTmp, "装备最多有三个孔");
			system_msg_to_role(pstRole, szTmp);
			return 0;
		}
		if(stItemID.chType != CS_LISTTYPE_COMMITEM)
		{
			sprintf(szTmp, "修改精炼次数时，物品只能置于背包中");
			system_msg_to_role(pstRole, szTmp);
		}
		else
		{
			RESARM *pstArmDef = find_arm_def_by_zoneitem(pstZoneItem);
			if(pstArmDef != NULL)
			{
				pstZoneItem->stItemAttr.stArmAttr.chHoleNum = (char)iHoleNum;
				update_roleitem(pstRole,&stItemID, pstZoneItem);
				sprintf(szTmp, "孔数被被修改为 [%d]",iHoleNum);
				system_msg_to_role(pstRole, szTmp);
			}
		}
	}
	else if (6 == iAttrType)
	{
		int iCurValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iCurValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}
		LPRESITEM pstResItem = find_item_def_by_zoneitem(pstZoneItem);
		if(NULL == pstResItem || pstZoneItem->chResType != CS_RES_ITEM)
		{
			return -1;
		}
		
		if(iCurValue > pstResItem->iTotalRecvrValue)
		{
			iCurValue = pstResItem->iTotalRecvrValue;
		}
		
		pstZoneItem->stItemAttr.stItemBaseAttr.iCurRecvrValue = iCurValue;
		update_roleitem(pstRole,&stItemID, pstZoneItem);
		
		sprintf(szTmp, "物品[%d]属性当前值修改为:%d", pstZoneItem->iResId, iCurValue);
		system_msg_to_role(pstRole, szTmp);
	}	
	else if (7 == iAttrType)
	{
		int iCurValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iCurValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}

		if (!can_zoneitem_lock(pstZoneItem))
		{
			return -1;
		}

		if (is_zoneitem_c2c_locked(pstZoneItem))
		{
			return -1;
		}

		int *plUnlockTime = get_zoneitem_uncooltime(pstZoneItem);
		if (plUnlockTime == NULL)
		{
			return -1;
		}

		*plUnlockTime = _cur_tick_time() + iCurValue;

		update_roleitem(pstRole,&stItemID, pstZoneItem);
		
		sprintf(szTmp, "冷却截止时间改为%d秒后", iCurValue);
		system_msg_to_role(pstRole, szTmp);
	}
	else if (8 == iAttrType)
	{
		if(pstZoneItem->chResType != CS_RES_ARM)
		{
			return -1;
		}
		int iType = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iType = atoi(szTmp);
		}
		else
		{
			return -1;
		}
		return armop_recycle(pstRole,&stItemID, (iType==1)? CS_ARMOP_RECYCLE_TOKEN : CS_ARMOP_RECYCLE_STUFF);
		//dismantle_arm(pstRole,&stItemID, pstZoneItem);
	}
	else if (9 == iAttrType)
	{
		if(pstZoneItem->chResType != CS_RES_ARM)
		{
			return -1;
		}
		unsigned char bQuality = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			bQuality = atoi(szTmp);
		}
		else
		{
			sprintf(szTmp, "quality = %d", pstZoneItem->stItemAttr.stArmAttr.bQuality);
			system_msg_to_role(pstRole, szTmp);
			return 0;
		}
		RESARM *pstArmDef = find_arm_def_by_zoneitem(pstZoneItem);
		if(pstArmDef != NULL)
		{
			if (pstZoneItem->stItemAttr.stArmAttr.bQuality != RES_ARM_QUALITY_TYPE_NORM)
			{
				sprintf(szTmp, "目前只支持将普通装备改成更优的!");
				system_msg_to_role(pstRole, szTmp);
				return -1;
			}
			pstZoneItem->stItemAttr.stArmAttr.bQuality = bQuality;
			if (arm_quality_improve(&pstZoneItem->stItemAttr.stArmAttr, bQuality) != 0)
			{
				sprintf(szTmp, "未知品质:%d", bQuality);
				system_msg_to_role(pstRole, szTmp);
				return -1;
			}

			//需要将品质对基础属性的修正存到后台数据区内，否则精炼会在原有基础属性上计算
			get_zonearm_baseattr(&pstZoneItem->stItemAttr.stArmAttr, &pstZoneItem->stZoneItemAttr.stArmAttr);

			update_roleitem(pstRole,&stItemID, pstZoneItem);
		}
	}	
	else if (10 == iAttrType)
	{
		if(pstZoneItem->chResType != CS_RES_ARM)
		{
			sprintf(szTmp, "arm must");
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		unsigned char bName = 0;
		unsigned short  wValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			bName = atoi(szTmp);
		}
		else
		{
			sprintf(szTmp, "please input both name and value. eg. //itemattr 1 0 0 10 2 12");
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			wValue = atoi(szTmp);
		}
		else
		{
			sprintf(szTmp, "please input both name and value. eg. //itemattr 1 0 0 10 2 12");
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		pstZoneItem->stItemAttr.stArmAttr.chMannaAttrNum = 1;
		pstZoneItem->stItemAttr.stArmAttr.astMannaAttrList[0].chAttrName = bName;
		pstZoneItem->stItemAttr.stArmAttr.astMannaAttrList[0].chRevisedType = ATTR_REVTYPE_ADDEX;
		pstZoneItem->stItemAttr.stArmAttr.astMannaAttrList[0].wValue = wValue;
		
		sprintf(szTmp, "added MannaAttr name %d, value %d", bName, wValue);
		system_msg_to_role(pstRole, szTmp);
		update_roleitem(pstRole,&stItemID, pstZoneItem);
	}
	else if (11 == iAttrType)
	{
		if(pstZoneItem->chResType != CS_RES_ARM)
		{
			sprintf(szTmp, "arm must");
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}
		int iArmID = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iArmID = atoi(szTmp);
		}
		else
		{
			sprintf(szTmp, "please input arm ID being updated to. eg. //itemattr 1 0 0 10 2 12");
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}

		CSARMUPGRADE stArmUpGrade;
		stArmUpGrade.stArmPos = stItemID;
		stArmUpGrade.iUpdateArmID = iArmID;
		return armop_upgrade(pstRole, &stArmUpGrade);
	}
	else if (12 == iAttrType)
	{
		if (CS_RES_ARM  != pstZoneItem->chResType)
		{
			system_msg_to_role(pstRole, "Dest Item is not Arm!");
			return -1;
		}
		int iBlessOne = 0;
		int iBlessTwo = 0;
		int iBlessThree = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iBlessOne = atoi(szTmp);
		}
		else
		{
			system_msg_to_role(pstRole, "eg. //itemattr 1 0 1 8 12 16");
			return -1;
		}
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iBlessTwo = atoi(szTmp);
		}
		else
		{
			system_msg_to_role(pstRole, "eg. //itemattr 1 0 1 8 12 16");
			return -1;
		}
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iBlessThree = atoi(szTmp);
		}
		else
		{
			system_msg_to_role(pstRole, "eg. //itemattr 1 0 1 8 12 16");
			return -1;
		}
		pstZoneItem->stItemAttr.stArmAttr.bBlessNum = 3;
		pstZoneItem->stItemAttr.stArmAttr.blessPoint[0] = iBlessOne;
		pstZoneItem->stItemAttr.stArmAttr.blessPoint[1] = iBlessTwo;
		pstZoneItem->stItemAttr.stArmAttr.blessPoint[2] = iBlessThree;
		update_roleitem(pstRole, &stItemID, pstZoneItem);
	}
	else if (13 == iAttrType)
	{
		int iCurValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iCurValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}

		int *plForceUnlockTime = get_zoneitem_force_uncooltime(pstZoneItem);
		if (plForceUnlockTime == NULL)
		{
			return -1;
		}

		*plForceUnlockTime = _cur_tick_time() + iCurValue;
		
		
		update_roleitem(pstRole,&stItemID, pstZoneItem);
		
		sprintf(szTmp, "强制冷却截止时间改为%d秒后", iCurValue);
		
		system_msg_to_role(pstRole, szTmp);
	}
	else if (14 == iAttrType)
	{
		sprintf(szTmp, "宠物装备耐久当前值:%d.", pstZoneItem->stItemAttr.stItemBaseAttr.iCurRecvrValue);
		system_msg_to_role(pstRole, szTmp);
	}
	else if (15 == iAttrType)
	{
		int iChgValue = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iChgValue = atoi(szTmp);
		}
		else
		{
			return -1;
		}

		pstZoneItem->stItemAttr.stItemBaseAttr.iCurRecvrValue += iChgValue;
		if (0 > pstZoneItem->stItemAttr.stItemBaseAttr.iCurRecvrValue)
		{
			pstZoneItem->stItemAttr.stItemBaseAttr.iCurRecvrValue = 0;
		}

		update_roleitem(pstRole,&stItemID, pstZoneItem);
	}
	else if (16 == iAttrType)
	{
		int iPetArmCoeff = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])  iPetArmCoeff = atoi(szTmp);
		else           return -1;

		if (iPetArmCoeff <= 0)  return -1;

		char chCoeff140 = iPetArmCoeff / 100;
		char chCoeff130 = iPetArmCoeff % 100 / 10;
		char chCoeff120 = iPetArmCoeff % 10;

		if (chCoeff140 + chCoeff130 + chCoeff120 > CS_PET_ARM_STRENG_MAX_TIMES)
		{
			sprintf(szTmp, "140:%d, 130:%d, 120:%d", chCoeff140, chCoeff130, chCoeff120);
			system_msg_to_role(pstRole, szTmp);
			return -1;
		}

		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.chNum = 0;
		if (chCoeff140 > 0)
			++pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.chNum;
		if (chCoeff130 > 0)
			++pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.chNum;
		if (chCoeff120 > 0)
			++pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.chNum;

		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[0].chCoefTimes = chCoeff140;
		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[0].chCoefType = 3;
		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[1].chCoefTimes = chCoeff130;
		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[1].chCoefType = 2;
		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[2].chCoefTimes = chCoeff120;
		pstZoneItem->stItemAttr.stItemBaseAttr.stMiscAttr.stPetArmAttr.astCoefTimes[2].chCoefType = 1;

		update_roleitem(pstRole,&stItemID, pstZoneItem);
	}
	
	return 0;
}

int gm_itemunlocktime(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}
	char szTmp[128];
	char szGMMsgTemp[128];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole  != NULL)
	{
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
			pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szGMMsgTemp);
	}
	else
	{
		pstDestRole = pstRole;
	}

	CSITEMID stItemID;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chBagIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stItemID.chItemIndex = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	
	LPZONEITEM pstZoneItem = get_zoneitem(pstDestRole, &stItemID);
	if(NULL == pstZoneItem)
	{
		log_info(LOG_ERR, "%s: this pos have no item.", __FUNCTION__);
		return -1;
	}
	
	int iCurValue = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iCurValue = atoi(szTmp);
	}
	else
	{
		return -1;
	}

	if (!can_zoneitem_lock(pstZoneItem))
	{
		return -1;
	}

	//C2C锁定和永久锁定公用一个字段,所以两者存在互斥关系
	if (is_zoneitem_c2c_locked(pstZoneItem))
	{
		return -1;
	}
	
	int *plUnlockTime = get_zoneitem_uncooltime(pstZoneItem);
	if (plUnlockTime == NULL)
	{
		return -1;
	}
	
	*plUnlockTime = _cur_tick_time() + iCurValue;

	update_roleitem(pstDestRole,&stItemID, pstZoneItem);
	
	sprintf(szTmp, "冷却时间改为%d秒后", iCurValue);
	system_msg_to_role(pstRole, szTmp);
	return 0;
}

int gm_ride(LPROLE pstRole, const char *pszArg) 
{
	if(NULL == pstRole)
	{
		return -1;
	}
	char szTmp[128];

	CSLISTRIDE stRide;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		stRide.chRideType = atoi(szTmp);
	}
	else
	{
		return -1;
	}

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0]) // 还有参数，继续取
	{
		stRide.stItemID.chType = atoi(szTmp);
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			stRide.stItemID.chBagIndex = atoi(szTmp);
		}
		else
		{
			return -1;
		}
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			stRide.stItemID.chItemIndex = atoi(szTmp);
		}
		else
		{
			return -1;
		}
	}
	else
	{
		stRide.stItemID.chType = CS_LISTTYPE_COMMITEM;
		stRide.stItemID.chItemIndex = 0;
	}

	int iRet = 0;
	char sTmpVar[1024];
	sTmpVar[0] = 0;
	if(stRide.chRideType == RIDE_TYPE_PREPARE || stRide.chRideType == RIDE_TYPE_BREAK_PREPARE 
		|| stRide.chRideType == RIDE_TYPE_DO || stRide.chRideType == RIDE_TYPE_UNDO)
	{
		if(RIDE_TYPE_PREPARE == stRide.chRideType)
		{
			sprintf(sTmpVar, "Prepare activate ride");
		}
		else if(RIDE_TYPE_BREAK_PREPARE == stRide.chRideType)
		{
			sprintf(sTmpVar, "break Prepare activate ride");
		}
		else if(RIDE_TYPE_DO == stRide.chRideType)
		{
			sprintf(sTmpVar, "Activate ride");
		}
		else
		{
			sprintf(sTmpVar, "Inactivate ride");
		}
		
		iRet = item_ride_cmd(pstRole, &stRide);		
		if(0 == iRet)
		{
			sprintf(sTmpVar, "%s successfully,", sTmpVar);
		}
		else
		{
			sprintf(sTmpVar, "%s failed, errcode=%d,", sTmpVar, iRet);
		}
		
	} // else 仅打印下速度	
	
	char sTmpStr[2048];
	sprintf(sTmpStr, "%s current stat is %d(0=riding), movespeed is %d.", 
		sTmpVar, is_commstat(pstRole, RES_COMMSTAT_DRIVE), get_role_movespeed(pstRole)); 
	
	system_msg_to_role(pstRole, sTmpStr);

	return iRet;
}

int gm_reloadscript(LPROLE pstRole, const char *pszArg)
{
	int iRet = 0;

	iRet = init_script_system_by_dir();

	return iRet;
}

int gm_actserial(LPROLE pstRole, const char *pszArg)
{
	int iID;
	char szTmp[128];

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iID = atoi(szTmp);
	}
	else
	{
		return -1;
	}

	act_serial_start(pstRole, iID);

	return 0;
}

int gm_pworld_event_var(LPROLE pstRole, const char *pszArg)
{
	char szInfo[512];
	char sTmpStr[512];
	int iVarID;
	int iVarValue;
	sTmpStr[0] = 0;
	
	if(NULL == pstRole || NULL == pszArg)
	{
	     return -1;
	}

	if(0 == is_role_at_pworld(pstRole))
	{
		 // 角色不在副本
		return -1;
	}
	LPPWORLDINST pstPworldInst = find_pworld_inst_by_index(&pstRole->stRolePworldInfo.stPworldInstIndex);
	if (NULL == pstPworldInst)
	{
		return -1;
	}
        gm_get_val(&pszArg,sTmpStr,sizeof(sTmpStr));             
        if(sTmpStr[0])
	{
		iVarID = atoi(sTmpStr);
        }
        else
	{
		return -1;
	}
				
        gm_get_val(&pszArg,sTmpStr,sizeof(sTmpStr));             
        if(sTmpStr[0])
	{
		iVarValue = atoi(sTmpStr);
		if(set_pworld_eventvar(pstPworldInst,iVarID,iVarValue) < 0 )
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Set : Var[%d] = %d\n", iVarID, pstPworldInst->astEventVar[iVarID]);
        }
        else
	{
		if(iVarID < 0 || iVarID >= CS_MAX_PWORLD_INST_EVENT_VAR)
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Query : Var[%d] = %d\n", iVarID, pstPworldInst->astEventVar[iVarID]);
	}
	return 0;
}

int gm_res_pworld_minigame(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}	
	char szTmp[128];
	char sTmpStr[512];
	sTmpStr[0] = 0;
	

	int iActID = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iActID = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	
	LPRESPWORLDMINIGAME pstResMinigame =  find_pworldminigame_by_actid(iActID);
	if (NULL == pstResMinigame)
	{
		sprintf(sTmpStr, "%s act [%d] not found.", sTmpStr, iActID); 
		system_msg_to_role(pstRole, sTmpStr);		
		return -1;
	}

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if(!strncasecmp(szTmp, "enterlimit", sizeof("enterlimit")))
	{
		int iEnterLimit = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (szTmp[0])
		{
			iEnterLimit = atoi(szTmp);
		}
		else
		{
			sprintf(sTmpStr, "%s act [%d] enter limit [%d].", sTmpStr, iActID, pstResMinigame->chEnterLimitTimes); 
			system_msg_to_role(pstRole, sTmpStr);		
			return 0;
		}
		int iLimitPre = pstResMinigame->chEnterLimitTimes;
		pstResMinigame->chEnterLimitTimes = iEnterLimit;
		sprintf(sTmpStr, "%s act [%d] enter limit change from [%d] to [%d].", sTmpStr, iActID, iLimitPre, pstResMinigame->chEnterLimitTimes); 
		system_msg_to_role(pstRole, sTmpStr);		
	}
	
	return 0;
}

int gm_res_attr(LPROLE pstRole, const char *pszArg) 
{
	if(NULL == pstRole)
	{
		return -1;
	}
	char szTmp[128];
	int iResId = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iResId = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	int iAttrType = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iAttrType = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	int iAttrValue1 = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iAttrValue1 = atoi(szTmp);
	}
	else
	{
		return -1;
	}
	int iAttrValue2 = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0])
	{
		iAttrValue2 = atoi(szTmp);
	}	
	
	if(IS_ARM_NONE != is_arm_of_resid(iResId))
	{
		LPRESARM pstArmDef = find_arm_def_by_resid(iResId);
		if(NULL == pstArmDef)
		{			
			return -1;
		}
		pstArmDef->bTimeType = iAttrValue1;
		pstArmDef->iTotalTime = iAttrValue2;
	}
	else if(is_pet_of_resid(iResId))
	{

	}
	else if(is_card_of_resid(iResId))
	{
	}
	else
	{
		LPRESITEM pstItemDef = find_item_def_by_resid(iResId);
		if(NULL == pstItemDef)
		{			
			return -1;
		}
		pstItemDef->bTimeType = iAttrValue1;
		pstItemDef->iTotalTime = iAttrValue2;
	}	

	return 0;

}



/*added by kevinfan*/
int gm_save_taunt(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
		return -1;
	ulRoleZID = pstRole->stObject.ulID;
	memset(g_astTaunt, 0 ,sizeof(g_astTaunt));
	return 0;
}
int gm_save_taunt_i(LPROLE pstRole, TAUNT astTunt[], int iTotalRole)
{
	if(NULL == pstRole || NULL == astTunt)
		return -1;

	int i = 0;
	for(; i < iTotalRole; ++i)
	{
		if(ulRoleZID == astTunt[i].ulID)
		{
			memset(g_astTaunt, 0 ,sizeof(g_astTaunt));
			memcpy(g_astTaunt, astTunt,iTotalRole*sizeof(g_astTaunt[0]));
			return 0;
		}
	}
		
	LPZONETEAM pstZoneTeam = get_role_team( pstRole);
	if(NULL != pstZoneTeam)
	{
		for(i = 0; i < pstZoneTeam->chCount; ++i)
		{
			if(ulRoleZID == pstZoneTeam->astMembers[i].ulObjectID)
			{
				memset(g_astTaunt, 0 ,sizeof(g_astTaunt));
				memcpy(g_astTaunt, astTunt,iTotalRole*sizeof(g_astTaunt[0]));
				break;
			}
		}
	}
	return 0;
}

int gm_disp_taunt(LPROLE pstRole ,  const char *pszArg)
{
	if(NULL == pstRole || ulRoleZID != pstRole->stObject.ulID)
		return -1;
	char szViewInfo[4096];
	int iCnt = 0;
	LPROLE pstTRole;
	LPPET pstPet;
	char chType;
	char szTmp[128];
	char szFileName[128];
	memset(szViewInfo, 0, sizeof(szViewInfo));
	while(g_astTaunt[iCnt].ulID)
	{
		chType = zid_to_type(g_astTaunt[iCnt].ulID);
		switch(chType)
		{
			case OBJ_ROLE:
				pstTRole = zid_to_role(g_astTaunt[iCnt].ulID);
				if(NULL == pstTRole)
					break;
				sprintf(szViewInfo+strlen(szViewInfo), " [Role( %s ) ", pstTRole->szName);
				break;
			case OBJ_PET:
				pstPet = zid_to_pet(g_astTaunt[iCnt].ulID);
				if(NULL == pstPet)
					break;
				pstTRole = get_role_by_pet(pstPet);
				if(NULL == pstTRole)
					break;
				sprintf(szViewInfo+strlen(szViewInfo), " [Pet ( %s ) ", pstTRole->szName);
				break;
			default:
				break;
		}

		sprintf(szViewInfo+strlen(szViewInfo), " Hurt ( %d ) ]\n", g_astTaunt[iCnt].iDamage);

		++iCnt;
		if(iCnt >= MONSTER_MAX_TAUNT)
			break;
	}

	sprintf(szViewInfo+strlen(szViewInfo), " All %d Objects\n" , iCnt);

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (szTmp[0]) 
	{
		strcpy(szFileName, szTmp);
		FILE* fp = fopen(szFileName, "w");
		if(NULL != fp)
		{
			fputs(szViewInfo, fp);
			fclose(fp);
		}
	}
	system_msg_to_role(pstRole, szViewInfo);
	return 0;
}

int gm_query_obj(LPROLE pstRole, const char *pszArg)
{
	if(pstRole == NULL)
	{
		return -1;
	}
	char szMsg[1024]={0};
	char szTemp[80];
	int iType = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole,"Usage:queryobj <objtype:role:0,item:1,monster:2,pet:3> [mapinstindex id]");	
		return 0;
	}
	else
	{
		 iType = atoi(szTemp);
	}
	int iIndexId = -1;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	unsigned long long ullMapInstID = 0;	
	int iObjNum = 0;
	if(szTemp[0])
	{
		iIndexId = atoi(szTemp);
		LPMAPINSTS pstMapInsts = get_map_insts();
		if(pstMapInsts == NULL)
		{
			system_msg_to_role(pstRole,"fail to get mapinsts.");
			return -1;
		}
		if(iIndexId >= pstMapInsts->iInst)
		{
			system_msg_to_role(pstRole,"wrong map inst index id.");
			return -1;
		}	
		ullMapInstID = pstMapInsts->astIndex[iIndexId].ullID;
		iObjNum = query_mapinst_obj_num(&pstMapInsts->astIndex[iIndexId],iType);	
	}
	else
	{		
		ullMapInstID = pstRole->stObject.stMapInstIndex.ullID;
		iObjNum = query_mapinst_obj_num(&pstRole->stObject.stMapInstIndex,iType);			
	}
	if(iObjNum < 0)
	{
		system_msg_to_role(pstRole,"fail to query obj num");			
	}
	else
	{
		snprintf(szMsg,sizeof(szMsg),"MAPID:%d query obj type:%d num:%d",MAP_INST_ID_TO_MAP_ID(ullMapInstID),iType,iObjNum);
		system_msg_to_role(pstRole,szMsg);
	}
	return 0;
}

int gm_clear_region_refresh(LPROLE pstRole, const char *pszArg)
{
	LPMAPINST      pstMapInst      = NULL;
	LPRESREGION    pstResRegion    = NULL;
	LPREGIONINST   pstRegionInst   = NULL;
	char szTemp[80];
	int iRegionID = -1;
	int i = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iRegionID = atoi(szTemp);
	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex); 
	if (NULL == pstMapInst)
	{
		return -1;
	}
	for(i=0; i<pstMapInst->iRegionInst; ++i)
	{
		pstRegionInst = get_region_inst_by_pos(pstMapInst->aiRegionInst[i]);
		if (NULL == pstRegionInst)
		{
			return -1;
		}
		pstResRegion = &pstRegionInst->stResRegion;
		if (NULL == pstResRegion)
		{
			return -1;
		}	
		if (iRegionID < 0 || iRegionID == pstResRegion->nRegionID)
		{
			pstRegionInst->nCurRefresh = 0;
		}
	}
	return 0;
}

int gm_clear_region_blowout_alived(LPROLE pstRole, const char *pszArg)
{
	LPMAPINST      pstMapInst      = NULL;
	LPRESREGION    pstResRegion    = NULL;
	LPREGIONINST   pstRegionInst   = NULL;
	char szTemp[80];
	int iRegionID = -1;
	int i = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0]) iRegionID = atoi(szTemp);
	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex); 
	if (NULL == pstMapInst)
	{
		return -1;
	}
	for(i=0; i<pstMapInst->iRegionInst; ++i)
	{
		pstRegionInst = get_region_inst_by_pos(pstMapInst->aiRegionInst[i]);
		if (NULL == pstRegionInst)
		{
			return -1;
		}
		pstResRegion = &pstRegionInst->stResRegion;
		if (NULL == pstResRegion)
		{
			return -1;
		}	
		if (iRegionID < 0 || iRegionID == pstResRegion->nRegionID
			|| pstResRegion->bRefreshType == RES_REGION_REFRESH_TYPE_BLOWOUT)
		{
			pstRegionInst->nCurAlive = 0;
		}
	}
	return 0;
}

int gm_add_role_log(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	unsigned int ulUin;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "addrolelog add uin");
			system_msg_to_role(pstRole, "addrolelog remove uin");
			return 0;
		}
		if(!strncasecmp(szTemp, "add", sizeof("add")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				return -1;
			}
			unsigned int alUin[1];
			alUin[0] = (unsigned int)atoll(szTemp);
			if(alUin[0] <= 0)
			{
				return -1;
			}
			set_chat_role_log(alUin[0], 1);
			return set_log_uin(1, alUin);
		}
		else if(!strncasecmp(szTemp, "remove", sizeof("remove")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				return -1;
			}
			ulUin = (unsigned int)atoll(szTemp);
			if(ulUin <= 0)
			{
				return -1;
			}
			set_chat_role_log(ulUin, 0);
			return del_log_uin(ulUin);
		}
		else if(!strncasecmp(szTemp, "moveinfo", sizeof("moveinfo")))
		{
		
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				return -1;
			}
		
			int iInfoTag = atoi(szTemp);
			if(iInfoTag != 0)
			{
				open_moveinfo(1);
				return 0;
			}
			
			open_moveinfo(0);
			return 0;
		}
	}
	else
	{
		return -1;
	}

	return -1;
}

int gm_logctrl(LPROLE pstRole,const char*pszArg) 
{
	//logctrl level levelstr
	//logctrl module moduleID value
	char szTemp[128];

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0] == 'l') //从简判断即可
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		if(szTemp[0])
		{
			return set_log_level_ctrl(szTemp);
		}
		else
		{
			return -1;
		}
		
	}
	else if (szTemp[0] == 'm') 
	{
		int iLogModule;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));		
		if(szTemp[0])
		{
			iLogModule = atoi(szTemp);
		}
		else
		{
			return -1;
		}
		
		int iValue;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0])
		{
			iValue = atoi(szTemp);
		}
		else
		{
			return -1;
		}
		return set_log_module_ctrl(iLogModule, iValue);
	}
	else
	{
		return -1;
	}
	
	return 0;
}

int gm_glory(LPROLE pstRole,const char*pszArg) 
{
	if(NULL == pstRole)
	{
		return -1;
	}

	/*提取操作对象*/
	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole  != NULL)
	{
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
			pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szGMMsgTemp);
	}
	else
	{
		pstDestRole = pstRole;
	}
	
	char szCmd[32];
	gm_get_val(&pszArg,szCmd,sizeof(szCmd));

	int iType = -1;
	int iParam1 = -1;
	char szCoef[32];
	gm_get_val(&pszArg,szCoef,sizeof(szCoef));	
	if(szCoef[0])
	{
		iType = atoi(szCoef);
	}

	gm_get_val(&pszArg,szCoef,sizeof(szCoef));	
	if(szCoef[0])
	{
		iParam1 = atoi(szCoef);
	}

	char szSysMsg[1024];
	szSysMsg[0] = 0;
	snprintf(szSysMsg,sizeof(szSysMsg),"====GM[%u %s] Op[%s]====\n",pstRole->ulUin,pstRole->szName,szCmd);
	if(!strncasecmp(szCmd, "dump", sizeof("dump")))
	{
		deump_glorylist(pstRole,iType);
	}
	else if(!strncasecmp(szCmd, "shift", sizeof("shift")))
	{
		deal_gm_glorylist_req(pstRole,iType,iParam1,0);
	}
	else if(!strncasecmp(szCmd, "gmshift", sizeof("gmshift")))
	{
		deal_gm_glorylist_req(pstRole,iType,iParam1,1);
	}
	else if(!strncasecmp(szCmd, "time", sizeof("time")))
	{
		deal_gm_query_glorytime_req(pstRole);
	}
	else if(!strncasecmp(szCmd, "del", sizeof("del")))
	{
		LPGLORYLIST pstGloryList = get_zoneglory_list(iType);
		if(pstGloryList == NULL)
		{
			system_msg_to_role(pstRole,"Invalid Type Input.");
			return -1;
		}

		if(iParam1 <= 0 || iParam1 > pstGloryList->wNum)
		{
			system_msg_to_role(pstRole,"Invalid Pos Input.");
			return -1;
		}

		snprintf(szSysMsg+ strlen(szSysMsg),sizeof(szSysMsg) - strlen(szSysMsg),"Glory[%d] Delete [%d: %s]\n",iType,iParam1,
			pstGloryList->astGloryOwner[iParam1 - 1].szName);
		
		LPGLORYOWNER pstGloryOwner = &pstGloryList->astGloryOwner[iParam1 - 1];
		del_glorylist_role(pstGloryOwner->ullGID, iType);
		
		snprintf(szSysMsg+ strlen(szSysMsg),sizeof(szSysMsg) - strlen(szSysMsg),"=========== Left [%d]=========\n",pstGloryList->wNum);
		system_msg_to_role(pstRole,szSysMsg);
		
	}
	else if(!strncasecmp(szCmd, "delall", sizeof("delall")))
	{
		LPGLORYLIST pstGloryList = get_zoneglory_list(iType);
		if(pstGloryList == NULL)
		{
			system_msg_to_role(pstRole,"Invalid Type Input.");
			return -1;
		}

		int iNum = pstGloryList->wNum;
		pstGloryList->wNum = 0;
		snprintf(szSysMsg+ strlen(szSysMsg),sizeof(szSysMsg) - strlen(szSysMsg),"Glory[%d] Clear [%d] Members\n",iType,iNum);
		snprintf(szSysMsg+ strlen(szSysMsg),sizeof(szSysMsg) - strlen(szSysMsg),"=========== Left [%d]=========\n",pstGloryList->wNum);
		system_msg_to_role(pstRole,szSysMsg);
		
	}
	else
	{
		system_msg_to_role(pstRole,"请参看，gm操作网页: http://172.25.42.76/gm.html");
	}

	return 0;
	
	
}

int gm_query_role_specstat(LPROLE pstRole,const char *pszArg)
{

	LPSPECSTATLIST pstList = &pstRole->stSpecStatList;
	char szSysMsg[1024];	
	time_t curtime = time(NULL);
	snprintf(szSysMsg,sizeof(szSysMsg),"Total poll specstat num:%d curtime:%s",pstList->bTotalPoll,ctime(&curtime));
	system_msg_to_role(pstRole,szSysMsg);	
	
	LPSPECSTAT pstSpecStat;
	LPRESSPECSTAT pstStatDef;
	int i = 0;
	for( ; i < pstList->bTotalPoll; i++)
	{
		pstSpecStat = pstList->astStat + i;
		pstStatDef = find_specstat_def(pstSpecStat->nID,pstSpecStat->nLevel);
		if(pstStatDef == NULL)
		{
			snprintf(szSysMsg,sizeof(szSysMsg),"fail to find stat def by id:level(%d:%d)",pstSpecStat->nID,pstSpecStat->nLevel);
			system_msg_to_role(pstRole,szSysMsg);
			continue;
		}	
		snprintf(szSysMsg,sizeof(szSysMsg),"stat id:%d level:%d pilecount:%d activecount:%d polltime:%d interval:%d countlimit:%d expiretime:%s",pstSpecStat->nID,pstSpecStat->nLevel,
			pstSpecStat->bPileCount,pstSpecStat->bActiveCount,pstSpecStat->wPollTime,pstStatDef->wInterval,pstStatDef->wCountLimit,ctime(&pstSpecStat->tExpd));	

		system_msg_to_role(pstRole,szSysMsg);
	}

	snprintf(szSysMsg,sizeof(szSysMsg),"Total last specstat num:%d",(int)(sizeof(pstList->astStat)/sizeof(pstList->astStat[0])) - pstList->bTailPos);
	system_msg_to_role(pstRole,szSysMsg);
	for(i= pstList->bTailPos; i < sizeof(pstList->astStat)/sizeof(pstList->astStat[0]); i++)
	{
		pstSpecStat = pstList->astStat + i;
		pstStatDef = find_specstat_def(pstSpecStat->nID,pstSpecStat->nLevel);
		if(pstStatDef == NULL)
		{
			snprintf(szSysMsg,sizeof(szSysMsg),"fail to find stat def by id:level(%d:%d)",pstSpecStat->nID,pstSpecStat->nLevel);
			system_msg_to_role(pstRole,szSysMsg);
			continue;
		}	
		snprintf(szSysMsg,sizeof(szSysMsg),"stat id:%d level:%d pilecount:%d activecount:%d polltime:%d interval:%d countlimit:%d expiretime:%s",pstSpecStat->nID,pstSpecStat->nLevel,
			pstSpecStat->bPileCount,pstSpecStat->bActiveCount,pstSpecStat->wPollTime,pstStatDef->wInterval,pstStatDef->wCountLimit,ctime(&pstSpecStat->tExpd));	

		system_msg_to_role(pstRole,szSysMsg);

	}
	return 0;
}

int gm_role_upgrade(LPROLE pstRole, const char*pszArg)
{

	char szUin[32];
	gm_get_val(&pszArg,szUin,sizeof(szUin));
	LPROLE pstUpgradeRole = NULL;
	if(!szUin[0])
	{
		pstUpgradeRole = pstRole;

	}
	else
	{
		pstUpgradeRole = uin_to_role(atoll(szUin));
	
	}
	if(pstUpgradeRole == NULL)
	{
		system_msg_to_role(pstRole,"获取的升级角色对象为空");	
		return -1;
	}

	if(role_manual_upgrade(pstRole) != 0)
	{
		system_msg_to_role(pstRole,"手动升级角色失败");
		return -1;
	}	
	
	system_msg_to_role(pstRole,"手动升级角色成功");
	return 0;
}

int gm_query_near(LPROLE pstRole,const char*pszArg)
{
	//CSNEARROLELIST stNearRoleList;
	CSTEAMRES stNearList;
	
	int iMonItem = 0;
	if(get_near_rolelist(pstRole,&stNearList, &iMonItem, CS_TEAM_QUERY_NEARLIST) < 0)
	{
		system_msg_to_role(pstRole, "fail to get near role list.");
		return -1;
	}
	
	char szSysMsg[1024];
	snprintf(szSysMsg,sizeof(szSysMsg),"===rolenum=%d, monsterAndItem=%d===",stNearList.stRoleNearList.chTotal, iMonItem);
	szSysMsg[1023]= 0;
	system_msg_to_role(pstRole,szSysMsg);

	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));	
	int iFlag = 0;
	if(szTemp[0])
	{
		iFlag = atoi(szTemp);
	}
	
	if(0 != iFlag)
	{
		int i =0;
		for( ; i < stNearList.stRoleNearList.chTotal; i++)
		{
			snprintf(szSysMsg, sizeof(szSysMsg), "RoleName:[%s] Prof[%d] Level :%d",stNearList.stRoleNearList.astRoleList[i].szName,stNearList.stRoleNearList.astRoleList[i].chProf,stNearList.stRoleNearList.astRoleList[i].nLevel);
			szSysMsg[1023] = 0;
			system_msg_to_role(pstRole, szSysMsg);
		}
	}
	return 0;
}


int gm_query_npclist(LPROLE pstRole, const char *pszArg)
{

	LPMAPINST pstMapInst = NULL;
	unsigned int aulObjectList[MAX_MAP_OBJECT];
	LPMONSTER pstMon = NULL;
	LPRESMONSTER pstMonDef= NULL;
	int i = 0;
	int iObjectSum = 0;
	char szSysMsg[1024];

	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if (NULL == pstMapInst)
	{
		return -1;
	}
	

	int iRet = get_map_object_list_by_type(&pstRole->stObject.stMapInstIndex, OBJ_MONSTER, 
		&iObjectSum, MAX_MAP_OBJECT, aulObjectList);
	if(iRet != 0)
	{
		return -1;
	}
	int iNpcNum = 0;
	for (i=0; i<iObjectSum; i++)
	{
		pstMon = zid_to_monster(aulObjectList[i]);
		if (NULL == pstMon)
		{
			continue;
		}
		pstMonDef = find_monster_def(pstMon->iID,&pstMon->iDefPos);
		if(NULL == pstMonDef)
		{
			continue;
		}
		if(pstMon->chType == CS_TYPE_NPC || pstMon->chType == CS_TYPE_DYNAMIC_NPC)
		{
		snprintf(szSysMsg, sizeof(szSysMsg), "MonName:[%s] Mon[%d] [X:Y]:[%d:%d] Status[%d] Pos[%d:%d] HP[%d]", 
			pstMonDef->szName, pstMon->iNPCResID, pstMon->stObject.stPos.x,pstMon->stObject.stPos.y, pstMon->chStatus, pstMon->stObject.stPos.x, pstMon->stObject.stPos.y, pstMon->iCurHP);
		szSysMsg[1023] = 0;
		system_msg_to_role(pstRole, szSysMsg);
		iNpcNum++;
		}
	}
		
	snprintf(szSysMsg, sizeof(szSysMsg), "query npc num %d", iNpcNum);
	szSysMsg[1023] = 0;
	system_msg_to_role(pstRole, szSysMsg);
	

	return 0;
}


int gm_query_monster(LPROLE pstRole, const char *pszArg)
{
	LPMAPINST pstMapInst = NULL;
	unsigned int aulObjectList[MAX_MAP_OBJECT];
	LPMONSTER pstMon = NULL;
	int i = 0;
	int iObjectSum = 0;
	char szSysMsg[1024];
	int iMonsterID = 0;
	int iPrintMonsterID = 0;

	gm_get_val(&pszArg,szSysMsg,sizeof(szSysMsg));
	iMonsterID = atoi(szSysMsg);

	pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if (NULL == pstMapInst)
	{
		return -1;
	}
	

	int iRet = get_map_object_list_by_type(&pstRole->stObject.stMapInstIndex, OBJ_MONSTER, 
		&iObjectSum, MAX_MAP_OBJECT, aulObjectList);
	if(iRet != 0)
	{
		return -1;
	}

	int iShowNum = 0;
	for (i=0; i<iObjectSum; i++)
	{
		pstMon = zid_to_monster(aulObjectList[i]);
		if (NULL == pstMon)
		{
			continue;
		}
		iPrintMonsterID = pstMon->iID;
		if(0 != iMonsterID)
		{
			if( CS_TYPE_NPC == pstMon->chType || CS_TYPE_DYNAMIC_NPC == pstMon->chType)
			{
				if(pstMon->iNPCResID != iMonsterID)
				{
					continue;
				}
				iPrintMonsterID = pstMon->iNPCResID;
			}
			else if(CS_TYPE_MONSTER  ==  pstMon->chType)
			{
				if(pstMon->iID != iMonsterID)
				{
					continue;
				}
			}
		}
		iShowNum++;
		snprintf(szSysMsg, sizeof(szSysMsg), "Mon[%d] Status[%d] Pos[%d:%d] HP[%d]", 
			iPrintMonsterID, pstMon->chStatus, pstMon->stObject.stPos.x, pstMon->stObject.stPos.y, pstMon->iCurHP);
		szSysMsg[1023] = 0;
		system_msg_to_role(pstRole, szSysMsg);
	}
		
	snprintf(szSysMsg, sizeof(szSysMsg), "Total num: %d", iShowNum);
	szSysMsg[1023] = 0;
	system_msg_to_role(pstRole, szSysMsg);
	

	return 0;
}

int gm_statusvar(LPROLE pstRole, const char *pszArg)
{
	char szTemp[32];
	int iVarID;
	int iVarValue;
	char szInfo[200];
	
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	//if(0 == is_role_at_pworld(pstRole))
	//{
		// 角色不在副本
	//	return -1;
	//}

	LPMAPINST pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if(pstMapInst == NULL)
	{
		return -1;
	}
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));		
	if(szTemp[0])
	{
		iVarID = atoi(szTemp);
	}
	else
	{
		return -1;
	}
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));		
	if(szTemp[0])
	{
		//set
		iVarValue = atoi(szTemp);
		if(set_pworld_map_statusvar(pstMapInst,iVarID,iVarValue) < 0 )
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Set : Var[%d] = %d\n", iVarID,pstMapInst->stStatusVar.awStatusVarList[iVarID]);
	}
	else
	{
		//Query
		if(iVarID < 0 || iVarID >= CS_MAX_MAP_INST_STATUS_VAR)
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Query : Var[%d] = %d\n", iVarID,pstMapInst->stStatusVar.awStatusVarList[iVarID]);
	}

	system_msg_to_role(pstRole, szInfo);
	return 0;
}


int gm_statusmode(LPROLE pstRole, const char *pszArg)
{
	char szTemp[32];
	int iModeID;
	char szInfo[200];
	
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	if(0 == is_role_at_pworld(pstRole))
	{
		// 角色不在副本
		return -1;
	}

	LPMAPINST pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);
	if(pstMapInst == NULL)
	{
		return -1;
	}
	

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));		
	if(szTemp[0])
	{
		//set
		iModeID = atoi(szTemp);
		if(begin_pworld_map_statusmode(pstMapInst,iModeID) < 0 )
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Set : VarMode = %d\n", pstMapInst->stStatusVar.chStatusMode);
	}
	else
	{
		if(end_pworld_map_statusmode(pstMapInst) < 0 )
		{
			return -1;
		}
		snprintf(szInfo, sizeof(szInfo), "Query : VarMode = %d\n", pstMapInst->stStatusVar.chStatusMode);
	}

	system_msg_to_role(pstRole, szInfo);
	return 0;
}

int gm_starpworld(LPROLE pstRole, const char *pszArg)
{
	char szHelp[1024];
	sprintf(szHelp, 
	" //starpworld set $Value\n");
	char szTemp[80];
	int iValue = 0;

	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	
	if(!strncasecmp(szTemp, "set", sizeof("set")))
	{		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iValue = atoi(szTemp);
		return gm_set_starpworld_limit(iValue);
	}
	else if(!strncasecmp(szTemp, "id", sizeof("id")))
	{		
		LPZONETEAM pstZoneTeam = get_role_team(pstRole);
		if (NULL == pstZoneTeam || pstZoneTeam->ullLeaderGID != pstRole->ullGID)
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iID = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		int iLvl = atoi(szTemp);
		pstRole->stRolePworldInfo.stStarPworldInfo.wStarPworldID = iID;
		pstRole->stRolePworldInfo.stStarPworldInfo.chPworldStarLevel = iLvl;
		return 0;
	}
	else if(!strncasecmp(szTemp, "reset", sizeof("reset")))
	{		
		if (NULL == pstRole)
		{
			return -1;
		}
		pstRole->stPworldForRole.stStarPworld.chStar = 0;
		pstRole->stPworldForRole.stStarPworld.iTime = 0;
		return 0;
	}
	else if(!strncasecmp(szTemp, "rank", sizeof("rank")))
	{		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		int iID = atoi(szTemp) - 1;
		if (iID < 0 || iID >= get_hardcode_value_by_id(SVR_HARDCODE_ID_STAR_PWORLD2))
		{
			return -1;
		}
		LPPWORLDMINIGAMERANK  pstMiniGameRank = get_comm_misc_rank_data();
		if (NULL == pstMiniGameRank)
		{
			return -1;
		}
		int i = 0, j;
		for ( ; i < MAX_PWORLD_STAR_PWORLD_LEVEL_NUM ; i ++ )
		{
			if (pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].chFirstNum > 0)
			{
				sprintf(szHelp, "Lvl: %d First", i+5);
				system_msg_to_role(pstRole, szHelp);
				for ( j = 0 ; j < pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].chFirstNum ; j ++ )
				{
					sprintf(szHelp, "gid=%"PRIu64" name=%s",
						   pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].astFirstTeam[j].ullGID,
						   pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].astFirstTeam[j].szName);
					system_msg_to_role(pstRole, szHelp);
				}
			}
			if (pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].chFastNum > 0)
			{
				sprintf(szHelp, "Lvl: %d Fast", i+5);
				system_msg_to_role(pstRole, szHelp);
				for ( j = 0 ; j < pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].chFastNum ; j ++ )
				{
					sprintf(szHelp, "gid=%"PRIu64" name=%s",
						   pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].astFastTeam[j].ullGID,
						   pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[i].astFastTeam[j].szName);
					system_msg_to_role(pstRole, szHelp);
				}
			}
		}
		return 0;
	}
	else if(!strncasecmp(szTemp, "refirst", sizeof("refirst")))
	{		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		int iID = atoi(szTemp) - 1;
		if (iID < 0 || iID >=  get_hardcode_value_by_id(SVR_HARDCODE_ID_STAR_PWORLD2))
		{
			return -1;
		}
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		int iLvl = atoi(szTemp) - 5;
		if (iLvl < 0 || iLvl >= MAX_PWORLD_STAR_PWORLD_LEVEL_NUM)
		{
			return -1;
		}
		LPPWORLDMINIGAMERANK  pstMiniGameRank = get_comm_misc_rank_data();
		if (NULL == pstMiniGameRank)
		{
			return -1;
		}
		pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[iLvl].chFirstNum = 0;
		pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[iLvl].iFirstTime = 0;

		return 0;
	}
	else if(!strncasecmp(szTemp, "refast", sizeof("refast")))
	{		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		int iID = atoi(szTemp) - 1;
		if (iID < 0 || iID >=  get_hardcode_value_by_id(SVR_HARDCODE_ID_STAR_PWORLD2))
		{
			return -1;
		}
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		int iLvl = atoi(szTemp) - 5;
		if (iLvl < 0 || iLvl >= MAX_PWORLD_STAR_PWORLD_LEVEL_NUM)
		{
			return -1;
		}
		LPPWORLDMINIGAMERANK  pstMiniGameRank = get_comm_misc_rank_data();
		if (NULL == pstMiniGameRank)
		{
			return -1;
		}
		pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[iLvl].chFastNum = 0;
		pstMiniGameRank->astStarPworldRank[iID].astRankLvlData[iLvl].iFastTime = 0xFFFF;

		return 0;
	}
	else
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	return 0;
}


int gm_commstat(LPROLE pstRole, const char *pszArg)
{
	char szHelp[1024];
	sprintf(szHelp, " 请正确输入参数\n "
					" //commstat add [状态ID] 	；增加角色的指定的普通状态\n "
					"//commstat remove [状态ID] ；移出角色的指定的普通状态\n "
					"//commstat check [状态ID] 	；查看角色的指定的普通状态\n"
					"//commstat look			；打印角色的所有普通状态\n"
					"//commstat clear			；清除角色的所有普通状态\n");
	char szTemp[80];
	char szRes[4096];
	char *pDesc=NULL;
	char chCmd = -1;
	int i;
	int iStatID = 0;
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole  != NULL)
	{
		snprintf(szRes,sizeof(szRes),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
			pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szRes);
	}
	else
	{
		pstDestRole = pstRole;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	if(!strncasecmp(szTemp, "add", sizeof("add")))
	{
		chCmd = 0;
	}else if(!strncasecmp(szTemp, "remove", sizeof("remove")))
	{
		chCmd = 1;
	}else if(!strncasecmp(szTemp, "check", sizeof("check")))
	{
		chCmd = 2;
	}
	else if(!strncasecmp(szTemp, "look", sizeof("look")))
	{
		chCmd = 3;
	}
	else if(!strncasecmp(szTemp, "clear", sizeof("clear")))
	{
		chCmd = 4;
	}
	else
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	if(3 != chCmd && 4 != chCmd)
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iStatID = atoi(szTemp);
		pDesc = get_desc_by_commstat(iStatID);
		if(NULL == pDesc)
		{
			sprintf(szHelp, " 没有这个普通状态，请核对\n ");
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
	}


	switch (chCmd)
	{
		case 0:
		{
			if(0 != set_commstat(pstDestRole, iStatID))
			{
				sprintf(szRes, "设置 [ %s ] 失败\n",pDesc);
			}
			else
			{
				sprintf(szRes, "设置 [ %s ] 成功\n",pDesc);
			}
			break;
		}
		case 1:
		{
			if(0 != is_commstat(pstDestRole, iStatID))
			{
				sprintf(szRes, "角色不在 [ %s ]\n",pDesc);
			}
			else
			{
				clr_commstat(pstDestRole, iStatID);
				sprintf(szRes, "清除 [ %s ] 成功\n",pDesc);
			}
			break;
		}
		case 2:
		{
			if(0 != is_commstat(pstDestRole, iStatID))
			{
				sprintf(szRes, "角色不在 [ %s ]\n",pDesc);
			}
			else
			{
				sprintf(szRes, "角色处于 [ %s ]\n",pDesc);
			}
			break;
		}
		case 3:
		{
			sprintf(szRes, "角色处于以下普通状态:\n");
			if(pstDestRole->stSpecStatList.flagDisableMove > 0)
			{
				sprintf(szRes+strlen(szRes), "[flag Disable Move  ]\n");
			}
			if(pstDestRole->stSpecStatList.flagUndamaged > 0)
			{
				sprintf(szRes+strlen(szRes),"[flag Undamage :%d]\n",pstDestRole->stSpecStatList.flagUndamaged);
			}

			for(i = RES_COMMSTAT_NA + 1; i <= RES_COMMSTAT_MAX; ++i)
			{
				pDesc = get_desc_by_commstat(i);
				if(NULL == pDesc)
				{
					continue;
				}
				if(0 == is_commstat(pstDestRole, i))
				{
					sprintf(szRes+strlen(szRes), "%d : [ %s ]\n", i ,pDesc);
				}
			}
			
			break;
		}
		case 4:
		{
			for(i = RES_COMMSTAT_NA + 1; i < RES_COMMSTAT_MAX; ++i)
			{
				if(0 == is_commstat(pstDestRole, i))
				{
					clr_commstat(pstDestRole, i);
				}
			}
			sprintf(szRes, "清除角色的所有普通状态\n");
			break;
		}
		default:
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
	}
	if(0 != strlen(szRes))
	{
		system_msg_to_role(pstRole, szRes);
	}
	return 0;
}
		

int gm_fetchattr(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	CSATTRLISTS stOut;
	stOut.nEno = 0;
	stOut.ulObjID = 0;
	stOut.nTotal = 0;
	int i;
	int iAttrID = 0;
	int iObjID = 0;
	int iValue = 0;
	LPPET pstPet = NULL;
	LPMONSTER pstMon = NULL;
	LPATTR pstObjAttr = NULL; //对象的基础属性
	
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole, "//fetchattr $isNoticeMsg  $ObjID $AttrID1 .... ");
		return -1;
	}
	//int iIsNoticeMsg = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		return -1;
	}
	iObjID = atoi(szTemp);
	if(0 == iObjID)
	{
		pstObjAttr = &pstRole->stAttr;
		for(i = 0; i < CS_MAX_ATTR ; ++i) 
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{		
				break;
			}
			iAttrID = atoi(szTemp);
			switch(iAttrID)
			{
				case CS_ATTR_CURHP:
					iValue = pstRole->iCurHP;
					break;
				case CS_ATTR_CURMP:
					iValue = pstRole->iCurMP;
					break;
				case CS_ATTR_CUREP:
					iValue = pstRole->iCurEP;
					break;
				default:
					iValue = role_attr_get_value(pstRole,iAttrID);
					break;
			}			
			if(iValue == -1)
			{
				return -1;
			}
			stOut.astAttr[stOut.nTotal].nAttr = iAttrID;
			stOut.astAttr[stOut.nTotal].iValue = iValue;
			++stOut.nTotal;
			
		}
	}
	else if (1 == iObjID)
	{
		pstPet = get_pet_by_role( pstRole);
		if(pstPet == NULL)
		{
			return -1;
		}
		pstObjAttr = &pstPet->stAttr;
		
		stOut.ulObjID = pstPet->stObject.ulID;
		for(i = 0; i < CS_MAX_ATTR ; ++i) 
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{		
				break;
			}
			iAttrID = atoi(szTemp);
			switch(iAttrID)
			{
				case CS_ATTR_CURHP:
					iValue = pstPet->iCurHP;
					break;
				case CS_ATTR_CURMP:
					iValue = pstPet->iCurMP;
					break;
				default:
					iValue = pet_attr_get_value(pstPet,iAttrID);
					break;
			}		
			if(iValue == -1)
			{
				return -1;
			}
			stOut.astAttr[stOut.nTotal].nAttr = iAttrID;
			stOut.astAttr[stOut.nTotal].iValue = iValue;
			++stOut.nTotal;
			
		}
	}
	else
	{
		pstMon = zid_to_monster( iObjID);
		if(pstMon == NULL)
		{
			return -1;
		}
		pstObjAttr = &pstMon->stAttr;
		stOut.ulObjID=iObjID;
		for(i = 0; i < CS_MAX_ATTR; ++i) 
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{		
				break;
			}
			iAttrID = atoi(szTemp);
			switch(iAttrID)
			{
				case CS_ATTR_CURHP:
					iValue = pstMon->iCurHP;
					break;
				case CS_ATTR_CURMP:
					iValue = pstMon->iCurMP;
					break;
				default:
					iValue = monster_attr_get_value(pstMon,iAttrID);
					break;
			}
			if(iValue == -1)
			{
				return -1;
			}
			stOut.astAttr[stOut.nTotal].nAttr = iAttrID;
			stOut.astAttr[stOut.nTotal].iValue = iValue;
			++stOut.nTotal;
			
		}
	}

	//向Client发一下打印消息
	char sPrintTmp[2500];
	sPrintTmp[0] = 0;
	char sTmp[218];
	sTmp[0] = 0;
	int iBase, iAdd, iMul, iAddEx;
	system_msg_to_role(pstRole, "属性计算公式:(iBase + iAdd)*(100+iMul)/100 + iAddEx");	

	for(i = 0; i < stOut.nTotal; i++)
	{
		if(strlen(sPrintTmp) >= 2000)
		{
			break;
		}
		iBase = iAdd = iMul = iAddEx = 0;
		if(NULL != pstObjAttr)
		{			
			attr_get_revvalue_detail(pstObjAttr, stOut.astAttr[i].nAttr, &iBase, &iAdd, &iMul, &iAddEx);
		}
		snprintf(sTmp, 218, "attr%d = %d【(%d+%d)*(100+%d)/100+%d】|",  
			stOut.astAttr[i].nAttr, stOut.astAttr[i].iValue,
			iBase, iAdd, iMul, iAddEx);		
		strcat(sPrintTmp, sTmp);
	}
	system_msg_to_role(pstRole, sPrintTmp);
	
	//if(0 != iIsNoticeMsg) --- 基本上不用atp，暂时都不发消息
	//{
	//	reply_server_pkg(pstRole->ulUin, CS_CMD_ROLE_ATTR, &stOut);
	//}
	return 0;
}

int gm_zoneinfo(LPROLE pstRole, const char *pszArg)
{
	char szMsg[1024] = {0};
	LPROLEPOOL    pstRolePool    = NULL;
	LPMONSTERPOOL pstMonsterPool = NULL;
	LPMAPINSTS    pstMapInstPool = NULL;
	LPPWORLDINSTS pstPworldPool  = NULL;

	if (NULL == pstRole)
	{
		return -1;
	}

	system_msg_to_role(pstRole, "\n=== zone info:server protocol ver(MAJOR:MINOR)=(%d:%d)",
				CS_MAJOR,CS_MINOR);

	unsigned int ulProcID = get_sys_entityid();
	snprintf(szMsg,sizeof(szMsg),"current zoneserver procid:%s",get_proc_str_by_id(ulProcID));	
	system_msg_to_role(pstRole,szMsg);
	
	LPSYSENV pstSysEnv = get_sys_env();
	if(pstSysEnv != NULL)
	{
		LPEVENTLIST pstEventList = pstSysEnv->pstEventList;
		if(pstEventList != NULL)
		{
			snprintf(szMsg,sizeof(szMsg),"pworld simple timer:event system limit:%d curr event num:%d",MAX_REGIST_EVENT_HANDLER,pstEventList->nTotal);
			system_msg_to_role(pstRole,szMsg);
		}
		LPPWORLDINSTS pstPworldInsts = pstSysEnv->pstPworldInsts;
		if(pstPworldInsts != NULL)
		{
			snprintf(szMsg,sizeof(szMsg),"pworld inst system limit:%d pworld insts num:%d",MAX_PWORLD_INST,pstPworldInsts->iInst);
			system_msg_to_role(pstRole,szMsg);
		}
	}
	else
	{
		return -1;
	}

				
	//取角色数
	pstRolePool = get_role_pool();
	if (NULL == pstRolePool)
	{
		snprintf(szMsg, sizeof(szMsg), "role num : get role num error");
	}
	else
	{
		snprintf(szMsg, sizeof(szMsg), "role syslimit:%d iUse:%d  iAlloc currnum:%d",MAX_ROLE, pstRolePool->stRole.iUse, pstRolePool->stRole.iAlloc);
	}
	system_msg_to_role(pstRole, szMsg);

	//取怪物数
	pstMonsterPool = get_monster_pool();
	if (NULL == pstMonsterPool)
	{
		snprintf(szMsg, sizeof(szMsg), "Monster num : get Monster num error");
	}
	else
	{
		snprintf(szMsg, sizeof(szMsg), "syslimit num:%d Monster num : %d",MAX_MONSTER, pstMonsterPool->stMonster.iAlloc);
	}
	system_msg_to_role(pstRole, szMsg);

	//取地图实例数
	pstMapInstPool = get_map_insts();
	if (NULL == pstMapInstPool)
	{
		snprintf(szMsg, sizeof(szMsg), "MapInst num : get MapInst num error");
		system_msg_to_role(pstRole, szMsg);

	}
	else
	{
		snprintf(szMsg, sizeof(szMsg), "mapinst syslimit num:%d MapInst num : InstNum[%d] currnum[%d]",MAX_MAP_INST,
			 pstMapInstPool->iInst, pstMapInstPool->stInst.iAlloc);
		system_msg_to_role(pstRole, szMsg);

		snprintf(szMsg,sizeof(szMsg),"mapinst triggergroup num alloc:%d  usednum:%d  sys limit:%d",pstMapInstPool->stTriggerGroup.stInst.iAlloc, 
			pstMapInstPool->stTriggerGroup.stInst.iUse,MAX_TRIGGER_GROUP);
		system_msg_to_role(pstRole,szMsg);
		snprintf(szMsg,sizeof(szMsg),"monster groupinst num alloc:%d usednum:%d  sys limit:%d",pstMapInstPool->stMonsterGroupInsts.stInst.iAlloc,
			pstMapInstPool->stMonsterGroupInsts.stInst.iUse,MAX_GROUP_INST);
		
		system_msg_to_role(pstRole,szMsg);
		
		snprintf(szMsg,sizeof(szMsg),"monster regioninst num alloc:%d usednum:%d  sys limit:%d",pstMapInstPool->stRegionInsts.stInst.iAlloc,
			pstMapInstPool->stRegionInsts.stInst.iUse,MAX_REGION_INST);

		system_msg_to_role(pstRole,szMsg);

		snprintf(szMsg,sizeof(szMsg),"map inst areainst num alloc:%d usednum:%d  syslimit:%d",pstMapInstPool->stAreaInsts.stInst.iAlloc,
			pstMapInstPool->stAreaInsts.stInst.iUse,MAX_AREA_INST);	
		system_msg_to_role(pstRole,szMsg);


	}

	

	
	//取物品数

	LPITEMPOOL  pstItemPool = pstSysEnv->pstItemPool;   
	if(NULL != pstItemPool)
	{
	     snprintf(szMsg,sizeof(szMsg),"item pool syslimit:%d iUse:%d  iAlloc currnum:%d\n",MAX_ITEM,pstItemPool->stItem.iUse,pstItemPool->stItem.iAlloc);
		system_msg_to_role(pstRole, szMsg);
	}


	// 取宠物数

	LPPETPOOL pstPetPool = pstSysEnv->pstPetPool;
	if(NULL != pstPetPool)
	{
        	snprintf(szMsg,sizeof(szMsg),"pet pool syslimit:%d currnum:%d\n",MAX_PET,pstPetPool->stPet.iAlloc);
		system_msg_to_role(pstRole, szMsg);

	}

	//取副本数
	pstPworldPool = get_pworld_insts();
	if (NULL == pstPworldPool)
	{
		snprintf(szMsg, sizeof(szMsg), "Pworld num : get Pworld num error");
	}
	else
	{
		snprintf(szMsg, sizeof(szMsg), "pworld syslimit num:%d Pworld num : InstNum[%d] currnum[%d]\n",MAX_PWORLD_INST, pstPworldPool->iInst, pstPworldPool->stInst.iAlloc);
	}
	system_msg_to_role(pstRole, szMsg);


	//取组队
	LPZONETEAMLIST  pstTeamPool = pstSysEnv->pstTeamPool;
        if(pstTeamPool != NULL)
        {
        	snprintf(szMsg,sizeof(szMsg),"team pool syslimit:%d currnum:%d used team:%d team size:%d bytes\n",MAX_TEAM,pstTeamPool->stTeam.iAlloc,pstTeamPool->stTeam.iUse,(int)sizeof(ZONETEAM));

		system_msg_to_role(pstRole, szMsg);

	}


	char szTemp[128];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return 0;
	}		

	LPPWORLDINST pstPworldInst = NULL;
	LPPWORLDINDEX pstPworldIndex = NULL;
	int i=0;
	for(i=0 ; i < pstPworldPool->iInst; i++)
	{
			
		pstPworldInst = find_pworld_inst_by_index(&pstPworldPool->astIndex[i]);		
		if(pstPworldInst == NULL)
		{
			system_msg_to_role(pstRole,"find pworld inst failed.");
			continue;
		}

		pstPworldIndex = find_pworld_index_by_inst(pstPworldInst);

		if(pstPworldIndex == NULL)
		{
			system_msg_to_role(pstRole,"find pworld index failed.");
			continue;
		}
		
		 snprintf(szMsg, sizeof(szMsg),"pworld id:%d name:%s include mapnum:%d usernum:%d",pstPworldIndex->stSetting.wID,pstPworldIndex->stSetting.szName,pstPworldInst->iMapInst,pstPworldInst->stRoleList.chCount);
		system_msg_to_role(pstRole,szMsg);
		

	}

	return 0;
#if 0
	////printf map info.	
	int i = 0;	
	for( ; i < pstMapInstPool->iInst; i++)
	{
		LPMAPINST pstMapInst = find_map_inst_by_index(&pstMapInstPool->astIndex[i]);	
		if(pstMapInst == NULL)
		{
			snprintf(szMsg, sizeof(szMsg), "show mapinfo : get mapinfo error");
			system_msg_to_role(pstRole, szMsg);

			continue;
		}	
        	LPMAPINDEX pstMapIndex = find_map_index(MAP_INST_ID_TO_MAP_ID(pstMapInst->ullID), &pstMapInst->iMapIndexPos);
		if(pstMapIndex == NULL)
		{
			snprintf(szMsg, sizeof(szMsg), "show mapinfo : get mapinfo error");
			system_msg_to_role(pstRole, szMsg);

			continue;
		}
		int iRoleNum = query_mapinst_obj_num(&pstMapInstPool->astIndex[i],OBJ_ROLE);
		snprintf(szMsg,sizeof(szMsg),"%d: MapInst Info:Mapid:%d mapname:%s PworldId:%d RoleNum:%d",
			i,pstMapIndex->stSetting.wID,pstMapIndex->stSetting.szName,				MAP_INST_ID_TO_PWORLD_ID(pstMapInst->ullID),iRoleNum);
		system_msg_to_role(pstRole,szMsg);
	
	}		

	
	LPPWORLDINST pstPworldInst = NULL;
	LPPWORLDINDEX pstPworldIndex = NULL;
	for(i=0 ; i < pstPworldPool->iInst; i++)
	{
			
		pstPworldInst = find_pworld_inst_by_index(&pstPworldPool->astIndex[i]);		
//		pstPworldIndex = find_pworld_index(MAP_INST_ID_TO_PWORLD_ID(pstPworldPool->astIndex[i].ullID),NULL);
		if(pstPworldInst == NULL)
		{
			system_msg_to_role(pstRole,"find pworld inst failed.");
			continue;
		}

		pstPworldIndex = find_pworld_index_by_inst(pstPworldInst);

		if(pstPworldIndex == NULL)
		{
			system_msg_to_role(pstRole,"find pworld index failed.");
			continue;
		}
		
		 snprintf(szMsg, sizeof(szMsg),"pworld id:%d name:%s include mapnum:%d usernum:%d",pstPworldIndex->stSetting.wID,pstPworldIndex->stSetting.szName,pstPworldInst->iMapInst,pstPworldInst->stRoleList.chCount);
		system_msg_to_role(pstRole,szMsg);
		

	}
#endif


	return 0;
}


void print_sort_int_array_to_gm(LPROLE pstRole,int piHead[],int iMax)
{
	//对统计包排序打印.
	if(NULL == pstRole)
	{
		return;
	}

	int astTmpStat[MAX_STAT_MSG_CMD_ID][2];
	int i=0; 
	if(iMax > MAX_STAT_MSG_CMD_ID)
	{
		return ;
	}		
	for( ; i < iMax; i++)
	{
		astTmpStat[i][0] = piHead[i];
		astTmpStat[i][1] = i;
	}

	qsort(astTmpStat,iMax,sizeof(astTmpStat[0]),rl_comp_func);
		
	i = 0;
	char sTmpPrint[256];
	sTmpPrint[0] = 0;
	char sTmp[32];
	sTmp[0] = 0;
	int iActCouter = 0;
	for(i = 0; i < iMax; i++)
	{
		if(0 == astTmpStat[i][0])
		{
			continue;
		}
		iActCouter++;		
		sprintf(sTmp, "[%d]=%d | ", astTmpStat[i][1], astTmpStat[i][0]);
		strcat(sTmpPrint, sTmp);
		if(0 == iActCouter % 4)
		{			
			system_msg_to_role(pstRole, sTmpPrint);
			sTmpPrint[0] = 0;
		}
	}
	if(0 != iActCouter % 4) //最后一次还没有打印出来
	{
		system_msg_to_role(pstRole, sTmpPrint);
		sTmpPrint[0] = 0;
	}	

}
void print_int_array_to_gm(LPROLE pstRole,  int piHead[], int iMax)
{
	if(NULL == pstRole)
	{
		return;
	}
	int i = 0;
	char sTmpPrint[256];
	sTmpPrint[0] = 0;
	char sTmp[32];
	sTmp[0] = 0;
	int iActCouter = 0;
	for(i = 0; i < iMax; i++)
	{
		if(0 == piHead[i])
		{
			continue;
		}
		iActCouter++;		
		sprintf(sTmp, "[%d]=%d | ", i, piHead[i]);
		strcat(sTmpPrint, sTmp);
		if(0 == iActCouter % 5)
		{			
			system_msg_to_role(pstRole, sTmpPrint);
			sTmpPrint[0] = 0;
		}
	}
	if(0 != iActCouter % 5) //最后一次还没有打印出来
	{
		system_msg_to_role(pstRole, sTmpPrint);
		sTmpPrint[0] = 0;
	}	
}

int gm_netflow(LPROLE pstRole, const char *pszArg)
{
	char szMsg[1024] = {0};
	char szTemp[80];
	LPSYSMISCSTATISTICSINFO pstNetFlowInfo = NULL;
	if (NULL == pstRole)
	{
		return -1;
	}

	system_msg_to_role(pstRole, "\n========== net flow info ===============");
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{		
		if(!strncasecmp(szTemp, "reset", sizeof("reset")))
		{
			reset_network_flow_statistic_mem();
			system_msg_to_role(pstRole, "\n========= reset static mem success ==========");
			return 0;
		}
		else if(!strncasecmp(szTemp, "csmsg", sizeof("csmsg")))
		{
			pstNetFlowInfo = get_network_flow_statistic_mem();
			if(NULL == pstNetFlowInfo)
			{
				return -1;
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			int iType = atoi(szTemp);
			system_msg_to_role(pstRole, "iType=%d:", iType);
			if(1 == iType)
			{
				print_sort_int_array_to_gm(pstRole, pstNetFlowInfo->aiUpCSMsgIDCount, MAX_STAT_MSG_CMD_ID);
			}
			else if (2 == iType)
			{
				print_sort_int_array_to_gm(pstRole, pstNetFlowInfo->aiDownCSMsgIDCount, MAX_STAT_MSG_CMD_ID);
			}
			else if (3 == iType)
			{
				print_sort_int_array_to_gm(pstRole, pstNetFlowInfo->aiDownCSMsgIDCountIncludePack, MAX_STAT_MSG_CMD_ID);
			}

			return 0;
		}		
	}

	pstNetFlowInfo = get_network_flow_statistic_mem();
	if(NULL == pstNetFlowInfo)
	{
		system_msg_to_role(pstRole, "\n========= system abnormal,get NULL ======");
		return -1;
	}

	LPROLEPOOL pstRolePool = get_role_pool();
	if(NULL != pstRolePool)
	{
		snprintf(szMsg,sizeof(szMsg),"curr online role num:%d",pstRolePool->stRole.iAlloc);
		system_msg_to_role(pstRole,szMsg);	
	}

	snprintf(szMsg,sizeof(szMsg),"Start Time : %s",ctime((time_t*)&pstNetFlowInfo->tStartTime));
	system_msg_to_role(pstRole,szMsg);

	int tNow = time(NULL);

	snprintf(szMsg,sizeof(szMsg),"Tconnd --> Zone : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulRecvFromConndPkgNum ,pstNetFlowInfo->ulRecvFromConndBytes);
	system_msg_to_role(pstRole,szMsg);
	if(pstNetFlowInfo->ulRecvFromConndPkgNum > 0 && pstNetFlowInfo->ulRecvFromConndBytes > 0 && (tNow - pstNetFlowInfo->tStartTime) > 0 && pstRolePool->stRole.iAlloc > 0)
	{
		snprintf(szMsg,sizeof(szMsg),"Tconnd-->Zone:pkgNumPerSecond:%u bps:%u rolebps:%u",pstNetFlowInfo->ulRecvFromConndPkgNum/(tNow - pstNetFlowInfo->tStartTime),
			pstNetFlowInfo->ulRecvFromConndBytes*8/(tNow - pstNetFlowInfo->tStartTime),(pstNetFlowInfo->ulRecvFromConndBytes*8/(tNow - pstNetFlowInfo->tStartTime))/pstRolePool->stRole.iAlloc);
		system_msg_to_role(pstRole,szMsg);

	}
	snprintf(szMsg,sizeof(szMsg),"Zone --> Tconnd : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulSendToConndPkgNum,pstNetFlowInfo->ulSendToConndBytes);
	system_msg_to_role(pstRole,szMsg);
	if(pstNetFlowInfo->ulSendToConndPkgNum > 0 && pstNetFlowInfo->ulSendToConndBytes > 0 && (tNow - pstNetFlowInfo->tStartTime) > 0 && pstRolePool->stRole.iAlloc > 0)
	{
		snprintf(szMsg,sizeof(szMsg),"Zone-->Tconnd: pkgnumpersecond:%u bps:%u rolebps:%u",pstNetFlowInfo->ulSendToConndPkgNum/(tNow - pstNetFlowInfo->tStartTime),
			pstNetFlowInfo->ulSendToConndBytes*8/(tNow - pstNetFlowInfo->tStartTime),
			(pstNetFlowInfo->ulSendToConndBytes*8/(tNow - pstNetFlowInfo->tStartTime))/pstRolePool->stRole.iAlloc);


		system_msg_to_role(pstRole,szMsg);

	}	

	snprintf(szMsg,sizeof(szMsg),"World --> Zone : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulRecvFromWorldPkgNum ,pstNetFlowInfo->ulRecvFromWorldBytes);
	system_msg_to_role(pstRole,szMsg);
	snprintf(szMsg,sizeof(szMsg),"Misc --> Zone : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulRecvFromMiscPkgNum ,pstNetFlowInfo->ulRecvFromMiscBytes);
	system_msg_to_role(pstRole,szMsg);
	snprintf(szMsg,sizeof(szMsg),"Chat --> Zone : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulRecvFromChatPkgNum ,pstNetFlowInfo->ulRecvFromChatBytes);
	system_msg_to_role(pstRole,szMsg);
	snprintf(szMsg,sizeof(szMsg),"Zone --> World : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulSendToWorldPkgNum,pstNetFlowInfo->ulSendToWorldBytes);
	system_msg_to_role(pstRole,szMsg);
	snprintf(szMsg,sizeof(szMsg),"Zone --> Misc : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulSendToMiscPkgNum,pstNetFlowInfo->ulSendToMiscBytes);
	system_msg_to_role(pstRole,szMsg);
	snprintf(szMsg,sizeof(szMsg),"Zone --> Chat : PkgNum [%u] PkgBytes [%u]",pstNetFlowInfo->ulRecvFromChatPkgNum ,pstNetFlowInfo->ulRecvFromChatBytes);
	system_msg_to_role(pstRole,szMsg);
	
	snprintf(szMsg,sizeof(szMsg),"Cur Time : %s ElapseTime [%d] s.",ctime((time_t*)&tNow),tNow - pstNetFlowInfo->tStartTime);
	system_msg_to_role(pstRole,szMsg);

	return 0;
}

int gm_pk(LPROLE pstRole, const char *pszArg)
{
	char szHelp[4096];
	sprintf(szHelp, "  // pk print 打印PK相关的几个参数值\n"
	 " // pk pkvalue set $Value\n " 	 
	 " // pk pkmode set $Value \n" 	 
	 " // pk regionpkmode get\n"
	 " // pk killer set $Num\n"
	 " // pk teamwin $Num\n"
	 " // pk selfwin $Num\n"
	 " // pk attackhonor/defhonor set $Value\n"
	 " // pk release $QQ\n");
	char szTemp[80];
	char chCmd = -1;
	int iValue = 0;
	int i = 0;

	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}

	if(!strncasecmp(szTemp, "print", sizeof("print")))
	{
		set_role_region_pk_mode(pstRole); //设置一下chRegionPKMode的值，因为当前只有pk发生时才取这个值
		sprintf(szHelp, "PKValue=%d\n PKMode=%d\n RegionPKMode=0x%x\n", 
			pstRole->stPKInfo.nPKValue, pstRole->stPKInfo.chPKMode, pstRole->stPKInfo.chRegionPKMode);
		system_msg_to_role(pstRole, szHelp);
		return 0;
	}
	else if(!strncasecmp(szTemp, "pkvalue", sizeof("pkvalue")))
	{
		chCmd = 0;
	}else if(!strncasecmp(szTemp, "pkmode", sizeof("pkmode")))
	{
		chCmd = 1;
	}else if(!strncasecmp(szTemp, "regionpkmode", sizeof("regionpkmode")))
	{
		chCmd = 2;
	}
	else if(!strncasecmp(szTemp, "killer", sizeof("killer")))
	{
		chCmd = 3;
	}
	else if(!strncasecmp(szTemp, "attackhonor", sizeof("attackhonor")))
	{
		chCmd = 4;
	}
	else if(!strncasecmp(szTemp, "defhonor", sizeof("defhonor")))
	{
		chCmd = 5;
	}
	else if(!strncasecmp(szTemp, "teamwin", sizeof("teamwin")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		pstRole->stPKInfo.stPkOtherInfo.iTeamWin = atoi(szTemp);
		sprintf(szHelp, "Pkplat SelfWin[%d] SelfLose[%d] TeamWin[%d] TeamLose[%d].", 
				pstRole->stPKInfo.stPkOtherInfo.iSelfWin,pstRole->stPKInfo.stPkOtherInfo.iSelfLost,
				pstRole->stPKInfo.stPkOtherInfo.iTeamWin,pstRole->stPKInfo.stPkOtherInfo.iTeamLost);
		return	system_msg_to_role(pstRole, szHelp);
	}
	else if(!strncasecmp(szTemp, "selfwin", sizeof("selfwin")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			return -1;
		}
		pstRole->stPKInfo.stPkOtherInfo.iSelfWin =  atoi(szTemp);
		sprintf(szHelp, "Pkplat SelfWin[%d] SelfLose[%d] TeamWin[%d] TeamLose[%d].", 
				pstRole->stPKInfo.stPkOtherInfo.iSelfWin,pstRole->stPKInfo.stPkOtherInfo.iSelfLost,
				pstRole->stPKInfo.stPkOtherInfo.iTeamWin,pstRole->stPKInfo.stPkOtherInfo.iTeamLost);
		return	system_msg_to_role(pstRole, szHelp);
	}
	else if(!strncasecmp(szTemp, "release", sizeof("release")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		unsigned int ulUin = atoll(szTemp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "目标不在线");
			return -1;
		}
		gm_release_from_jail(pstTargetRole);
		return 0;
		
	}
	else if(!strncasecmp(szTemp, "req", sizeof("req")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		unsigned int ulUin = atoll(szTemp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "目标不在线");
			return -1;
		}
		CSPKC stPKC;
		stPKC.chOpType = CS_PK_OP_TYPE_PK_REQ;
		stPKC.stData.stPKReq.chPKType = CS_PK_PK_TYPE_SINGLE;
		stPKC.stData.stPKReq.ulInviter = pstRole->stObject.ulID;
		stPKC.stData.stPKReq.ulInvitee = pstTargetRole->stObject.ulID;
		return process_pk_cmd(pstRole, &stPKC);
	}
	else if(!strncasecmp(szTemp, "answer", sizeof("answer")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		unsigned int ulUin = atoll(szTemp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "目标不在线");
			return -1;
		}
		CSPKC stPKC;
		stPKC.chOpType = CS_PK_OP_TYPE_PK_ANSWER;
		stPKC.stData.stPKAnswer.chYesOrNo = 1;
		stPKC.stData.stPKAnswer.stReq.chPKType = CS_PK_PK_TYPE_SINGLE;
		stPKC.stData.stPKAnswer.stReq.ulInviter = pstTargetRole->stObject.ulID;
		stPKC.stData.stPKAnswer.stReq.ulInvitee = pstRole->stObject.ulID;
		return process_pk_cmd(pstRole, &stPKC);
	}
	else if(!strncasecmp(szTemp, "pklist", sizeof("pklist")))
	{
		CSPKC stPKC;
		stPKC.chOpType = CS_PK_OP_TYPE_QUERY_LIST;
		stPKC.stData.chRes = 0;
		return process_pk_cmd(pstRole, &stPKC);
	}
	else if(!strncasecmp(szTemp, "pkview", sizeof("pkview")))
	{
		CSPKC stPKC;
		stPKC.chOpType = CS_PK_OP_TYPE_VIEW_REQ;
		stPKC.stData.iPlatformID = 1;
		return process_pk_cmd(pstRole, &stPKC);
	}	
	else if(!strncasecmp(szTemp, "5v5", sizeof("5v5")))
	{
		gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	
		if (!szTemp[0])
		{
			return -1;
		}
		if(!strncasecmp(szTemp, "sys", sizeof("sys")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				int iArray[5];
				get_pk_5v5_global_limit(iArray, 5);

				snprintf(szHelp, sizeof(szHelp), 
						"max role num = %d prof = %d team = %d statstart=%d statover=%d", 
						iArray[0],iArray[1],iArray[2],iArray[3],iArray[4]);
				system_msg_to_role(pstRole,szHelp);
				return 0;
			}
			if(!strncasecmp(szTemp, "set", sizeof("set")))
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				char chMax = atoi(szTemp);
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				char chProf = atoi(szTemp);
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				char chTeam = atoi(szTemp);
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				char chStatStart = atoi(szTemp);
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				char chStatOver = atoi(szTemp);

				chg_pk_5v5_global_limit(chMax, chProf, chTeam);
				chg_pk_5v5_global_commstat(chStatStart, chStatOver);
				return 0;
			}
		}
		if(!strncasecmp(szTemp, "map", sizeof("map")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				LPPK5V5ACTDATA pstPK5V5ActData = get_pk_5v5_act_data();
				if (NULL == pstPK5V5ActData)
				{
					return -1;
				}
				int iNum = deal_pk_5v5_map_inst_num(PK_5V5_MAPINST_NUM_OP_GET, 0);
				int iStatVal = -1;
				LPMAPINST pstMapInst = find_map_inst(pstRole->stRolePworldInfo.stPworldInstIndex.ullID, NULL);
				if (NULL != pstMapInst)
				{
					iStatVal = pstMapInst->aiMapInstValue[0];
				}
				snprintf(szHelp, sizeof(szHelp), "map inst num = %d statval[0] = %d", iNum,iStatVal);
				system_msg_to_role(pstRole,szHelp);
				return 0;
			}
			if(!strncasecmp(szTemp, "data", sizeof("data")))
			{
				LPPK5V5PWORLDRECORD pstMapData = get_pk_5v5_mapinst_data(pstRole);
				if (NULL == pstMapData)
				{
					return -1;
				}
				snprintf(szHelp, sizeof(szHelp), "grade = %d", pstMapData->chGrade);
				system_msg_to_role(pstRole,szHelp);

				snprintf(szHelp, sizeof(szHelp), 
						"Red: Score=%d avgscore=%d gidnum=%d", 
						pstMapData->stRedCamp.chScore,
						pstMapData->stRedCamp.iAvgScore,
						pstMapData->stRedCamp.chGidNum);
				system_msg_to_role(pstRole,szHelp);
				int i;
				LPROLE pstRoleTmp = NULL;
				for ( i = 0 ; i < pstMapData->stRedCamp.chGidNum && i < CS_PK_5V5_MAX_ROLE_NUM; i++ )
				{
					pstRoleTmp = gid_to_role(pstMapData->stRedCamp.astTeamData[i].ullRoleGid);
					if (NULL != pstRoleTmp)
					{
						snprintf(szHelp, sizeof(szHelp), 
								"%d: score=%d gid=%"PRIu64" uin=%u name=%s", 
								i+1,
								pstMapData->stRedCamp.astTeamData[i].chScore,
								pstMapData->stRedCamp.astTeamData[i].ullRoleGid,
								pstRoleTmp->ulUin, pstRoleTmp->szName);
					}
					else
					{
						snprintf(szHelp, sizeof(szHelp), 
								"%d: score=%d gid=%"PRIu64" uin=xxx name=xxx", 
								i+1,
								pstMapData->stRedCamp.astTeamData[i].chScore,
								pstMapData->stRedCamp.astTeamData[i].ullRoleGid);
					}
					system_msg_to_role(pstRole,szHelp);
				}

				snprintf(szHelp, sizeof(szHelp), 
						"Blue: Score=%d avgscore=%d gidnum=%d", 
						pstMapData->stBlueCamp.chScore,
						pstMapData->stBlueCamp.iAvgScore,
						pstMapData->stBlueCamp.chGidNum);
				system_msg_to_role(pstRole,szHelp);
				for ( i = 0 ; i < pstMapData->stBlueCamp.chGidNum && i < CS_PK_5V5_MAX_ROLE_NUM; i++ )
				{
					pstRoleTmp = gid_to_role(pstMapData->stBlueCamp.astTeamData[i].ullRoleGid);
					if (NULL != pstRoleTmp)
					{
						snprintf(szHelp, sizeof(szHelp), 
								"%d: score=%d gid=%"PRIu64" uin=%u name=%s", 
								i+1,
								pstMapData->stBlueCamp.astTeamData[i].chScore,
								pstMapData->stBlueCamp.astTeamData[i].ullRoleGid,
								pstRoleTmp->ulUin, pstRoleTmp->szName);
					}
					else
					{
						snprintf(szHelp, sizeof(szHelp), 
								"%d: score=%d gid=%"PRIu64" uin=xxx name=xxx", 
								i+1,
								pstMapData->stBlueCamp.astTeamData[i].chScore,
								pstMapData->stBlueCamp.astTeamData[i].ullRoleGid);
					}
					system_msg_to_role(pstRole,szHelp);
				}
				return 0;
			}
			if(!strncasecmp(szTemp, "add", sizeof("add")))
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				int iChgVal = atoi(szTemp);
				if (0 == iChgVal)
				{
					return 0;
				}
				return deal_pk_5v5_map_inst_num(PK_5V5_MAPINST_NUM_OP_ADD, iChgVal);
			}
		}
		if(!strncasecmp(szTemp, "team", sizeof("team")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				LPPK5V5ACTDATA pstPK5V5ActData = get_pk_5v5_act_data();
				if (NULL == pstPK5V5ActData)
				{
					return -1;
				}
				snprintf(szHelp, sizeof(szHelp), "==Team Num: %d==", pstPK5V5ActData->iTeamNum);
				system_msg_to_role(pstRole,szHelp);
				if (pstPK5V5ActData->iTeamNum > 0)
				{
					int i, j;
					LPROLE pstRoleTmp = NULL;
					for ( i = 0 ; i < pstPK5V5ActData->iTeamNum && i < CS_PK_5V5_MAX_ROLE_NUM ; i++ )
					{
						snprintf(szHelp, sizeof(szHelp), 
								"Team %d: grade=%d avgscore=%d entertime=%d gidnum=%d", 
								i+1,
								pstPK5V5ActData->stPK5v5EloList[i].chGrade,
								pstPK5V5ActData->stPK5v5EloList[i].iAvgScore,
								pstPK5V5ActData->stPK5v5EloList[i].iEnterTime,
								pstPK5V5ActData->stPK5v5EloList[i].chGidNum);
						system_msg_to_role(pstRole,szHelp);
						for ( j = 0 ; j < pstPK5V5ActData->stPK5v5EloList[i].chGidNum 
										&& j < CS_PK_5V5_MAX_ROLE_NUM; j++ )
						{
							pstRoleTmp = gid_to_role(pstPK5V5ActData->stPK5v5EloList[i].aullGid[j]);
							if (NULL != pstRoleTmp)
							{
								snprintf(szHelp, sizeof(szHelp), 
										"%d: gid=%llu uin=%u name=%s", 
										j+1,
										pstPK5V5ActData->stPK5v5EloList[i].aullGid[j],
										pstRoleTmp->ulUin, pstRoleTmp->szName);
							}
							else
							{
								snprintf(szHelp, sizeof(szHelp), 
										"%d: gid=%llu uin=xxx name=xxx", 
										j+1,
										pstPK5V5ActData->stPK5v5EloList[i].aullGid[j]);
							}
							system_msg_to_role(pstRole,szHelp);
						}
					}
					return 0;
				}
				else 
				{
					return 0;
				}
			}
			if(!strncasecmp(szTemp, "del", sizeof("del")))
			{
				LPPK5V5ACTDATA pstPK5V5ActData = get_pk_5v5_act_data();
				if (NULL == pstPK5V5ActData)
				{
					return -1;
				}
				if (pstPK5V5ActData->iTeamNum <= 0)
				{
					return 0;
				}
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				if (!szTemp[0])
				{
					return -1;
				}
				int iPos = atoi(szTemp);
				if (iPos <= 0 || iPos > pstPK5V5ActData->iTeamNum || iPos >= PK_5V5_MAX_ELO_TEAM_NUM)
				{
					return -1;
				}

				return del_pk_5v5_team_from_elo_list(pstPK5V5ActData->stPK5v5EloList[iPos-1].ullTeamGid);
			}
			if(!strncasecmp(szTemp, "reset", sizeof("reset")))
			{
				return reset_pk_5v5_elo_list();
			}
		}
		if(!strncasecmp(szTemp, "role", sizeof("role")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				int iMorale = get_pk_5v5_role_morale(pstRole);
				snprintf(szHelp, sizeof(szHelp), 
						"morale = %d win = %d lost = %d score = %d point = %d", 
						iMorale,
						pstRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nWin,
						pstRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nLost,
						pstRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iScore,
						pstRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iPoint);
				system_msg_to_role(pstRole,szHelp);
				return 0;
			}
			if(!strncasecmp(szTemp, "morale", sizeof("morale")))
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				int iChgVal = atoi(szTemp);
				if (0 == iChgVal)
				{
					return 0;
				}
				return add_pk_5v5_role_morale(pstRole, iChgVal);
			}
			if(!strncasecmp(szTemp, "enter", sizeof("enter")))
			{
				deal_pk_5v5_list_apply(pstRole, NULL);
				return 0;
			}
		}
		if(!strncasecmp(szTemp, "qq", sizeof("qq")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			unsigned int ulUin = (unsigned int)atoll(szTemp);
			LPROLE pstTargetRole = uin_to_role(ulUin);
			if(NULL == pstTargetRole)
			{
				system_msg_to_role(pstRole, "目标不在线");
				return -1;
			}
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				int iMorale = get_pk_5v5_role_morale(pstTargetRole);
				snprintf(szHelp, sizeof(szHelp), 
						"uin=%u name=%s \nmorale = %d win = %d lost = %d score = %d point = %d", 
						pstTargetRole->ulUin,
						pstTargetRole->szName,
						iMorale,
						pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nWin,
						pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nLost,
						pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iScore,
						pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iPoint);
				system_msg_to_role(pstRole,szHelp);
				return 0;
			}
			if(!strncasecmp(szTemp, "reset", sizeof("reset")))
			{
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iScore = 0;
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.iPoint = 0;
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nWin = 0;
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nLost = 0;
				return 0;
			}
			int iVal = atoi(szTemp);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "morale", sizeof("morale")))
			{
				if (0 == iVal)
				{
					return 0;
				}
				return add_pk_5v5_role_morale(pstTargetRole, iVal);
			}
			if(!strncasecmp(szTemp, "score", sizeof("score")))
			{
				if (0 == iVal)
				{
					return 0;
				}
				return add_pk_5v5_role_score(pstTargetRole, iVal);
			}
			if(!strncasecmp(szTemp, "point", sizeof("point")))
			{
				if (0 == iVal)
				{
					return 0;
				}
				return add_pk_5v5_role_point(pstTargetRole, iVal);
			}
			if(!strncasecmp(szTemp, "win", sizeof("win")))
			{
				if (0 == iVal)
				{
					return 0;
				}
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nWin += iVal;
				return 0;
			}
			if(!strncasecmp(szTemp, "lost", sizeof("lost")))
			{
				if (0 == iVal)
				{
					return 0;
				}
				pstTargetRole->stPKInfo.stPkOtherInfo.stPK5v5Info.nLost += iVal;
				return 0;
			}
		}
		if(!strncasecmp(szTemp, "rank", sizeof("rank")))
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
		
			if (!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "info", sizeof("info")))
			{
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
				
				if (!szTemp[0])
				{
					return -1;
				}
				int iGrade = atoi(szTemp);
			
				LPCOMMPK5V5DATA pstCommData = (LPCOMMPK5V5DATA)commdata_cache_op_get(ENM_COMMDATA_KEY_PK_5V5_RANK);
				if(NULL == pstCommData)
				{
					return -1;
				}
				unsigned char bRoleNum = 0;
				LPCOMMPK5V5UNIT apstRankList = NULL;
				if (PK_5V5_LEVEL_GRADE_A == iGrade)
				{
					bRoleNum = pstCommData->bGradeANum;
					apstRankList = pstCommData->astGradeARank;
				}
				else if (PK_5V5_LEVEL_GRADE_B == iGrade)
				{
					bRoleNum = pstCommData->bGradeBNum;
					apstRankList = pstCommData->astGradeBRank;
				}
				else 
				{
					//没有开放其他等级段的排名榜
					return -1;
				}
				snprintf(szHelp, sizeof(szHelp), "Rank role num %d: ", bRoleNum);
				system_msg_to_role(pstRole,szHelp);
				int i = 0;
				for ( ; i < bRoleNum ; i++ )
				{
					snprintf(szHelp, sizeof(szHelp), 
							"%d: score=%d gid=%"PRIu64" name=%s zone=%d", 
							i+1,
							apstRankList[i].iScore,
							apstRankList[i].ullGID,
							apstRankList[i].szName,
							apstRankList[i].chBirthZone);
					system_msg_to_role(pstRole,szHelp);
				}
				return 0;
			}
			if(!strncasecmp(szTemp, "sync", sizeof("sync")))
			{
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			
				if (!szTemp[0])
				{
					return -1;
				}

				char chGrade = atoi(szTemp);
				return sync_pk_5v5_role_rank(chGrade);
			}
			if(!strncasecmp(szTemp, "reset", sizeof("reset")))
			{
				gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			
				if (!szTemp[0])
				{
					return -1;
				}
				char chGrade = atoi(szTemp);

				LPCOMMPK5V5DATA pstCommData = (LPCOMMPK5V5DATA)commdata_cache_op_get(ENM_COMMDATA_KEY_PK_5V5_RANK);
				if(NULL == pstCommData)
				{
					return -1;
				}

				unsigned char *pbRoleNum = NULL;
				LPCOMMPK5V5UNIT apstRankList = NULL;
				if (PK_5V5_LEVEL_GRADE_A == chGrade)
				{
					pbRoleNum = &pstCommData->bGradeANum;
					apstRankList = pstCommData->astGradeARank;
				}
				else if (PK_5V5_LEVEL_GRADE_B == chGrade)
				{
					pbRoleNum = &pstCommData->bGradeBNum;
					apstRankList = pstCommData->astGradeBRank;
				}
				else 
				{
					//没有开放其他等级段的排名榜
					return -1;
				}
				
				*pbRoleNum = 0;

				return 0;
			}
		}
	}
	else
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}	
	if(!strncasecmp(szTemp, "set", sizeof("set")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			system_msg_to_role(pstRole, szHelp);
			return -1;
		}
		iValue = atoi(szTemp);
	}
	else if(!strncasecmp(szTemp, "get", sizeof("get")))
	{		
	}
	else
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	switch (chCmd)
	{
		case 0:
			if(iValue > 9999) //GM指令，写死无妨
			{
				iValue = 9999;
			}
			else if (iValue < -9999)
			{
				iValue = -9999;
			}			
			set_role_pk_value(pstRole,  iValue-pstRole->stPKInfo.nPKValue);
			break;
		case 1:
		{
			CSOBJPROCATTR stProcAttr;
			stProcAttr.ulObjectID = 0;
			stProcAttr.nTotal = 1;
			stProcAttr.astAttr[0].nAttr = CS_PROC_ATTR_PKMODE;
			stProcAttr.astAttr[0].iValue = iValue;				
			deal_role_proc_attr(pstRole, &stProcAttr);
			break;
		}
		case 2:
			set_role_region_pk_mode(pstRole);	
			sprintf(szHelp, "role(%u) map(%d), pos[%d,%d] RegionPKMode=%d.", pstRole->ulUin, 
				MAP_INST_ID_TO_MAP_ID(pstRole->stObject.stMapInstIndex.ullID),
				pstRole->stObject.stPos.x, pstRole->stObject.stPos.y, 
				pstRole->stPKInfo.chRegionPKMode);
			system_msg_to_role(pstRole, szHelp);
			break;
		case 3:
			for(i = 1; i <= iValue;i++)
			{
				roll_dailycounter(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_ATTACK_KILLER, i); //就是填个位置，以便测试一下最大值
				roll_dailycounter(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_DEFENCE_KILLER, i);
			}
			break;
		case 4:
			i = iValue - get_role_attack_honor(pstRole);
			add_role_honor(pstRole, ROLE_HONOR_TYPE_ATTACK, ROLE_HONOR_GET_MODE_TASK, i); //gm获得写到任务中
			break;
		case 5:
			i = iValue - get_role_defence_honor(pstRole);
			add_role_honor(pstRole, ROLE_HONOR_TYPE_DEFENCE, ROLE_HONOR_GET_MODE_TASK, i);
			break;
		default:			
			break;
	}

	return 0;
}

int gm_jailrole(LPROLE pstRole, const char *pszArg)
{
	char szHelp[4096];
	sprintf(szHelp, " //jailrole $QQ $Hour $Min $Sec \n\t-----若时间同为0，则是将角色从监狱中释放。\n");
	char szTemp[80];

	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{		
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	unsigned int ulUin = (unsigned int)atoll(szTemp);
	LPROLE pstTargetRole = uin_to_role(ulUin);
	if(NULL == pstTargetRole)
	{
		system_msg_to_role(pstRole, "目标不在线");
		return -1;
	}
		
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	int iHour = atoi(szTemp);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	int iMin = atoi(szTemp);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole, szHelp);
		return -1;
	}
	int iSec = atoi(szTemp);
	
	//现在是一分钟+2个PK值，所以要求输入的时间最少是一分钟
	int iTotalSec = iHour*3600+iMin*60 +iSec;	
	if(iTotalSec < 60 && iTotalSec > 0)
	{
		system_msg_to_role(pstRole, "坐牢时间必须大于1分钟");
		return -1;
	}
	else if(iTotalSec == 0)
	{
		gm_release_from_jail(pstTargetRole);
		return 0;
	}
	else
	{
		iMin = iTotalSec/60; 
		int iQwValue = -iMin*2; //以后如果坐牢的数值发生修改，这个值要相应调整
		if(iQwValue < -9999)
		{
			system_msg_to_role(pstRole, "坐牢时间设置的太长，请最好设置48小时以下。\n");
			return -1;
		}
		
		short nAddValue = -pstTargetRole->stPKInfo.nPKValue+iQwValue;		
		set_role_pk_value(pstTargetRole, nAddValue); 

		//如果没有通过直接修改PK进入监狱，则强行拉角色进入监狱
		if(0 != is_commstat(pstTargetRole, RES_COMMSTAT_PK_JAIL))
		{
			return throw_to_jail(pstTargetRole);
		}
	}

	return 0;
}

int gm_show_role_info(LPROLE pstRole,const char *pszArg)
{	
	if(NULL == pszArg)
	{
		return -1;
	}

	char szMsg[1024] = { 0};
	unsigned int zid = 0;	

	unsigned int ulProcID = get_sys_entityid();

	unsigned int ulRoleID = 0;
	get_role_id_by_gid(&ulRoleID,pstRole->ullGID);	
	snprintf(szMsg,sizeof(szMsg),"role(%u:%s) objectid:%u gid:%lld :roleid:%d at pworldid(%d) mapid(%d) pos(%d:%d) birthzone:%d zoneid:%s",pstRole->ulUin,pstRole->szName,pstRole->stObject.ulID,
		pstRole->ullGID,ulRoleID,MAP_INST_ID_TO_PWORLD_ID(pstRole->stObject.stMapInstIndex.ullID),MAP_INST_ID_TO_MAP_ID(pstRole->stObject.stMapInstIndex.ullID),pstRole->stObject.stPos.x,pstRole->stObject.stPos.y,pstRole->ucBirthZone,get_proc_str_by_id(ulProcID));		
	system_msg_to_role(pstRole,szMsg);
	if(is_role_at_pworld(pstRole))
	{
		LPPWORLDINST pstPworldInst = find_pworld_inst_by_index(&pstRole->stRolePworldInfo.stPworldInstIndex);
		snprintf(szMsg,sizeof(szMsg),"pworld type:%d pworld level:%d pworld mode:%d cycle:%d deathnum:%d useditem:%d",pstPworldInst->stPworldStat.chPworldType,
				pstPworldInst->stPworldStat.chLevel,pstPworldInst->stPworldStat.chMode,
		pstPworldInst->stPworldStat.chCycle,pstPworldInst->stPworldStat.wDeathNum,pstPworldInst->stPworldStat.iUsedConsumeItemNum);		
		system_msg_to_role(pstRole,szMsg);
	}	

	// 显示玩家周围怪物列表 (monster resid objectid)
	// 显示玩家在地图还是副本	

	int iPos = 0;	
	LPMONSTER pstMon = NULL;
	LPITEM pstItem = NULL;	
	LPPET pstPet = NULL;
	LPROLE pstTmpRole = NULL;

       // for( i = 0; i <pstRole->iVRefer; i++)
       FOREACHVISIONPARAMS stParams;
	foreach_vision_object(&pstRole->stVRefer, &stParams, FOREACH_VISION_OBJECT_INIT);
	while((zid=foreach_vision_object(&pstRole->stVRefer, &stParams, FOREACH_VISION_OBJECT_GET)) > 0)
	{
		char chType = zid_to_type(zid);
		iPos = zid_to_pos(zid, chType);
		if(iPos < 0)
		{
			system_msg_to_role(pstRole,"invalid role refer obj pos.");
			continue;
		}		
		switch(chType)
		{
			case OBJ_MONSTER:
				pstMon = pos_to_monster(iPos);
				if(pstMon != NULL)
				{
					snprintf(szMsg,sizeof(szMsg),"vision: monster resid:%d monster objectid:%u listid:%d flag:%d status:%d",
							pstMon->iID,pstMon->stObject.ulID,pstMon->iListID,pstMon->chFlag,pstMon->chStatus);
					system_msg_to_role(pstRole,szMsg);
					snprintf(szMsg,sizeof(szMsg),"I:--:npcresid:%d birthpos:(%d:%d) dir:%d createtype:%d",pstMon->iNPCResID,pstMon->stOriginalPos.x,pstMon->stOriginalPos.y,pstMon->bOriginDirection,pstMon->bCreateType);
					system_msg_to_role(pstRole,szMsg);
					snprintf(szMsg,sizeof(szMsg),"II:===:next refresh time:%s:body cleartime:%s curhp:%d curmp:%d patroalspeed:%d gathernum:%d",ctime(&pstMon->tRefresh),ctime(&pstMon->tClearBody),pstMon->iCurHP,pstMon->iCurMP,pstMon->nPatrolSpeed,pstMon->nGatherNum);
					system_msg_to_role(pstRole,szMsg);
					snprintf(szMsg,sizeof(szMsg),"III:=====:movespeed:%d level:%d maxhp:%d maxmp:%d xp:%d degree:%d hide:%d ",get_monster_movespeed(pstMon),get_monster_level(pstMon),get_monster_maxhp(pstMon),get_monster_maxmp(pstMon),get_monster_xp(pstMon),get_monster_degree(pstMon),get_monster_hide(pstMon));
					system_msg_to_role(pstRole,szMsg);
	
				}
				break;
			case OBJ_ITEM:
				{
					pstItem = pos_to_item(iPos);
					if(pstItem != NULL)
					{
						snprintf(szMsg,sizeof(szMsg),"vision:item resid:%d objectid:%u pos(%d:%d)",pstItem->stData.stItem.iResId,pstItem->stObject.ulID,pstItem->stObject.stPos.x,pstItem->stObject.stPos.y);
						system_msg_to_role(pstRole,szMsg);
					}
					break;

				}
			case OBJ_PET:
				{
					pstPet = pos_to_pet(iPos);
					if(pstPet != NULL)
					{
						if (zid != pstPet->stObject.ulID)
						{	
							log_info(LOG_ERR,"%s:zid(%u) != pstPet->stObject.ulID(%u)",__FUNCTION__,zid,pstPet->stObject.ulID);
							break;
						}
						LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
						if(pstZonePetItem != NULL)
						{
							snprintf(szMsg,sizeof(szMsg),"vision: pet resid:%d owner uin:%u",pstZonePetItem->stPetItem.iResId,pstPet->ulUin);
							system_msg_to_role(pstRole,szMsg);
						}
					}
					break;
				}
			case OBJ_ROLE:
				{
					pstTmpRole = pos_to_role(iPos);
					if(pstTmpRole != NULL)
					{
						snprintf(szMsg,sizeof(szMsg),"vision: role(%u:%s)",pstTmpRole->ulUin,pstTmpRole->szName);	
						system_msg_to_role(pstRole,szMsg);
					}
					break;
				}
		}
	}
	snprintf(szMsg,sizeof(szMsg), "role refer num:%d", get_vision_object_total_num(&pstRole->stVRefer));			
	system_msg_to_role(pstRole,szMsg);		

	foreach_vision_object(&pstRole->stVCare, &stParams, FOREACH_VISION_OBJECT_INIT);	
	while((zid=foreach_vision_object(&pstRole->stVCare, &stParams, FOREACH_VISION_OBJECT_GET)) > 0)
	{
		char chType = zid_to_type(zid);
		iPos = zid_to_pos(zid, chType);
		if(iPos < 0)
		{
			system_msg_to_role(pstRole,"invalid role care obj pos.");
			continue;
		}		
		switch(chType)
		{
			case OBJ_MONSTER:
				pstMon = pos_to_monster(iPos);
				if(pstMon != NULL)
				{
					snprintf(szMsg,sizeof(szMsg),"care: monster resid:%d monster objectid:%u listid:%d flag:%d status:%d",
							pstMon->iID,pstMon->stObject.ulID,pstMon->iListID,pstMon->chFlag,pstMon->chStatus);
					system_msg_to_role(pstRole,szMsg);
				}
				break;
			case OBJ_ITEM:
				{
					pstItem = pos_to_item(iPos);
					if(pstItem != NULL)
					{
						snprintf(szMsg,sizeof(szMsg),"care:item resid:%d objectid:%u pos(%d:%d)",pstItem->stData.stItem.iResId,pstItem->stObject.ulID,pstItem->stObject.stPos.x,pstItem->stObject.stPos.y);
						system_msg_to_role(pstRole,szMsg);
					}
					break;

				}
			case OBJ_PET:
				{
					pstPet = pos_to_pet(iPos);
					if(pstPet != NULL)
					{
						LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
						if(pstZonePetItem != NULL)
						{
							snprintf(szMsg,sizeof(szMsg),"care: pet resid:%d owner uin:%u",pstZonePetItem->stPetItem.iResId,pstPet->ulUin);
							system_msg_to_role(pstRole,szMsg);
						}
					}
					break;
				}
			case OBJ_ROLE:
				{
					pstTmpRole = pos_to_role(iPos);
					if(pstTmpRole != NULL)
					{
						snprintf(szMsg,sizeof(szMsg),"care: role(%u:%s)",pstTmpRole->ulUin,pstTmpRole->szName);	
						system_msg_to_role(pstRole,szMsg);
					}
					break;
				}

		}
	}

	snprintf(szMsg,sizeof(szMsg),"role care num:%d", get_vision_object_total_num(&pstRole->stVCare));
	system_msg_to_role(pstRole,szMsg);

	// 显示副本的等级和模式

/**
	char szTemp[128];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole,"setpworldlevel <levelid> <modeid>");
		return -1;
	}
	int iLevel = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole,"setlevel <levelid> <modeid>");
		return -1;
	}
	int iMode = atoi(szTemp);

	CSPWORLDSETLEVEL stSetLevel;
	stSetLevel.chLevel = (char)iLevel;
	stSetLevel.chMode = (char)iMode;
	if(role_set_pworld_level(pstRole,&stSetLevel)!= CS_CODE_NOERR)
	{
		system_msg_to_role(pstRole,"set pworld level failed.");
		return -1;
	}
*/
	return 0;
}

static void guild_help(LPROLE pstRole)
{
	system_msg_to_role(pstRole, "//guild create ");	//创建家族
	system_msg_to_role(pstRole, "//guild delelet ");				//删除家族
	system_msg_to_role(pstRole, "//guild dump");			//在后台log中打印家族的所有数据库信息
	system_msg_to_role(pstRole, "//guild dumpall");			//在后台log中打印家族的所有数据库信息
	system_msg_to_role(pstRole, "//guild list ");	//列出家族的所有成员
	system_msg_to_role(pstRole, "//guild setlevel <ID> <Level> ");			//增加家族及技能的升级
	system_msg_to_role(pstRole, "//guild raisetime <ID> <AddTime>");			//增加家族及技能的升级
	system_msg_to_role(pstRole, "//guild resetreckon");			//清除本周的结算信息
	system_msg_to_role(pstRole, "//guild addgold <Num>");			//增加家族金券
	system_msg_to_role(pstRole, "//guild adddish <DishID> <Pos> ");			//设置一个菜肴给家族的某个位置
	system_msg_to_role(pstRole, "//guild showdish");			//显示当前家族的所有菜肴
	system_msg_to_role(pstRole, "//guild addstuff <StuffID> <Num>");			//增加家族材料
	system_msg_to_role(pstRole, "//guild resetblesstime");			//重置后台的开始祈福时间，这样可以在一天内进行多次祈福任务
	system_msg_to_role(pstRole, "//guild resetdinnertime");			//重置后台的开始聚餐时间，这样可以在一天内进行多次聚餐
	system_msg_to_role(pstRole, "//guild showblesstime");			//祈福任务开始，查看祈福任务的进行状态。
	system_msg_to_role(pstRole, "//guild showdinnertime");			//查看聚餐任务的进行状态
	system_msg_to_role(pstRole, "//guild blesstime <Hour> <Min>");			//设置家族的祈福时间，只有族长可以设置
	system_msg_to_role(pstRole, "//guild dinnertime <Weekday> <Hour> <Min>");			//设置家族的聚餐时间，只有族长可以设置
	system_msg_to_role(pstRole, "//guild entersceen ");			//进入某一个家族场景的家族场景，如果不指定家族，默认进入自己的家族场景
	system_msg_to_role(pstRole, "//guild maint");				//进行家族维护
	system_msg_to_role(pstRole, "//guild maintinfo");				//进行家族维护
	system_msg_to_role(pstRole, "//guild maintlack");				//进行家族维护
	system_msg_to_role(pstRole, "//guild addbuildlevel");				//进行家族维护
	system_msg_to_role(pstRole, "//guild addfriendly");				//增加家族友好度
	system_msg_to_role(pstRole, "//guild startime");				//设置家族之星的下次更新时间
	system_msg_to_role(pstRole, "//guild setstar");				//设置家族之星，或取消家族之星
	system_msg_to_role(pstRole, "//guild swap");				//设置家族之星，或取消家族之星
	system_msg_to_role(pstRole, "//guild querylifetree"); //查询家族生命树
	system_msg_to_role(pstRole, "//guild changelifetree"); //改变家族生命树
	
	system_msg_to_role(pstRole, "//guildrole showquestion");			//显示祈福问题
	system_msg_to_role(pstRole, "//guildrole addcontribute <Num>");			//增加家族贡献度
	system_msg_to_role(pstRole, "//guildrole addlastcontribute <Num>");			//增加上周家族贡献度
	system_msg_to_role(pstRole, "//guildrole addmutupoint <Num>");			//增加家族互助点
	system_msg_to_role(pstRole, "//guildrole mutulpointtime <AddTimeSec>");			//修改上次互助点的发放时间
	system_msg_to_role(pstRole, "//guildrole resetroleblesstime");			//清除角色今天的祈福记录
	system_msg_to_role(pstRole, "//guildrole resetroledinnertime");			//清除角色本周的聚餐记录
	system_msg_to_role(pstRole, "//guildrole chgmutualtasktime <AddTimeSec>");			//修改互助任务的接收时间
	system_msg_to_role(pstRole, "//guildrole join <guild_name>");	//加入招募状态为: Open的家族
	
}

//分解命令
#define TMP_GUILD_CMD_CREATE 1
#define TMP_GUILD_CMD_DEL 2
#define TMP_GUILD_CMD_DUMP 3
#define TMP_GUILD_CMD_DUMPALL 4
#define TMP_GUILD_CMD_LIST 5
#define TMP_GUILD_CMD_SETLEVEL 6
#define TMP_GUILD_CMD_RAISE_TIME 7
#define TMP_GUILD_CMD_RESET_RECHKON 8
#define TMP_GUILD_CMD_ADD_GOLD 9
#define TMP_GUILD_CMD_ADD_DISH 10
#define TMP_GUILD_CMD_SHOW_DISH 11
#define TMP_GUILD_CMD_ADD_STUFF 12
#define TMP_GUILD_CMD_SHOW_BLESSTIME 13
#define TMP_GUILD_CMD_BLESSTIME 14
#define TMP_GUILD_CMD_RESET_BLESSTIME 15
#define TMP_GUILD_CMD_SHOW_DINNERTIME 16
#define TMP_GUILD_CMD_DINNERTIME 17
#define TMP_GUILD_CMD_RESET_DINNERTIME 18
#define TMP_GUILD_CMD_SHOW_QUESTION 19
#define TMP_GUILD_CMD_ADD_CONTRIBUTE 20
#define TMP_GUILD_CMD_ADD_LAST_CONTRIBUTE 21
#define TMP_GUILD_CMD_ADD_MUTUAL_POINT 22
#define TMP_GUILD_CMD_MUTUAL_POINT_TIME 23
#define TMP_GUILD_CMD_ENTERSCEEN 24
#define TMP_GUILD_CMD_RESET_ROLE_BLESSTIME 25
#define TMP_GUILD_CMD_RESET_ROLE_DINNERTIME 26
#define TMP_GUILD_CMD_CHG_MUTUALTASK_TIME 27
#define TMP_GUILD_CMD_JOIN 28
#define TMP_GUILD_CMD_MAINT 29
#define TMP_GUILD_CMD_MAINTINFO 30
#define TMP_GUILD_CMD_MAINTLACK 31
#define TMP_GUILD_CMD_ADD_BUILDLEVEL 32
#define TMP_GUILD_CMD_ADD_FRIENDLY 33
#define TMP_GUILD_CMD_FLAG 34
#define TMP_GUILD_CMD_EVALUATE_STAR_TIME 35
#define TMP_GUILD_CMD_SET_STAR 36
#define TMP_GUILD_CMD_SWAPPING_MEMBER 37
#define TMP_GUILD_CMD_SET_MEMBER_JOB 38
#define TMP_GUILD_CMD_SET_VOTE 39
#define TMP_GUILD_CMD_ADD_LAMP 40
#define TMP_GUILD_CMD_RESET_LAMP 41
#define TMP_GUILD_CMD_ADD_LAMP_TIME 42
#define TMP_GUILD_CMD_REMOVE_MUTUAL 43
#define TMP_GUILD_CMD_ENTER_GUILDPWORLD 44
#define TMP_GUILD_CMD_MID_CONDITION 45
#define TMP_GUILD_CMD_CLEAR_LAMPITEM_RECORD 46
#define TMP_GUILD_CMD_LIST_LAMPITEM_RECORD 47
#define TMP_GUILD_CMD_SET_LAMP_TIME 48
#define TMP_GUILD_CMD_LAST_LOGIN_TIME 49
#define TMP_GUILD_CMD_JOIN_TIME 50
#define TMP_GUILD_CMD_RESET_VOTEMASTER 51
#define TMP_GUILD_CMD_RECKON_VOTEMASTER 52
#define TMP_GUILD_CMD_WAR 53
#define TMP_GUILD_CMD_QUERYLIFETREE 54
#define TMP_GUILD_CMD_CHANGELIFETREE 55
static int gm_distill_guild_cmd(const char* ppszCmd)
{
	if(NULL == ppszCmd || !ppszCmd[0])
	{
		return 0;
	}
	if(!strncasecmp(ppszCmd, "help", sizeof("help")))
	{
		return 0;
	}
	else if(!strncasecmp(ppszCmd, "create", sizeof("create")))
	{
		return TMP_GUILD_CMD_CREATE;
	}
	else if(!strncasecmp(ppszCmd, "delete", sizeof("delete")))
	{
		return TMP_GUILD_CMD_DEL;
	}
	else if(!strncasecmp(ppszCmd, "dump", sizeof("dump")))
	{
		return TMP_GUILD_CMD_DUMP;
	}
	else if(!strncasecmp(ppszCmd, "dumpall", sizeof("dumpall")))
	{
		return TMP_GUILD_CMD_DUMPALL;
	}
	else if(!strncasecmp(ppszCmd, "list", sizeof("list")))
	{
		return TMP_GUILD_CMD_LIST;
	}
	else if(!strncasecmp(ppszCmd, "setlevel", sizeof("setlevel")))
	{
		return TMP_GUILD_CMD_SETLEVEL;
	}
	else if(!strncasecmp(ppszCmd, "raisetime", sizeof("raisetime")))
	{
		return TMP_GUILD_CMD_RAISE_TIME;
	}
	else if(!strncasecmp(ppszCmd, "resetreckon", sizeof("resetreckon")))
	{
		return TMP_GUILD_CMD_RESET_RECHKON;
	}
	else if(!strncasecmp(ppszCmd, "addgold", sizeof("addgold")))
	{
		return TMP_GUILD_CMD_ADD_GOLD;
	}
	else if(!strncasecmp(ppszCmd, "adddish", sizeof("adddish")))
	{
		return TMP_GUILD_CMD_ADD_DISH;
	}
	else if(!strncasecmp(ppszCmd, "showdish", sizeof("showdish")))
	{
		return TMP_GUILD_CMD_SHOW_DISH;
	}
	else if(!strncasecmp(ppszCmd, "addstuff", sizeof("addstuff")))
	{
		return TMP_GUILD_CMD_ADD_STUFF;
	}
	else if(!strncasecmp(ppszCmd, "resetblesstime", sizeof("resetblesstime")))
	{
		return TMP_GUILD_CMD_RESET_BLESSTIME;
	}
	else if(!strncasecmp(ppszCmd, "resetdinnertime", sizeof("resetdinnertime")))
	{
		return TMP_GUILD_CMD_RESET_DINNERTIME;
	}
	else if(!strncasecmp(ppszCmd, "showblesstime", sizeof("showblesstime")))
	{
		return TMP_GUILD_CMD_SHOW_BLESSTIME;
	}
	else if(!strncasecmp(ppszCmd, "showdinnertime", sizeof("showdinnertime")))
	{
		return TMP_GUILD_CMD_SHOW_DINNERTIME;
	}
	else if(!strncasecmp(ppszCmd, "blesstime", sizeof("blesstime")))
	{
		return TMP_GUILD_CMD_BLESSTIME;
	}
	else if(!strncasecmp(ppszCmd, "dinnertime", sizeof("dinnertime")))
	{
		return TMP_GUILD_CMD_DINNERTIME;
	}
	else if(!strncasecmp(ppszCmd, "showquestion", sizeof("showquestion")))
	{
		return TMP_GUILD_CMD_SHOW_QUESTION;
	}
	else if(!strncasecmp(ppszCmd, "addcontribute", sizeof("addcontribute")))
	{
		return TMP_GUILD_CMD_ADD_CONTRIBUTE;
	}
	else if(!strncasecmp(ppszCmd, "addlastcontribute", sizeof("addlastcontribute")))
	{
		return TMP_GUILD_CMD_ADD_LAST_CONTRIBUTE;
	}
	else if(!strncasecmp(ppszCmd, "addmutupoint", sizeof("addmutupoint")))
	{
		return TMP_GUILD_CMD_ADD_MUTUAL_POINT;
	}
	else if(!strncasecmp(ppszCmd, "mutulpointtime", sizeof("mutulpointtime")))
	{
		return TMP_GUILD_CMD_MUTUAL_POINT_TIME;
	}
	else if(!strncasecmp(ppszCmd, "entersceen", sizeof("entersceen")))
	{
		return TMP_GUILD_CMD_ENTERSCEEN;
	}
	else if(!strncasecmp(ppszCmd, "resetroleblesstime", sizeof("resetroleblesstime")))
	{
		return TMP_GUILD_CMD_RESET_ROLE_BLESSTIME;
	}
	else if(!strncasecmp(ppszCmd, "resetroledinnertime", sizeof("resetroledinnertime")))
	{
		return TMP_GUILD_CMD_RESET_ROLE_DINNERTIME;
	}
	else if(!strncasecmp(ppszCmd, "chgmutualtasktime", sizeof("chgmutualtasktime")))
	{
		return TMP_GUILD_CMD_CHG_MUTUALTASK_TIME;
	}
	else if(!strncasecmp(ppszCmd, "join", sizeof("join")))
	{
		return TMP_GUILD_CMD_JOIN;
	}
	else if(!strncasecmp(ppszCmd, "maint", sizeof("maint")))
	{
		return TMP_GUILD_CMD_MAINT;
	}
	else if(!strncasecmp(ppszCmd, "maintinfo", sizeof("maintinfo")))
	{
		return TMP_GUILD_CMD_MAINTINFO;
	}
	else if(!strncasecmp(ppszCmd, "maintlack", sizeof("maintlack")))
	{
		return TMP_GUILD_CMD_MAINTLACK;
	}
	else if(!strncasecmp(ppszCmd, "addbuildlevel", sizeof("addbuildlevel")))
	{
		return TMP_GUILD_CMD_ADD_BUILDLEVEL;
	}
	else if(!strncasecmp(ppszCmd, "addfriendly", sizeof("addfriendly")))
	{
		return TMP_GUILD_CMD_ADD_FRIENDLY;
	}
	else if(!strncasecmp(ppszCmd, "flag", sizeof("flag")))
	{
		return TMP_GUILD_CMD_FLAG;
	}
	else if(!strncasecmp(ppszCmd, "startime", sizeof("startime")))
	{
		return TMP_GUILD_CMD_EVALUATE_STAR_TIME;
	}
	else if(!strncasecmp(ppszCmd, "setstar", sizeof("setstar")))
	{
		return TMP_GUILD_CMD_SET_STAR;
	}
	else if(!strncasecmp(ppszCmd, "swap", sizeof("swap")))
	{
		return TMP_GUILD_CMD_SWAPPING_MEMBER;
	}
	else if(!strncasecmp(ppszCmd, "setjob", sizeof("setjob")))
	{
		return TMP_GUILD_CMD_SET_MEMBER_JOB;
	}
	else if(!strncasecmp(ppszCmd, "setvote", sizeof("setvote")))
	{
		return TMP_GUILD_CMD_SET_VOTE;
	}
	else if(!strncasecmp(ppszCmd, "addlamp", sizeof("addlamp")))
	{
		return TMP_GUILD_CMD_ADD_LAMP;
	}
	else if(!strncasecmp(ppszCmd, "resetlamp", sizeof("resetlamp")))
	{
		return TMP_GUILD_CMD_RESET_LAMP;
	}
	else if(!strncasecmp(ppszCmd, "addlamptime", sizeof("addlamptime")))
	{
		return TMP_GUILD_CMD_ADD_LAMP_TIME;
	}
	else if(!strncasecmp(ppszCmd, "removemutu", sizeof("removemutu")))
	{
		return TMP_GUILD_CMD_REMOVE_MUTUAL;
	}
	else if(!strncasecmp(ppszCmd, "act", sizeof("act")))
	{
		return TMP_GUILD_CMD_ENTER_GUILDPWORLD;
	}
	else if(!strncasecmp(ppszCmd, "mid", sizeof("mid")))
	{
		return TMP_GUILD_CMD_MID_CONDITION;
	}
	else if(!strncasecmp(ppszCmd, "clearlamprecord", sizeof("clearlamprecord")))
	{
		return TMP_GUILD_CMD_CLEAR_LAMPITEM_RECORD;
	}
	else if(!strncasecmp(ppszCmd, "listlamprecord", sizeof("listlamprecord")))
	{
		return TMP_GUILD_CMD_LIST_LAMPITEM_RECORD;
	}
	else if(!strncasecmp(ppszCmd, "setlamptime", sizeof("setlamptime")))
	{
		return TMP_GUILD_CMD_SET_LAMP_TIME;
	}
	else if(!strncasecmp(ppszCmd, "lastlongintime", sizeof("lastlongintime")))
	{
		return TMP_GUILD_CMD_LAST_LOGIN_TIME;
	}
	else if(!strncasecmp(ppszCmd, "jointime", sizeof("jointime")))
	{
		return TMP_GUILD_CMD_JOIN_TIME;
	}
	else if(!strncasecmp(ppszCmd, "resetmasterelect", sizeof("resetmasterelect")))
	{
		return TMP_GUILD_CMD_RESET_VOTEMASTER;
	}
	else if(!strncasecmp(ppszCmd, "reckonmasterelect", sizeof("reckonmasterelect")))
	{
		return TMP_GUILD_CMD_RECKON_VOTEMASTER;
	}
	else if(!strncasecmp(ppszCmd, "war", sizeof("war")))
	{
		return TMP_GUILD_CMD_WAR;
	}
	else if (!strncasecmp(ppszCmd, "querylifetree", sizeof("querylifetree")))
	{
		return TMP_GUILD_CMD_QUERYLIFETREE;
	}
	else if (!strncasecmp(ppszCmd, "changelifetree", sizeof("changelifetree")))
	{
		return TMP_GUILD_CMD_CHANGELIFETREE;
	}

	
	return 0;
}

int gm_guildrole(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	/*提取操作对象*/
	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole  != NULL)
	{
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
			pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szGMMsgTemp);
	}
	else
	{
		pstDestRole = pstRole;
	}

	CSGUILDC stGuildC;
	char szTemp[128];
	char szCMD[128];
	char chCmd = 0;
	int iRet = 0;

	
	LPGUILD pstGuild = get_role_guild(pstDestRole);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	chCmd = gm_distill_guild_cmd(szTemp);
	switch(chCmd)
	{
		case TMP_GUILD_CMD_SHOW_QUESTION:
		{
			int iQuestionID=0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole,  "No question input!");
				return -1;
			}
			
			iQuestionID = atoi(szTemp);
	
			LPRESQUESTION pstResQues = find_question_def_by_id(iQuestionID);
			if(pstResQues == NULL )
			{
				snprintf(szTemp, 128, "find not question for id[%d]!",iQuestionID);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}

			CSGUILDS stGuildS;
			memset(&stGuildS,0,sizeof(stGuildS));
			stGuildS.nEno = 0;
			stGuildS.chOperation = GUILD_OP_INFO_CHANGE;
			stGuildS.stData.stGuildInfoChange.bGuildInfoChangeType = GUILD_INFOCHG_BLESS_QUESTION;
			LPCSGUILDBLESSQUESTIONCHGS pstBlessQuesChg = &stGuildS.stData.stGuildInfoChange.stGuildInfoChangeData.stBlessQuestionChg;
			
			pstBlessQuesChg->chState = GUILD_BLESS_QUESTION_STATE_ASK;
			pstBlessQuesChg->chTotalNum = 1;
			pstBlessQuesChg->chRightNum = 0;
			pstBlessQuesChg->ullAnswererGID = pstDestRole->ullGID;
			memcpy(pstBlessQuesChg->szAnswererName, pstDestRole->szName,sizeof(pstBlessQuesChg->szAnswererName));
			
			pstBlessQuesChg->iQuestionID = iQuestionID;
			pstBlessQuesChg->chKeyNum = pstResQues->chKeyNum;
			memcpy(pstBlessQuesChg->szAsk, pstResQues->szAsk, RES_MAX_QUESTION_CONTENT_LEN);
			memcpy(pstBlessQuesChg->aszAnswers[0], pstResQues->aszAnswers[0],pstResQues->chKeyNum * RES_MAX_QUESTION_CONTENT_LEN);
			
			guild_protocol_proxy_send_res(pstDestRole->ulUin, NULL, &stGuildS);
			break;	
		}
		case TMP_GUILD_CMD_ENTER_GUILDPWORLD:
		{
			int iActID = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole,  "No ActiID input!");
				return -1;
			}
			
			iActID = atoi(szTemp);

			role_enter_guild_multiact_pworld(pstDestRole, iActID);
			break;
		}
		case TMP_GUILD_CMD_SET_VOTE:
		{
			int iVoteNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole,  "No Vote Num input!");
				return -1;
			}
			iVoteNum = atoi(szTemp);

			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			pstMember->stZoneGuildMember.stGuildHonor.wWeekNum = iVoteNum;
			
			snprintf(szTemp, 128, "role[%u %s] VoteNum Set to[%d]!",pstDestRole->ulUin,pstDestRole->szName,pstMember->stZoneGuildMember.stGuildHonor.wWeekNum);
			system_msg_to_role(pstRole, szTemp);
			
			break;
		}
		case TMP_GUILD_CMD_LAST_LOGIN_TIME:
		{
			int iLoginDays = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole,  "No Login Days input!");
				return -1;
			}
			iLoginDays = atoi(szTemp);

			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			pstMember->stZoneGuildMember.stBaseInfo.ulLastLoginTime += iLoginDays * 86400;
			
			snprintf(szTemp, 128, "role[%u %s] LastLoginTime Set to[%s]!",pstDestRole->ulUin,pstDestRole->szName,compactdatetime(pstMember->stZoneGuildMember.stBaseInfo.ulLastLoginTime));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_JOIN_TIME:
		{
			int iJoinDays = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole,  "No Join Days input!");
				return -1;
			}
			iJoinDays = atoi(szTemp);

			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			pstMember->stZoneGuildMember.stBaseInfo.iJoinTime += iJoinDays * 86400;
			
			snprintf(szTemp, 128, "role[%u %s] JoinGuildTime Set to[%s]!",pstDestRole->ulUin,pstDestRole->szName,compactdatetime(pstMember->stZoneGuildMember.stBaseInfo.iJoinTime));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_RESET_VOTEMASTER:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			pstMember->stZoneGuildMember.stMemberForElect.iReferTime = 0;
			
			snprintf(szTemp, 128, "role[%u %s] reset master elect time!",pstDestRole->ulUin,pstDestRole->szName);
			system_msg_to_role(pstRole, szTemp);
			break;
		}		

		case TMP_GUILD_CMD_ADD_CONTRIBUTE:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iContribute = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iContribute = atoi(szTemp);
			}
			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}

			change_member_contribution(pstGuild,pstDestRole, pstMember, iContribute);
			
			snprintf(szTemp, 128, "role contribute Total[%u] Cur[%u],  Week %d LastWeek %d", 
				pstMember->stZoneGuildMember.stContribute.ulSumContribute,
				pstMember->stZoneGuildMember.stContribute.ulCurContribute,
				pstMember->stZoneGuildMember.stContribute.wWeekContribute,
				pstMember->stZoneGuildMember.stContribute.wLastWeekContribute);
			system_msg_to_role(pstRole, szTemp);
			break;	
		}
		case TMP_GUILD_CMD_ADD_LAST_CONTRIBUTE:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iContribute = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iContribute = atoi(szTemp);
			}
			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}


			if(pstMember->stZoneGuildMember.stContribute.wLastWeekContribute  +  iContribute < 0 ||
				iContribute > 100000)
			{
				system_msg_to_role(pstRole, "设定的数目非法");
				return -1;
			}
			
			pstMember->stZoneGuildMember.stContribute.wLastWeekContribute += iContribute;
			pstGuild->stGuildData.stBuildLevelInfo.ulLastWeekBuildLevel += iContribute;
			snprintf(szTemp, 128, "role contribute  Total[%u] Cur[%u]  Week %d LastWeek %d", 
				pstMember->stZoneGuildMember.stContribute.ulSumContribute,
				pstMember->stZoneGuildMember.stContribute.ulCurContribute,
				pstMember->stZoneGuildMember.stContribute.wWeekContribute,
				pstMember->stZoneGuildMember.stContribute.wLastWeekContribute);
			system_msg_to_role(pstRole, szTemp);

			break;	
		}
		case TMP_GUILD_CMD_ADD_MUTUAL_POINT:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iMutualPoint = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iMutualPoint = atoi(szTemp);
			}
			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}

			change_member_mutualpoint(pstDestRole,pstMember,iMutualPoint);
			snprintf(szTemp, 128, "role mutupoint is %d", get_member_mutualpoint(pstDestRole, pstMember));
			system_msg_to_role(pstRole, szTemp);

			break;	
		}
		case TMP_GUILD_CMD_MUTUAL_POINT_TIME:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iMutualTime = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iMutualTime = atoi(szTemp);
			}
			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			
			pstDestRole->stGuildMemberData.stGuildForRole.ulLastMutuPoinTime += iMutualTime;
			snprintf(szTemp, 128, "role end mututime is %s", compactdatetime(pstDestRole->stGuildMemberData.stGuildForRole.ulLastMutuPoinTime));
			system_msg_to_role(pstRole, szTemp);
			break;	
		}
		
		case TMP_GUILD_CMD_RESET_ROLE_BLESSTIME:
		{
			pstDestRole->stGuildMemberData.stGuildForRole.ulLastBlessTime = 0;
			system_msg_to_role(pstRole, "Reset Last Bless Time to 0.");
			break;	
		}
		case TMP_GUILD_CMD_RESET_ROLE_DINNERTIME:
		{

			pstDestRole->stGuildMemberData.stGuildForRole.ulLastDinnerTime= 0;
			system_msg_to_role(pstRole, "Reset Last Dinner Time to 0.");
			break;	
		}
		case TMP_GUILD_CMD_CHG_MUTUALTASK_TIME:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iMutualTime = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iMutualTime = atoi(szTemp);
			}
			LPGUILDMEMBER pstMember = get_guild_member(pstGuild, pstDestRole->ullGID, &pstDestRole->stGuildMemberData.stGuildForRole);
			if(NULL == pstMember)
			{
				snprintf(szTemp, 128, "guild find not member for role[%u %s]!",pstDestRole->ulUin,pstDestRole->szName);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}

			LPTASK pstTask = get_task_by_type(&pstDestRole->stTaskData.stTaskManagement, TASK_TYPE_GUILD_MUTUAL);
			if(NULL == pstTask)
			{
				system_msg_to_role(pstRole, "no task find");
				return -1;
			}
			pstTask->ulAcceptTime += iMutualTime;
			pstTask->ulLastCountTime += iMutualTime;
			system_msg_to_role(pstRole, "修改互助任务的接收时间，请下线重新上线生效");
			break;	
		}
		case TMP_GUILD_CMD_SET_LAMP_TIME:
		{
			if(pstGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				iRet = -1;
				break;
			}

			int iUseLampTimes = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iUseLampTimes = atoi(szTemp);
			}

			pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wProtectLamp = iUseLampTimes;

			snprintf(szTemp, 128, "Role UseLamp Times Change to[%d]",pstDestRole->stAchievement.stAchieveData.stTitleAssisInfo.wProtectLamp);
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_JOIN:
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				system_msg_to_role(pstRole, "no guild appoint");
				return -1;			
			}
			pstGuild = get_guild_by_name(szTemp);
			if(NULL == pstGuild)
			{
				system_msg_to_role(pstRole, "no guild find for join in");
				return -1;
			}
			
			stGuildC.nOperation = GUILD_OP_APPLY;
			stGuildC.stData.stGuildApply.bApplyType = CS_GUILD_APPLY_DIRECTLY;
			stGuildC.stData.stGuildApply.stApplyData.ullGuildGID = pstGuild->ullGID;
			int iRet = guild_protocol_proxy_get_cs_req(pstDestRole, &stGuildC);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "insert role to guild error(error code %d)", iRet);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			break;	
		}
		case TMP_GUILD_CMD_WAR:
		{
			iRet = -1;			
			do
			{
				if(pstGuild == NULL)
				{
					system_msg_to_role(pstRole,  "find not guild");
					break;
				}
				
				gm_get_val(&pszArg,szCMD,sizeof(szCMD));
				if(szCMD[0] == 0)
				{
					break;
				}

				int iParam = 0, iParam2 = 0;
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(szTemp[0])
				{
					iParam = atoi(szTemp);
					gm_get_val(&pszArg,szTemp,sizeof(szTemp));
					if(szTemp[0])
					{
						iParam2 = atoi(szTemp);
					}
				}
				
				if(!strncasecmp(szCMD, "enter", sizeof("enter")))
				{
					iRet = role_enter_guildwar_pworld(pstDestRole, iParam, get_guildwar_sppkey_by_guildgid(pstGuild->ullGID));
					break;
				}
				else if(!strncasecmp(szCMD, "addscore", sizeof("addscore")))
				{
					iRet = chg_role_guildwar_score(pstDestRole, iParam);
					break;
				}
				else if(!strncasecmp(szCMD, "join", sizeof("join")))
				{
					iRet = add_guildwar_join_data(pstDestRole,get_role_guild(pstDestRole),0);
					if(iRet < 0)
					{
						system_msg_to_role(pstRole,"Join Error");
					}
					else
					{
						system_msg_to_role(pstRole,"Join Successful");
					}

					break;
				}
				else if(!strncasecmp(szCMD, "showbattle", sizeof("showbattle")))
				{
					if(get_guildwar_step() != GUILD_WAR_STEP_BATTLE)
					{
						system_msg_to_role(pstRole,"Not In Battle State, No Info to show");
						break;
					}

					snprintf(szTemp, 128, "Kill[%d] InvalidKill[%d] CoverKill[%d] DoubleHit[%d] BeKill[%d].", 
						pstDestRole->stGuildMemberData.stGuildForRole.stGuildWarForRole.stCurBattle.nKill,
						pstDestRole->stGuildMemberData.stGuildForRole.stGuildWarForRole.stCurBattle.nInvalidKill,
						pstDestRole->stGuildMemberData.stGuildForRole.stGuildWarForRole.stCurBattle.nCoverKill,
						pstDestRole->stGuildMemberData.stGuildForRole.stGuildWarForRole.stCurBattle.nDoubleHit,
						pstDestRole->stGuildMemberData.stGuildForRole.stGuildWarForRole.stCurBattle.nBeKill);
					system_msg_to_role(pstRole, szTemp);

					iRet = 0;
					break;
				}
				else if(!strncasecmp(szCMD, "dumptower", sizeof("dumptower")))
				{
					dump_guildwar_towerinfo_by_role(pstDestRole);
					system_msg_to_role(pstRole,"Dump OK.");
					iRet = 0;
					break;
				}
				else if(!strncasecmp(szCMD, "pos", sizeof("pos")))
				{
					if(is_role_at_guildwar_sceen(pstRole) == 1)
					{
						LPMAPINST pstMapinst = find_map_inst_by_index(&pstDestRole->stObject.stMapInstIndex);
						POSITION stNewPos;
						stNewPos.x = iParam;
						stNewPos.y = iParam2;
						object_change_map(&pstDestRole->stObject,pstMapinst,&stNewPos,NULL);

						iRet = 0;
					}
					break;
				}
			}while(0);
			break;
		}
		default:
			guild_help( pstRole);
			break;
	}

	return iRet;
	
}

static int gm_guildwar_i(LPGUILD pstGuild,const char *pszArg, LPROLE pstGM)
{
	if(NULL == pszArg || NULL == pstGM)
	{
		return -1;
	}

	char szGMMsg[2048] ={0};
	char szCmd[128];
	int iRet = 0;
	
	//提取命令符
	gm_get_val(&pszArg,szCmd,sizeof(szCmd));
	if(szCmd[0] == 0)
	{
		return -1;
	}
	
	//提取参数 1 和 2	
	int iParam1 = 0, iParam2 = 0;
	char szTemp[128];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if((szTemp[0] != 0))
	{
		iParam1 = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if((szTemp[0] != 0))
		{
			iParam2 = atoi(szTemp);
		}
	}				

	//执行命令
	do{
			if(!strncasecmp(szCmd, "dumptower", sizeof("dumptower")))
			{
				if(pstGuild == NULL)
				{	
					snprintf(szGMMsg,sizeof(szGMMsg),"No Guild Input.");
					iRet = -1;
					break;
				}
				dump_guildwar_towerinfo_by_guild(pstGuild);
				snprintf(szGMMsg,sizeof(szGMMsg),"Dump Guild Tower Info Successful.");
				break;
			}
			else if(!strncasecmp(szCmd, "dumpdata", sizeof("dumpdata")))
			{
				dump_guildwar_pairs(1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Dump Guild War Data Successful.");
				break;
			}
			else if(!strncasecmp(szCmd, "dumprank", sizeof("dumprank")))
			{
				dump_guildwar_ranklist();
				snprintf(szGMMsg,sizeof(szGMMsg),"Dump Guild War Rank List Successful.");
				break;
			}
			else if(!strncasecmp(szCmd, "preparelenth", sizeof("preparelenth")))
			{
				set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILD_WAR_TIME_ID,0,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Set PrepareLenth To [%d] Min Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s]  Set PrepareLenth to[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,iParam1);
				break;
			}
			else if(!strncasecmp(szCmd, "warlenth", sizeof("warlenth")))
			{
				set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILD_WAR_TIME_ID,1,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Set War Lenth To [%d] Min Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s]  Set WarLenth to[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,iParam1);
				break;
			}
			else if(!strncasecmp(szCmd, "pairnum", sizeof("pairnum")))
			{
				set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILDWAR_LIMIT,0,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Set Rand Pairs Num To [%d] Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s]  Set PairNum to[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,iParam1);
				break;
			}
			else if(!strncasecmp(szCmd, "joinguild", sizeof("joinguild")))
			{
				if(iParam1 > MAX_GUILD_WAR_JOIN_NUM)
				{
					snprintf(szGMMsg,sizeof(szGMMsg),"Set Num Must Less Than [%d], Set Failed.",MAX_GUILD_WAR_JOIN_NUM);
					iRet = -1;
					break;
				}
				
				set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILDWAR_LIMIT,1,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Set Max Join Guild Num To [%d] Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s]  Set Join Guild Num to[%d].", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,iParam1);
				break;
			}
			else if(!strncasecmp(szCmd, "joinmember", sizeof("joinmember")))
			{
				if(iParam1 > CS_MAX_GUILD_WAR_MEMBER)
				{
					snprintf(szGMMsg,sizeof(szGMMsg),"Set Num Must Less Than [%d], Set Failed.",CS_MAX_GUILD_WAR_MEMBER);
					iRet = -1;
					break;
				}
				set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILDWAR_LIMIT,2,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Set Max Join Guild Member In Battle Num To [%d]  Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s]  Set Join Memerb Num to[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,iParam1);
				break;
			}
			else if(!strncasecmp(szCmd, "clearseason", sizeof("clearseason")))
			{
				on_get_guild_season_act_open(time(NULL));
				snprintf(szGMMsg,sizeof(szGMMsg)," Clear Season Successful.");
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Clear Season .", __FUNCTION__,	pstGM->ullGID,pstGM->szName);
				break;
			}
			else if(!strncasecmp(szCmd, "resetguildwar", sizeof("resetguildwar")))
			{
				iRet = on_get_gm_reset_guildwar(pstGM);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_WARN, "%s: Gm[%u %s] Rest All GuildWar Info.", __FUNCTION__,pstGM->ulUin,pstGM->szName);
				break;
			}
			else if(!strncasecmp(szCmd, "brief", sizeof("brief")))
			{
				LPGUILDWARDATA pstGuildWarCommData = (LPGUILDWARDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_GUILD_WAR);
				if (NULL == pstGuildWarCommData)
				{
					iRet = -1;
					break;
				}
				szGMMsg[0] = 0;
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"---------------------------------------------\n");
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"WarType[%s]\n",war_type_to_str(pstGuildWarCommData->chWarType));
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"SeasonTime[%s]\n",shortdatetime(pstGuildWarCommData->iSeasonTime));
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"Seasons[%d]\n",pstGuildWarCommData->nSeasons);
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"Rounds[%d]\n",pstGuildWarCommData->nRounds);
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"RankNum[%d]\n",pstGuildWarCommData->stRankList.nRankNum);
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"---------------------------------------------\n");
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"WatStep[%d]\n",(int)pstGuildWarCommData->chWarStep);
				/*****B E G I N***************/
				if (is_guild_war_addition_match() == 0)
				{
					snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"JoinTime[%s]\n",shortdatetime(pstGuildWarCommData->stJoinList.iJoinTime));
				}
				else
				{
					snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"JoinTime[%s]\n",shortdatetime(pstGuildWarCommData->stJoinList.iAdditionJoinTime));
				}	
				/*****E N D***************/				
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"PrepareBegin[%s]\n",shortdatetime(pstGuildWarCommData->iPrepareBeginTime));
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"FightBegin[%s]\n",shortdatetime(pstGuildWarCommData->iFightBeginTime));
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"FightOver[%s]\n",shortdatetime(pstGuildWarCommData->iFightEndTime));
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"---------------------------------------------\n");				
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"LastSeasonClearTime[%s]\n",shortdatetime(pstGuildWarCommData->iLastSeasonClearTime));	
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"SeasonClearTime[%s]\n",shortdatetime(pstGuildWarCommData->iSeasonClearTime));						
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"HistoryWars[%d]\n",pstGuildWarCommData->wHistoryWarNum);
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"HistoryRecords[%d]\n",pstGuildWarCommData->wHistoryRecordNum);
				snprintf(szGMMsg + strlen(szGMMsg),sizeof(szGMMsg) - strlen(szGMMsg),"---------------------------------------------");				
				break;
			}
			else if(!strncasecmp(szCmd, "addscore", sizeof("addscore")))
			{
				if(pstGuild == NULL)
				{	
					snprintf(szGMMsg,sizeof(szGMMsg),"No Guild Input.");
					iRet = -1;
					break;
				}
				chg_guild_guildwar_seasonscore(pstGuild,iParam1);
				snprintf(szGMMsg,sizeof(szGMMsg),"Add Socre [%d] Successful.",iParam1);
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Add Score To Guild[%llu %s] Season .", __FUNCTION__,pstGM->ullGID,pstGM->szName,
					pstGuild->ullGID,pstGuild->stGuildData.stBaseInfo.szGuildName);
				break;
			}
			else if(!strncasecmp(szCmd, "finish", sizeof("finish")))
			{
				if(pstGuild == NULL)
				{	
					snprintf(szGMMsg,sizeof(szGMMsg),"No Guild Input.");
					iRet = -1;
					break;
				}
				
				do{
					LPGUILDWARJOINUNIT pstJoinData = find_guildwar_join_data_by_guildgid(NULL, pstGuild->ullGID);
					LPGUILDWARACTDATA pstWarActData = get_guildwar_act_data(pstJoinData);
					if(NULL == pstJoinData || NULL == pstWarActData)
					{
						iRet = -1;
						break;
					}
					if(get_guildwar_step() != GUILD_WAR_STEP_BATTLE)
					{
						snprintf(szGMMsg,sizeof(szGMMsg)," Guild War Not In Battle Stat, Can not Finish");
						iRet = -1;
						break;
					}
					if(do_guild_war_finish(find_guildwar_map_inst(&pstWarActData->stBaseData),iParam1,iParam2) < 0 )
					{
						iRet = -1;
					}

					snprintf(szGMMsg,sizeof(szGMMsg)," Finish Guild[%llu %s] Successful.",pstGuild->ullGID,pstGuild->stGuildData.stBaseInfo.szGuildName);

					log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Set Guild[%llu %s]  Finish, LeftResult[%d] RightResult[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,pstGuild->ullGID,pstGuild->stGuildData.stBaseInfo.szGuildName,iParam1,iParam2);
					
				}while(0);
				
				break;;
			}
			else if(!strncasecmp(szCmd, "begin", sizeof("begin")))
			{
				do{
					LPGUILDWARDATA pstGuildWarCommData = (LPGUILDWARDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_GUILD_WAR);
					if (NULL == pstGuildWarCommData)
					{
						iRet = -1;
						break;
					}

					if(get_guildwar_step() != GUILD_WAR_STEP_PREPARE)
					{
						snprintf(szGMMsg,sizeof(szGMMsg)," Guild War Not In Prepare Stat, Can not Begin");
						iRet = -1;
						break;
					}

					pstGuildWarCommData->iFightBeginTime = time(NULL) + iParam1;
					pstGuildWarCommData->iFightEndTime = pstGuildWarCommData->iFightBeginTime + 60 * get_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_GUILD_WAR_TIME_ID,1);

					snprintf(szGMMsg,sizeof(szGMMsg)," Begin Guild War Battle Successful.");
					log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Set Guild War Fight Will Begin at[%s] .", __FUNCTION__,pstGM->ullGID,pstGM->szName,compactdatetime(pstGuildWarCommData->iFightBeginTime));
					log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Set Guild War Fight Will Over at[%s] .", __FUNCTION__,pstGM->ullGID,pstGM->szName,compactdatetime(pstGuildWarCommData->iFightEndTime));
				}while(0);

				break;
			}
			else if(!strncasecmp(szCmd, "closeall", sizeof("closeall")))
			{
				log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: GM [%llu %s] Force Close GuildWar, CurStep[%d] .", __FUNCTION__,
						pstGM->ullGID,pstGM->szName,get_guildwar_step());
				
				do{
					LPGUILDWARDATA pstGuildWarCommData = (LPGUILDWARDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_GUILD_WAR);
					if (NULL == pstGuildWarCommData)
					{
						iRet = -1;
						log_info_m(LOG_MODULE_GUILDWAR, LOG_INFO, "%s: Close Failed for Get Commdata Error",__FUNCTION__);
						break;
					}

					pstGuildWarCommData->chWarStep = GUILD_WAR_STEP_NONE;
					pstGuildWarCommData->iPrepareBeginTime = 0;
					pstGuildWarCommData->iFightBeginTime = 0;
					pstGuildWarCommData->iFightEndTime = 0;

					snprintf(szGMMsg,sizeof(szGMMsg)," Close All Guild War Battle Successful.");
				}while(0);

				break;

			}
	}while(0);

	system_msg_to_role(pstGM,szGMMsg);
	return iRet ;
}

int gm_guild(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	/*提取操作对象*/
	char szGMMsgTemp[80];
	LPGUILD pstDestGuild = gm_extract_target_guild(&pszArg, NULL);
	if(pstDestGuild  != NULL)
	{
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Guild[%s  %llu]",pstRole->szName,
			pstDestGuild->stGuildData.stBaseInfo.szGuildName,pstDestGuild->ullGID);
		system_msg_to_role(pstRole, szGMMsgTemp);
	}

	struct timeval stCurrTime;
	gettimeofday(&stCurrTime, NULL);
	
	CSGUILDC stGuildC;
	char szTemp[128];
	char szResInfo[1024];
	char chCmd = 0;
	int iRet = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	chCmd = gm_distill_guild_cmd(szTemp);
	switch(chCmd)
	{
		case TMP_GUILD_CMD_CREATE:
		{
			gm_get_val(&pszArg, stGuildC.stData.stCreateGuild.szGuildName, sizeof(szTemp));
			stGuildC.stData.stCreateGuild.bGuildRecruitState = CS_GUILD_RECRUIT_STATE_OPEN;
			if(stGuildC.stData.stCreateGuild.szGuildName[0])
			{
				stGuildC.nOperation = GUILD_OP_CREATE;
				
				iRet = guild_protocol_proxy_get_cs_req(pstRole, &stGuildC);
				if(iRet != 0)
				{
					snprintf(szTemp, 128, "send create guild req error:(%d)", iRet);
					system_msg_to_role(pstRole, szTemp);
				}else
				{
					system_msg_to_role(pstRole, "send create guild req success");
				}
			}else
			{
				iRet = -1;
			}
			break;
		}
		case TMP_GUILD_CMD_REMOVE_MUTUAL:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			
			unsigned long long ullMutulID = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				iRet = -1;
				break;
			}
			ullMutulID = strtoull(szTemp, NULL, 10);
			del_mutualtask_entry_from_guild(&pstDestGuild->stGuildData.stMutualTask, (unsigned int)ullMutulID);

			break;
		}	
		case TMP_GUILD_CMD_MID_CONDITION:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			do
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(szTemp[0] == 0)
				{
					break;
				}
				//如果有设置参数则进行设置
				char szTempParam[128];
				gm_get_val(&pszArg,szTempParam,sizeof(szTempParam));
				if((szTempParam[0] == 0))
				{
					break;
				}

				int iNum = atoi(szTempParam);
				if(iNum < 0)
				{
					break;
				}
				
				if(!strncasecmp(szTemp, "minonline", sizeof("minonline")))
				{
					set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID,0,iNum);
				}
				else if(!strncasecmp(szTemp, "maxinst", sizeof("maxinst")))
				{
					set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID,1,iNum);
				}
				else if(!strncasecmp(szTemp, "newsvr", sizeof("newsvr")))
				{
					set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID,2,iNum);
				}
				else if(!strncasecmp(szTemp, "oldsvr", sizeof("oldsvr")))
				{
					set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID,3,iNum);
				}
			}while(0);

			LPMAPINST pstMapInst = find_map_inst(pstDestGuild->ullActPworldInstID,NULL);

			//重新返回全部信息
			snprintf(szResInfo, 1024, "Guild MidAutumn Coef:\n"
			    				  "Guild Min Online [%d]\n"
								  "Guild Max Inst [%d] Current Inst[%d]\n"
								  "New Svr Standard[%d] Hours\n"
								  "Old Svr Min Create[%d] Hours\n"
								  "GuildInstID[%llu] IsExist[%d]\n",
								  get_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID, 0),
								  get_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID, 1),
								  get_guild_act_pworldinst_num(MINIGAME_MIDAUTUMN_PWORLD_ACT_ID),
								  get_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID, 2),
								  get_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_MIDAUTUMN_ID, 3),
								  pstDestGuild->ullActPworldInstID,(int)(pstMapInst == NULL ? 0 : 1));	
			system_msg_to_role(pstRole, szResInfo);
			break;
		}
		case TMP_GUILD_CMD_DEL:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			delete_guild(pstDestGuild,1,DELETE_GUILD_REASON_GM);
			break;
		}
		case TMP_GUILD_CMD_DUMP:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			iRet = gm_dump_guild(pstDestGuild);
			break;
		}
		case TMP_GUILD_CMD_DUMPALL:
		{
			gm_dump_all_guild();
			break;
		}
		case TMP_GUILD_CMD_ADD_LAMP:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			int iMonsterID = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				iRet = -1;
				break;
			}
			iMonsterID = atoi(szTemp);
			add_guild_lamp_mon_data(pstDestGuild,iMonsterID);
			break;
		}
		case TMP_GUILD_CMD_RESET_LAMP:
		{
			LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_GUILD_LAMP);
			if(NULL == pstCommData)
			{
				log_info_m(LOG_MODULE_GUILD, LOG_ERR, "%s: Get Commdata Cache Failed for AppKey[%d]，MayBe Not Init.", __FUNCTION__,ENM_COMMDATA_KEY_GUILD_LAMP);
				return -1;
			}

			pstCommData->stGuildLampMon.ulNextTime = time(NULL) - 1000;
			
			break;
		}
		case TMP_GUILD_CMD_ADD_LAMP_TIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			int iLayNum = 4;
			szTemp[0] = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iLayNum = atoi(szTemp);
			}
			
			int iAddTime = 0;
			szTemp[0] = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iAddTime = atoi(szTemp);
			}

			int iRefreshSingle = 0;
			szTemp[0] = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iRefreshSingle = atoi(szTemp);
			}

			append_guild_loayllamp_lightspan_by_layer(pstDestGuild,iLayNum, iAddTime);
			
			if(iRefreshSingle == 1 && iAddTime > pstDestGuild->stGuildData.stGuildLampInfo.iMaxLampSpan)
			{
				snprintf(szTemp, 128, "Update Single Lamp Time From[%d] To [%d].",pstDestGuild->stGuildData.stGuildLampInfo.iMaxLampSpan,iAddTime);
				system_msg_to_role(pstRole, szTemp);
				pstDestGuild->stGuildData.stGuildLampInfo.iMaxLampSpan = iAddTime;
			}
			
			snprintf(szTemp, 128, "Append Time[%d] To Lay[%d].",iAddTime,iLayNum);
			system_msg_to_role(pstRole, szTemp);			
			break;
		}
		case TMP_GUILD_CMD_CLEAR_LAMPITEM_RECORD:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			pstDestGuild->stGuildData.stGuildLampInfo.bLampItemNum = 0;

			system_msg_to_role(pstRole,  "Clear Guild Lamp Item Record OK.");		
			break;
		}	
		case TMP_GUILD_CMD_LIST_LAMPITEM_RECORD:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			system_msg_to_role(pstRole,  "----------Lamp Item Record List----------");
			snprintf(szTemp, 128, "Total[%d] RecordTime[%s].",(int)pstDestGuild->stGuildData.stGuildLampInfo.bLampItemNum,
				shortdatetime(pstDestGuild->stGuildData.stGuildLampInfo.iLastGetLampTime));
			system_msg_to_role(pstRole, szTemp);
			int i = 0;
			for(i = 0; i < pstDestGuild->stGuildData.stGuildLampInfo.bLampItemNum; ++i)
			{
				snprintf(szTemp, 128, "%d) ItemID[%d] DayGet[%d] WeekGet[%d] DayUse[%d].",i,
					pstDestGuild->stGuildData.stGuildLampInfo.astLampItems[i].iItemID,(int)pstDestGuild->stGuildData.stGuildLampInfo.astLampItems[i].bDayGetNum,
					(int)pstDestGuild->stGuildData.stGuildLampInfo.astLampItems[i].bWeekGetNum,(int)pstDestGuild->stGuildData.stGuildLampInfo.astLampItems[i].bDayUseNum);
				system_msg_to_role(pstRole, szTemp);
			}
			system_msg_to_role(pstRole,  "-----------------------------------------");		
			break;
		}	
		case TMP_GUILD_CMD_FLAG:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			snprintf(szTemp, 128, "Guild[%llu %s] Creater[%s] GMPower Flag is[%d]", pstDestGuild->ullGID,pstDestGuild->stGuildData.stBaseInfo.szGuildName,
				pstDestGuild->stGuildData.stBaseInfo.szGuildCreater,pstDestGuild->bGMPower);
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_LIST:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			iRet =  gm_list_guild_member(pstRole, pstDestGuild);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "list guild error(error code %d)", iRet);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			break;
		}
		case TMP_GUILD_CMD_SWAPPING_MEMBER:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			unsigned long long ullMemberA = 0;
			unsigned long long ullMemberB = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole,  "//guild swap <RoleGIDA>  <RoleGIDB>.");
				iRet = -1;
				break;
			}
			ullMemberA =  strtoull(szTemp, NULL, 10);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole,  "//guild swap <RoleGIDA>  <RoleGIDB>.");
				iRet = -1;
				break;
			}
			ullMemberB = strtoull(szTemp, NULL, 10);

			LPGUILDMEMBER pstMemberA = get_guild_member(pstDestGuild, ullMemberA, NULL);
			LPGUILDMEMBER pstMemberB = get_guild_member(pstDestGuild, ullMemberB, NULL);
			if(NULL == pstMemberA )
			{
				snprintf(szTemp, 128, "Invlid RoleID [%llu] Input, not in Guild.",ullMemberA);
				system_msg_to_role(pstRole, szTemp);
				iRet = -1;
				break;
			}
			if(NULL == pstMemberB)
			{
				snprintf(szTemp, 128, "Invlid RoleID [%llu] Input, not in Guild.",ullMemberB);
				system_msg_to_role(pstRole, szTemp);
				iRet = -1;
				break;
			}

			char chJobA = pstMemberA->stZoneGuildMember.chJob;
			char chJobB = pstMemberB->stZoneGuildMember.chJob;

			system_msg_to_role(pstRole,  "You Will Exec Guild Member Swap:");
			snprintf(szTemp, 128, "MemberA[%u %"PRIu64" %s] Job[%d]",pstMemberA->stZoneGuildMember.stBaseInfo.ulUin,pstMemberA->stZoneGuildMember.ullRoleGID,
				pstMemberA->stZoneGuildMember.stBaseInfo.szName,(int)chJobA);
			system_msg_to_role(pstRole,  szTemp);
			snprintf(szTemp, 128, "MemberB[%u %"PRIu64" %s] Job[%d]",pstMemberB->stZoneGuildMember.stBaseInfo.ulUin,pstMemberB->stZoneGuildMember.ullRoleGID,
				pstMemberB->stZoneGuildMember.stBaseInfo.szName,(int)chJobB);
			system_msg_to_role(pstRole,  szTemp);

			szTemp[0] = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(strncasecmp(szTemp, "Yes", sizeof("Yes")))
			{
				system_msg_to_role(pstRole,  "Then Use GM //guild swap <RoleGIDA>  <RoleGIDB>  Yes");
				break;
			}
			
			
			iRet =  exchange_guild_member_job(pstDestGuild, ullMemberA, ullMemberB);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "Exchange Member Job Failed, Ret[%d].",iRet);
				system_msg_to_role(pstRole,  szTemp);
				break;
			}

			
			system_msg_to_role(pstRole,  "---Swap Successful--");
			break;
		}
		case TMP_GUILD_CMD_SET_MEMBER_JOB:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			unsigned long long ullMemberA = 0;
			int iJob = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole,  "//guild setjob <RoleGID>  <Job>.");
				iRet = -1;
				break;
			}
			ullMemberA =  strtoull(szTemp, NULL, 10);
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole,  "//guild setjob <RoleGID>  <Job>.");
				iRet = -1;
				break;
			}
			iJob = atoi(szTemp);

			LPGUILDMEMBER pstMemberA = get_guild_member(pstDestGuild, ullMemberA, NULL);
			if(NULL == pstMemberA )
			{
				snprintf(szTemp, 128, "Invlid RoleID [%llu] Input, not in Guild.",ullMemberA);
				system_msg_to_role(pstRole, szTemp);
				iRet = -1;
				break;
			}

			char chJobA = pstMemberA->stZoneGuildMember.chJob;

			system_msg_to_role(pstRole,  "You Will Exec Guild Member SetJob:");
			snprintf(szTemp, 128, "Member[%u %"PRIu64" %s] CurJob[%d] DestJob[%d]",pstMemberA->stZoneGuildMember.stBaseInfo.ulUin,pstMemberA->stZoneGuildMember.ullRoleGID,
				pstMemberA->stZoneGuildMember.stBaseInfo.szName,(int)chJobA,iJob);
			system_msg_to_role(pstRole,  szTemp);

			szTemp[0] = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(strncasecmp(szTemp, "Yes", sizeof("Yes")))
			{
				system_msg_to_role(pstRole,  "Then Use GM //guild setJob <RoleGIDA>  <Job>  Yes");
				break;
			}
			
			
			iRet =  set_guild_member_job(pstDestGuild, ullMemberA,chJobA, iJob);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "Set Member To Job[%d] Failed, Maybe DestJob is full.",(int)iJob);
				system_msg_to_role(pstRole,  szTemp);
				break;
			}
			
			system_msg_to_role(pstRole,  "---SetJob Successful--");
			break;
		}
		case TMP_GUILD_CMD_SETLEVEL:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			int ID = 0;
			int iLevel = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole,  "Not Input level.");
				iRet = -1;
				break;
			}
			ID = atoi(szTemp);		
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				iRet = -1;
				break;
			}
			iLevel = atoi(szTemp);
			if(ID == 0)
			{
				if(iLevel <=0 || iLevel > CS_GUILD_MAX_LEVEL)
				{
					system_msg_to_role(pstRole, "设置家族等级---> 非法参数");
					return -1;
				}
				pstDestGuild->stGuildData.stBaseInfo.iLevel = iLevel;

				report_guild_levelup(pstDestGuild);

				snprintf(szTemp, 128, "设置家族等级成功 %u", get_guild_level(pstDestGuild));
				system_msg_to_role(pstRole, szTemp);
				return 0;
			}

			if(iLevel <=0 || iLevel > CS_GUILD_MAX_SKILL_RANK)
			{
				system_msg_to_role(pstRole, "非法参数");
				return -1;
			}
			

			int i = 0;
			LPSMELTSKILL pstSmeltSkill = NULL;
			for(i = 0; i < pstDestGuild->stGuildData.stGuildResource.stTechRes.bSmeltNum; ++i)
			{
				if(pstDestGuild->stGuildData.stGuildResource.stTechRes.astSmeltSkill[i].iID == ID)
				{
					pstSmeltSkill = &pstDestGuild->stGuildData.stGuildResource.stTechRes.astSmeltSkill[i];
					break;
				}
			}

			if(pstSmeltSkill != NULL)
			{
				snprintf(szTemp, 128, "该技能正在修炼中，不可修改其等级");
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}

			LPMASTERSKILL pstMasterSkill = NULL;
			for(i = 0; i < pstDestGuild->stGuildData.stGuildResource.stTechRes.bMasterNum; ++i)
			{
				if(pstDestGuild->stGuildData.stGuildResource.stTechRes.astMasterSkill[i].iID == ID)
				{
					pstMasterSkill = &pstDestGuild->stGuildData.stGuildResource.stTechRes.astMasterSkill[i];
					break;
				}
			}

			if(pstMasterSkill == NULL)
			{
				snprintf(szTemp, 128, "尚未掌握该技能");
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			char chReport_begin = pstMasterSkill->bRank;
			pstMasterSkill->bRank = iLevel;
			for(i = chReport_begin + 1; i <= pstMasterSkill->bRank; ++i)
			{
				report_guild_skill_upgrade(pstDestGuild, pstMasterSkill->iID, i);
			}
			
			
			system_msg_to_role(pstRole, "修改成功，本gm概不负责家族等级对技能档次的限制");
			break;
		}
		case TMP_GUILD_CMD_RAISE_TIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			int ID = 0;
			int iTime = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				guild_help(pstRole);
				return -1;
			}
			ID = atoi(szTemp);		
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0 && ID != -1)
			{
				guild_help(pstRole);
				return -1;
			}
			iTime = atoi(szTemp);
			if(ID == -1)
			{
				szTemp[0]='\0';
				if(pstDestGuild->stGuildData.bGuildState == CS_GUILD_STATE_UPGRADE)
				{
					//时间不能超过最大时间
					LPRESGUILDLEVELCONFDEF pstGuildLevelConf = get_guild_level_conf(get_guild_level(pstDestGuild));
					if(NULL == pstGuildLevelConf)
					{
						log_info_m(LOG_MODULE_GUILD, LOG_ERR,"%s: get guild level conf error, guildlevel[%u].",__FUNCTION__,get_guild_level(pstDestGuild));
						return -1;
					}

					pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime = pstGuildLevelConf->iUpgradeTimeMin * 60;
					snprintf(szTemp + strlen(szTemp), 128 -  strlen(szTemp), "Guild Raise Time Add Full to [%u].\n",pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime);

				}

				int i = 0;
				LPSMELTSKILL pstSmeltSkill = NULL;
				for(; i < pstDestGuild->stGuildData.stGuildResource.stTechRes.bSmeltNum; ++i)
				{
					pstSmeltSkill = &pstDestGuild->stGuildData.stGuildResource.stTechRes.astSmeltSkill[i];

					//时间不能超过最大时间
					LPRESGUILDSKILLUPGRADEDEF pstGuildSkillUpgradeDef = get_guild_skill_upgrade_conf(pstSmeltSkill->bRank - 1,pstSmeltSkill->iID);
					if(pstGuildSkillUpgradeDef == NULL)
					{
						log_info_m(LOG_MODULE_GUILD, LOG_ERR,"%s: get skill upgrade stuff by rank[%d] error.",__FUNCTION__,(int)(pstSmeltSkill->bRank - 1));
						return -1;
					}

					pstSmeltSkill->iSmeltElapseTime = pstGuildSkillUpgradeDef->iUpgradeTimeMin * 60;
					
					snprintf(szTemp + strlen(szTemp), 128 -  strlen(szTemp), "Guild Skill[%d] Raise Time Add to Full[%d].\n",pstSmeltSkill->iID,pstSmeltSkill->iSmeltElapseTime);
				}

			}
			else if(ID == 0)
			{
				if(pstDestGuild->stGuildData.bGuildState != CS_GUILD_STATE_UPGRADE)
				{
					return system_msg_to_role(pstRole, "guild not in upgrade state");
				}

				pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime += iTime;

				//时间不能小于0
				if(pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime < 0)
				{
					pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime = 0;
				}

				//时间不能超过最大时间
				LPRESGUILDLEVELCONFDEF pstGuildLevelConf = get_guild_level_conf(get_guild_level(pstDestGuild));
				if(NULL == pstGuildLevelConf)
				{
					log_info_m(LOG_MODULE_GUILD, LOG_ERR,"%s: get guild level conf error, guildlevel[%u].",__FUNCTION__,get_guild_level(pstDestGuild));
					return -1;
				}
				
				if(pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime > pstGuildLevelConf->iUpgradeTimeMin * 60)
				{
					pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime = pstGuildLevelConf->iUpgradeTimeMin * 60;
				}

				
				snprintf(szTemp, 128, "Guild Raise Time Add %d, Cur Elapse %u",iTime,pstDestGuild->stGuildData.stUpgradeInfo.ulElapseTime);
			}
			else
			{
				int i = 0;
				LPSMELTSKILL pstSmeltSkill = NULL;
				for(; i < pstDestGuild->stGuildData.stGuildResource.stTechRes.bSmeltNum; ++i)
				{
					if(pstDestGuild->stGuildData.stGuildResource.stTechRes.astSmeltSkill[i].iID == ID)
					{
						pstSmeltSkill = &pstDestGuild->stGuildData.stGuildResource.stTechRes.astSmeltSkill[i];
						break;
					}
				}

				if(pstSmeltSkill == NULL)
				{
					snprintf(szTemp, 128, "No Skill %d find in raise list",ID);
				}
				else
				{
					pstSmeltSkill->iSmeltElapseTime += iTime;

					//时间不能小于0
					if(pstSmeltSkill->iSmeltElapseTime < 0)
					{
						pstSmeltSkill->iSmeltElapseTime = 0;
					}

					//时间不能超过最大时间
					LPRESGUILDSKILLUPGRADEDEF pstGuildSkillUpgradeDef = get_guild_skill_upgrade_conf(pstSmeltSkill->bRank - 1,pstSmeltSkill->iID);
					if(pstGuildSkillUpgradeDef == NULL)
					{
						log_info_m(LOG_MODULE_GUILD, LOG_ERR,"%s: get skill upgrade stuff by rank[%d] error.",__FUNCTION__,(int)(pstSmeltSkill->bRank - 1));
						return -1;
					}
					
					if(pstSmeltSkill->iSmeltElapseTime > pstGuildSkillUpgradeDef->iUpgradeTimeMin * 60)
					{
						pstSmeltSkill->iSmeltElapseTime = pstGuildSkillUpgradeDef->iUpgradeTimeMin * 60;
					}
					
					snprintf(szTemp, 128, "Guild Skill Raise Time Add %d, Cur Elapse %d",iTime,pstSmeltSkill->iSmeltElapseTime);
				}
			}

			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_ADD_FRIENDLY:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			int iType = 0;
			int iNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				guild_help(pstRole);
				return -1;
			}
			iType = atoi(szTemp);		
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				guild_help(pstRole);
				return -1;
			}
			iNum = atoi(szTemp);
			
			add_guild_power_friendly(pstDestGuild,iType, iNum);
			snprintf(szTemp, 128, "Guild Friendly [%d] is [%d].", iType,get_guild_power_friendly(pstDestGuild,iType));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_EVALUATE_STAR_TIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int iSec = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iSec = atoi(szTemp);
			}

			pstDestGuild->stGuildData.stGuildStarInfo.iNextEvalueTime = stCurrTime.tv_sec + iSec;


			snprintf(szTemp, 128, "Guild[%s] Star Evaluate Time Set To[%s]\n",
				pstDestGuild->stGuildData.stBaseInfo.szGuildName,compactdatetime(pstDestGuild->stGuildData.stGuildStarInfo.iNextEvalueTime));
			
			deal_guild_star_vote(pstDestGuild,&stCurrTime);
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_SET_STAR:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int iSec = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iSec = atoi(szTemp);
			}

			if(iSec == 0)
			{
				pstDestGuild->stGuildData.stGuildStarInfo.ullStarGID = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.szStarName[0] = 0;
				
				pstDestGuild->stGuildData.stGuildStarInfo.iStarVoteNum = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chGender = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chProf = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chHairStyle = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.iHeadImage = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.bCount = 0;
				pstDestGuild->stGuildData.stGuildStarInfo.szDialog[0] = 0;

				snprintf(szTemp, 128, "Guild[%s] Star is Canceled.\n",pstDestGuild->stGuildData.stBaseInfo.szGuildName);
			}
			else
			{
				if(	get_role_guild_gid( pstRole) != pstDestGuild->ullGID)
				{
					snprintf(szTemp, 128, "You are not in Guild[%s].\n",pstDestGuild->stGuildData.stBaseInfo.szGuildName);
				}
				else
				{
					pstDestGuild->stGuildData.stGuildStarInfo.ullStarGID = pstRole->ullGID;
					STRNCPY(pstDestGuild->stGuildData.stGuildStarInfo.szStarName,pstRole->szName,CS_MAX_NAME_LEN);
					
					pstDestGuild->stGuildData.stGuildStarInfo.iStarVoteNum = 100;
					pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chGender = pstRole->chGender;
					pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chProf = pstRole->chProf;
					pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.chHairStyle = 0;
					pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.iHeadImage = 0;
					pstDestGuild->stGuildData.stGuildStarInfo.stPortrayInfo.bCount = 0;
					pstDestGuild->stGuildData.stGuildStarInfo.szDialog[0] = 0;
					snprintf(szTemp, 128, "You are selected to Guild Star for Guild[%s].\n",pstDestGuild->stGuildData.stBaseInfo.szGuildName);
				}	
				
			}

			system_msg_to_role(pstRole, szTemp);
			break;
		}	
		case TMP_GUILD_CMD_RESET_RECHKON:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			pstDestGuild->stGuildData.stGuildResource.stFinanceRes.ulLastReckonTime  = 0;
			system_msg_to_role(pstRole, "Guild Will reckon this week after a min.");
			break;
		}
		case TMP_GUILD_CMD_ADD_GOLD:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int iGoldNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iGoldNum = atoi(szTemp);
			}

			if(iGoldNum <= 0 || iGoldNum > 100000)
			{
				system_msg_to_role(pstRole,  "增加的金钱数目太多或者非法.");
				return -1;
			}
			
			add_guild_gold_ceti(pstDestGuild,iGoldNum);
			snprintf(szTemp, 128, "Guild Gold Ceti :(%u)", get_guild_gold_ceti(pstDestGuild));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_ADD_DISH:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int iDishID = 0;
			int iPos = 0;
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iDishID = atoi(szTemp);
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iPos = atoi(szTemp);
			}

			if(iPos < 0 || iPos > 6)
			{
				snprintf(szTemp, 128, "invalid pos[%d]", iPos);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			LPRESITEM pstResItem = find_item_def_by_resid(iDishID);
			if(NULL == pstResItem)
			{
				snprintf(szTemp, 128, "invalid DishID[%d]", iDishID);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			
			pstDestGuild->stGuildData.stGuildDinner.astDish[iPos].iID = iDishID;
			pstDestGuild->stGuildData.stGuildDinner.astDish[iPos].bLevel = pstResItem->nItemGrade;
			system_msg_to_role(pstRole, "add dish to guild Successful");
			break;
		}
		case TMP_GUILD_CMD_SHOW_DISH:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int i =0;
			snprintf(szResInfo, 1024, "-------Guild Dish-----\n");
			for(i = 0; i <  MAX_GUILD_DISH_WHEN_DINNER; ++i)
			{
				if(pstDestGuild->stGuildData.stGuildDinner.astDish[i].iID == 0)
				{
					continue;
				}
				snprintf(szResInfo + strlen(szResInfo), 1024 - strlen(szResInfo), "Pos[%d] DishID[%d] Level[%d]\n",
					i,pstDestGuild->stGuildData.stGuildDinner.astDish[i].iID,pstDestGuild->stGuildData.stGuildDinner.astDish[i].bLevel);
			}
			system_msg_to_role(pstRole, szResInfo);
			break;
		}
		case TMP_GUILD_CMD_ADD_STUFF:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			int iStuffID = 0;
			int iNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iStuffID = atoi(szTemp);
			}
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iNum = atoi(szTemp);
			}

			if(iStuffID <= 0)
			{
				system_msg_to_role(pstRole,  "材料id非法.");
				return -1;
			}

			if(iNum < 0 || iNum > 10000)
			{
				system_msg_to_role(pstRole,  "材料数目超出上限或者非法.");
				return -1;
			}
			if(add_guild_build_stuff(pstDestGuild, iStuffID, iNum) < 0)
			{
				return system_msg_to_role(pstRole, "add stuff fail.");
			}
		
			return system_msg_to_role(pstRole, "add stuff Suc");
			break;
		}

		case TMP_GUILD_CMD_SHOW_BLESSTIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			time_t tNow;
			time(&tNow);
			if(pstDestGuild->chBlessState == GUILD_BLESS_TASK_STATE_BEGIN)
			{
				
				tNow = tNow - pstDestGuild->stGuildData.stGuildBless.ulLastBlessTime;
				snprintf(szTemp, 128, "blesstime elapse[%d:%d]-remain [%d:%d]",
					(int)(tNow / 60), (int)(tNow % 60),
					(int)((CS_GUILD_BLESS_TIME_MIN * 60 - tNow) / 60),(int)((CS_GUILD_BLESS_TIME_MIN * 60 - tNow) % 60) );
				system_msg_to_role(pstRole, szTemp);
				return 0;
			}

			snprintf(szTemp, 128, "Last[%s]\n This[%d:%d]\n",compactdatetime(pstDestGuild->stGuildData.stGuildBless.ulLastBlessTime),
				(int)pstDestGuild->stGuildData.stGuildBless.stBlessTime.bHour,(int)pstDestGuild->stGuildData.stGuildBless.stBlessTime.bMin);
			snprintf(szTemp + strlen(szTemp), 128 - strlen(szTemp), "Current[%s]\nState [%d]",currcompactdatetime(),pstDestGuild->chBlessState);
			system_msg_to_role(pstRole, szTemp);
			break;	
			
		}

		case TMP_GUILD_CMD_BLESSTIME:
		{
			if(pstDestGuild != NULL)
			{
				system_msg_to_role(pstRole,  "Can only Set SelfGuild.");
			}
			pstDestGuild = get_role_guild(pstRole);
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				return -1;
			}
	
			int iHour = 20;
			int iMin = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iHour = atoi(szTemp);
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iMin = atoi(szTemp);
			}
			stGuildC.nOperation = GUILD_OP_SET_GUILD_DATA;
			stGuildC.stData.stSetGuildData.bSetGuildDataType = CS_SET_GUILD_DATA_BLESS_TIME;
			stGuildC.stData.stSetGuildData.stSetGuildData.stGuildBlessTime.bHour = iHour;
			stGuildC.stData.stSetGuildData.stSetGuildData.stGuildBlessTime.bMin= iMin;
	
			int iRet = guild_protocol_proxy_get_cs_req(pstRole, &stGuildC);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "invite role error (error code %d)", iRet);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			snprintf(szTemp, 128, "set guild bless time to[ %d : %d]", 
				pstDestGuild->stGuildData.stGuildBless.stBlessTime.bHour, pstDestGuild->stGuildData.stGuildBless.stBlessTime.bMin);
			system_msg_to_role(pstRole, szTemp);
			break;	
		}
		case TMP_GUILD_CMD_RESET_BLESSTIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			pstDestGuild->stGuildData.stGuildBless.ulLastBlessTime = 0;
			pstDestGuild->chBlessState = GUILD_BLESS_TASK_STATE_NOT_BEGIN;
			system_msg_to_role(pstRole, "Reset Last Bless Time to 0.");
			break;	
		}
		case TMP_GUILD_CMD_SHOW_DINNERTIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			time_t tNow;
			time(&tNow);
			if(pstDestGuild->chDinnerState == CS_GUILD_DINNER_STATE_BEGIN)
			{
				
				tNow = tNow - pstDestGuild->stGuildData.stGuildDinner.ulRecordDinnerTime;
				snprintf(szTemp, 128, "dinnertime elapse[%d:%d]-remain[%d:%d]",
					(int)(tNow / 60), (int)(tNow % 60),
					(int)((CS_GUILD_BLESS_TIME_MIN * 60 - tNow) / 60),(int)((CS_GUILD_BLESS_TIME_MIN * 60 - tNow) % 60) );
				system_msg_to_role(pstRole, szTemp);
				return 0;
			}

			snprintf(szTemp, 128, "Last[%s]\n This[%d:%d]\n",compactdatetime(pstDestGuild->stGuildData.stGuildDinner.ulRecordDinnerTime),
				(int)pstDestGuild->stGuildData.stGuildDinner.stDinnerTime.bHour,(int)pstDestGuild->stGuildData.stGuildDinner.stDinnerTime.bMin);
			snprintf(szTemp + strlen(szTemp), 128 - strlen(szTemp), "Current[%s]\nState [%d]",currcompactdatetime(),pstDestGuild->chDinnerState);
			system_msg_to_role(pstRole, szTemp);
			break;	
		}	
		case TMP_GUILD_CMD_DINNERTIME:
		{
			if(pstDestGuild != NULL)
			{
				system_msg_to_role(pstRole,  "Can only Set SelfGuild.");
			}
			pstDestGuild = get_role_guild(pstRole);
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find not guild");
				return -1;
			}

			int iWeek = 6;
			int iHour = 20;
			int iMin = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iWeek = atoi(szTemp);
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iHour = atoi(szTemp);
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iMin = atoi(szTemp);
			}
		
			stGuildC.nOperation = GUILD_OP_DINE_RELATED;
			stGuildC.stData.stGuildDinner.bGuildDinnerType = CS_GUILD_DINNER_SET_DINNER_TIME;
			stGuildC.stData.stGuildDinner.stGuildDinnerData.stGuildDinnerTime.bWeekday = iWeek;
			stGuildC.stData.stGuildDinner.stGuildDinnerData.stGuildDinnerTime.bHour = iHour;
			stGuildC.stData.stGuildDinner.stGuildDinnerData.stGuildDinnerTime.bMin = iMin;
	
			int iRet = guild_protocol_proxy_get_cs_req(pstRole, &stGuildC);
			if(iRet != 0)
			{
				snprintf(szTemp, 128, "invite role error (error code %d)", iRet);
				system_msg_to_role(pstRole, szTemp);
				return -1;
			}
			snprintf(szTemp, 128, "set guild dinner time to[ %d : %d: %d]", 
				pstDestGuild->stGuildData.stGuildDinner.stDinnerTime.bWeekday, 
				pstDestGuild->stGuildData.stGuildDinner.stDinnerTime.bHour,
				pstDestGuild->stGuildData.stGuildDinner.stDinnerTime.bMin);
			system_msg_to_role(pstRole, szTemp);
			break;	
		}	
		case TMP_GUILD_CMD_RESET_DINNERTIME:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			pstDestGuild->stGuildData.stGuildDinner.ulRecordDinnerTime = 0;
			pstDestGuild->chDinnerState = CS_GUILD_DINNER_STATE_NOT_BEGIN;
			system_msg_to_role(pstRole, "Reset Last Dinner Time to 0.");
			break;	
		}	
		case TMP_GUILD_CMD_ENTERSCEEN:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			role_enter_guildsceen(pstRole,0,pstDestGuild,0,0);
			break;	
		}
		case TMP_GUILD_CMD_MAINT:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			
			pstDestGuild->stGuildData.stMaintenanceInfo.ulLastTime = 0;
			struct timeval stCurrTime;
			gettimeofday(&stCurrTime, NULL);
			
			deal_guild_daily_maintenance(pstDestGuild, &stCurrTime);
			break;
		}
		case TMP_GUILD_CMD_MAINTINFO:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}

			snprintf(szTemp, 128, "Guild Lack Times[%d] LastMaintTime[%s]",
				(int)pstDestGuild->stGuildData.stMaintenanceInfo.bLackTimes,compactdatetime(pstDestGuild->stGuildData.stMaintenanceInfo.ulLastTime));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_MAINTLACK:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			if(pstDestGuild->stGuildData.bGuildState == CS_GUILD_STATE_UPGRADE)
			{
				system_msg_to_role(pstRole,  "Can not change lack times in guild upgrade state.");
				return -1;
			}
			
			int iLackTimes = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iLackTimes = atoi(szTemp);
			}
			if(iLackTimes <= 0 || iLackTimes > 6)
			{
				system_msg_to_role(pstRole,  "Lack Times Must be [1 - 6].");
				return -1;
			}
				
			pstDestGuild->stGuildData.stMaintenanceInfo.bLackTimes = iLackTimes;

			snprintf(szTemp, 128, "Guild Lack Times[%d] LastMaintTime[%s]",
				(int)pstDestGuild->stGuildData.stMaintenanceInfo.bLackTimes,compactdatetime(pstDestGuild->stGuildData.stMaintenanceInfo.ulLastTime));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_ADD_BUILDLEVEL:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			int iBuildLevel  = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0])
			{
				iBuildLevel = atoi(szTemp);
			}

			change_guild_buildlevel(pstDestGuild,iBuildLevel);
			snprintf(szTemp, 128, "Guild BuildLevel Change To[%u]",get_guild_buildlevel(pstDestGuild));
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_RECKON_VOTEMASTER:
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			if(pstDestGuild == NULL)
			{
				system_msg_to_role(pstRole,  "find no guild with your input.");
				return -1;
			}
			if(pstDestGuild->stGuildData.stMasterElectInfo.ullApplyGID == 0)
			{
				system_msg_to_role(pstRole,  "Guild Not In Master Elect.");
				return -1;
			}
			
			pstDestGuild->stGuildData.stMasterElectInfo.iApplyTime = 1;
			
			system_msg_to_role(pstRole, "Dest Guild Master Elect ApplyTime Set to [1], Now Stop Vote Begin Reckon.");
			break;
		}
		case TMP_GUILD_CMD_WAR: //家族战的GM
		{
			if(pstDestGuild == NULL)
			{
				pstDestGuild = get_role_guild(pstRole);
			}

			return gm_guildwar_i(pstDestGuild,pszArg,pstRole);
			break;
		}
		case TMP_GUILD_CMD_QUERYLIFETREE: //家族生命树查询
		{
			if (NULL == pstDestGuild)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			
			if (NULL == pstDestGuild)
			{
				system_msg_to_role(pstRole, "No Guild!");
				return 0;
			}

			short nWateringTimes = pstDestGuild->stGuildExtendData.stGuildLifeTree.nWateringTimes;
			
			snprintf(szTemp, 128, "GuildLifeTreeStatus[%d]", nWateringTimes);
			
			system_msg_to_role(pstRole, szTemp);
			break;
		}
		case TMP_GUILD_CMD_CHANGELIFETREE: //家族生命树改变
		{
			if (NULL == pstDestGuild)
			{
				pstDestGuild = get_role_guild(pstRole);
			}
			
			if (NULL == pstDestGuild)
			{
				system_msg_to_role(pstRole, "No Guild!");
				return 0;
			}

			if (-1 == pstDestGuild->stGuildExtendData.stGuildLifeTree.nWateringTimes)
			{
				system_msg_to_role(pstRole, "No Guild Life Tree!");
				return 0;
			}

			int iValue = 0;
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0])
			{
				iValue = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "Please Check GuildHelp!");
				return 0;
			}

			if (0 > iValue)
			{
				system_msg_to_role(pstRole, "Value Illegal!");
				return 0;
			}
			
			pstDestGuild->stGuildExtendData.stGuildLifeTree.nWateringTimes = iValue;
			//全家族广播
			CSGUILDS stGuildS;
			memset(&stGuildS,0,sizeof(stGuildS));
			stGuildS.nEno = 0;
			stGuildS.chOperation = GUILD_OP_LIFE_TREE_RELATED;
			stGuildS.stData.stGuildLifeTree.nWateringTimes = iValue;
			broadcast_guild(pstDestGuild, &stGuildS, 0, ORG_FOREACH_NO_SPECIFY_JOB);
			
			break;
		}
		default:
			guild_help(pstRole);
			break;
	
	}

	return 0;
}

void gm_gm_help(LPROLE pstRole)
{
	system_msg_to_role(pstRole, "gm <nogm/first/second/third/...> local UIN RoleName");
}

int gm_gm(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	unsigned char bPower = 0;
	unsigned char bZoneID = 0;
	unsigned int ulUin = 0;
	char szRoleName[CS_MAX_NAME_LEN];

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		gm_gm_help(pstRole);
		return -1;
	}
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		gm_gm_help(pstRole);
		return 0;
	}

	//输入权限
	if(!strncasecmp(szTemp, "nogm", sizeof("nogm")))
	{
		bPower = GM_ROLE_NO_GM;
	}
	else if(!strncasecmp(szTemp, "first", sizeof("first")))
	{
		bPower = GM_ROLE_FIRST;
	}
	else if(!strncasecmp(szTemp, "second", sizeof("second")))
	{
		bPower = GM_ROLE_SECOND;
	}
	else if(!strncasecmp(szTemp, "third", sizeof("third")))
	{
		bPower = GM_ROLE_THIRD;
	}
	else if(!strncasecmp(szTemp, "fourth", sizeof("fourth")))
	{
		bPower = GM_ROLE_FOURTH;
	}
	else if(!strncasecmp(szTemp, "fifth", sizeof("fifth")))
	{
		bPower = GM_ROLE_FIFTH;
	}
	else if(!strncasecmp(szTemp, "sixth", sizeof("sixth")))
	{
		bPower = GM_ROLE_SIXTH;
	}
	else if(!strncasecmp(szTemp, "seventh", sizeof("seventh")))
	{
		bPower = GM_ROLE_SEVENTH;
	}
	else if(!strncasecmp(szTemp, "eighth", sizeof("eighth")))
	{
		bPower = GM_ROLE_EIGHTH;
	}
	else
	{
		gm_gm_help(pstRole);
		return -1;
	}

	//输入ZoneID,local则为本zoneID
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		gm_gm_help(pstRole);
		return -1;
	}
	if(!strncasecmp(szTemp, "local", sizeof("local")))
	{
		bZoneID = get_sys_zoneid();
	}else
	{
		bZoneID = atoi(szTemp);
	}
	if(bZoneID == 0)
	{
		gm_gm_help(pstRole);
		return -1;
	}

	//输入Uin
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		gm_gm_help(pstRole);
		return -1;
	}
	ulUin = atoll(szTemp);
	if(0 == ulUin)
	{
		gm_gm_help(pstRole);
		return -1;
	}
	
	//输入Name
	gm_get_val(&pszArg,szRoleName,sizeof(szRoleName));
	if(!szRoleName[0])
	{
		gm_gm_help(pstRole);
		return -1;
	}

	sprintf(szTemp, "grant %d to role(%d, %u, %s)", bPower, bZoneID, ulUin, szRoleName);
	system_msg_to_role(pstRole, szTemp);

	//if target role online ,change it immediately.
	LPROLE pstTargetRole = uin_to_role(ulUin);
	if(pstTargetRole != NULL && !strncmp(pstTargetRole->szName,szRoleName,CS_MAX_NAME_LEN))
	{
		pstTargetRole->bGMPower = bPower;
	}	
	
	//向world发送请求
	REQUESTPKG stRequest;
	LPSSGMUPDATEREQ pstReq = NULL;

	pstReq = &stRequest.stBody.stGMUpdate;
	pstReq->bZoneID = bZoneID;
	pstReq->ulUin = ulUin;
	STRNCPY(pstReq->szRoleName, szRoleName, SS_MAX_NAME_LEN);
	pstReq->bRolePower = bPower;
	unsigned char ucWorldID = get_sys_worldid();
	unsigned int iServiceID;
	get_serviceid(ucWorldID, 0, FUNC_WORLD_SVR, &iServiceID);
	int iRet = send_world_request(iServiceID, pstRole->ulUin, SS_GM_UPDATE_REQ, &stRequest, 0);
	if (0 != iRet)
	{
		log_info(LOG_ERR, "%s : send_world_request failed.", __FUNCTION__);
		return -1;
	}
	
	return 0;
}

int gm_battlepower(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	char szMsg[512] ={0};
	char szTemp[32];
	int iPetIndex = 0;
	int i;
	LPZONEPETITEM pstPetItem;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		snprintf(szMsg + strlen(szMsg), sizeof(szMsg) - strlen(szMsg), "Role LevelBP = %d, ArmBP = %d ,SkillBP= %d Total = %d\n",
			get_role_levelbp(pstRole),get_role_armbp(pstRole),get_role_skillbp(pstRole),get_role_bp(pstRole));
		for(i = 0; i < pstRole->stRoleItem.stData.stPetList.chTotal; ++i)
		{
			pstPetItem = pstRole->stRoleItem.stData.stPetList.astPetItems + i;
			snprintf(szMsg + strlen(szMsg), sizeof(szMsg) - strlen(szMsg),  "Pet[%d] LevelBP = %d, SelfBP = %d ,SkillBP= %d Total = %d\n",
				pstPetItem->stPetItem.chGridIndex,pstPetItem->iLevelBP,pstPetItem->iSelfBP,pstPetItem->iSkillBP,get_petitem_battlepower(pstPetItem));
		}
		snprintf(szMsg + strlen(szMsg), sizeof(szMsg) - strlen(szMsg), "Total = %d",get_role_battle_power(pstRole));
	}
	else
	{
		iPetIndex = atoi(szTemp);
		pstPetItem = get_petitem_by_index(pstRole,iPetIndex);
		if(pstPetItem == NULL)
		{
			return -1;
		}
		snprintf(szMsg, sizeof(szMsg), "Pet[%d] LevelBP = %d, ArmBP = %d ,SkillBP= %d Total = %d",
			iPetIndex,pstPetItem->iLevelBP,pstPetItem->iArmBP,pstPetItem->iSkillBP,get_petitem_battlepower(pstPetItem));
	}
	system_msg_to_role(pstRole, szMsg);
	return 0;
}
int gm_repairall(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}
	int i =0;
	LPZONEITEM pstWearItem = NULL;
	LPRESARM pstArmRes = NULL;
	CSITEMID stItemID;
	stItemID.chBagIndex = 0;
	stItemID.chType = CS_LISTTYPE_WEARBASE;
	stItemID.chNum = 1;
	for(; i < pstRole->stRoleItem.stData.stWearList.iCount; ++i)
	{
		pstWearItem = &pstRole->stRoleItem.stData.stWearList.astItems[i];
		pstArmRes = find_arm_def_by_zoneitem(pstWearItem);
		if(NULL == pstArmRes || pstWearItem->stItemAttr.stArmAttr.iCurDurableDegree == pstWearItem->stItemAttr.stArmAttr.iMaxDurableDegree)
		{
			continue;
		}
		stItemID.chItemIndex = pstWearItem->chGridIndex;
		change_arm_durabledegree(pstRole, pstWearItem, &stItemID, 
				pstArmRes->iMaxDurableDegree - pstWearItem->stItemAttr.stArmAttr.iCurDurableDegree, 0, 1, NULL);
		update_roleitem(pstRole, &stItemID, pstWearItem); //通知Client的，耐久度属性的变更
	}
	return 0;
}
int gm_roleattr(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	char szMsg[512] ={0};
	char szTemp[32];
	int iTmp = 0;
	CSATTRLISTC stAttrAdjust;
	memset(&stAttrAdjust,0,sizeof(CSATTRLISTC));
	stAttrAdjust.nTotal = 0;
	stAttrAdjust.astAttr[0].nAttr = CS_ATTR_BLD;
	stAttrAdjust.astAttr[1].nAttr = CS_ATTR_STR;
	stAttrAdjust.astAttr[2].nAttr = CS_ATTR_HAB;
	stAttrAdjust.astAttr[3].nAttr = CS_ATTR_INT;
	do{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{
			break;
		}
		iTmp = atoi(szTemp);
		if(iTmp < 0)
		{
			break;
		}
		stAttrAdjust.astAttr[stAttrAdjust.nTotal].iValue = iTmp;
		++ stAttrAdjust.nTotal;

	}while(stAttrAdjust.nTotal < 4);

	if(0 == stAttrAdjust.nTotal)
	{
		snprintf(szMsg , sizeof(szMsg), "查询角色的属性: \n"
				"1)最大生命:%d   	2)当前生命:%d\n"
				"3)最大法力:%d   	4)当前法力:%d\n"
				"5)物理攻击:%d-%d   6)物理防御:%d\n"
				"7)法术攻击:%d-%d   8)法术防御:%d\n"
				"9)气血:%d   		10)精神:%d\n"
				"11)力量:%d   		12)智慧:%d\n"
				"13)剩余点数:%d\n"
				"14)闪避率:%d  		15)闪避点:%d\n"
				"16)命中率:%d       17)命中点:%d\n"
				"18)物理吸收:%d  	19)法术吸收:%d\n"
				"20)忽视物理吸收:%d 21)忽视法术吸收:%d\n"
				"22)6秒回血:%d  	23)6秒回蓝:%d\n"
				"24)爆击点:%d  		25)韧性点:%d\n"
				"26)爱心值:%d\n",
				
				attr_get_value(&pstRole->stAttr, CS_ATTR_MAXHP),get_role_curhp(pstRole),
				attr_get_value(&pstRole->stAttr, CS_ATTR_MAXMP),get_role_curmp(pstRole),
				attr_get_value(&pstRole->stAttr, CS_ATTR_MINPHYSATK),attr_get_value(&pstRole->stAttr, CS_ATTR_MAXPHYSATK),
				attr_get_value(&pstRole->stAttr, CS_ATTR_PHYSDEF),
				attr_get_value(&pstRole->stAttr, CS_ATTR_MINMAGICATK),attr_get_value(&pstRole->stAttr, CS_ATTR_MAXMAGICATK),
				attr_get_value(&pstRole->stAttr, CS_ATTR_MAGICDEF),
				attr_get_value(&pstRole->stAttr, CS_ATTR_BLD),attr_get_value(&pstRole->stAttr, CS_ATTR_HAB),
				attr_get_value(&pstRole->stAttr, CS_ATTR_STR),attr_get_value(&pstRole->stAttr, CS_ATTR_INT),
				pstRole->nLeftAP,
				attr_get_value(&pstRole->stAttr, CS_ATTR_EVADERATE), attr_get_value(&pstRole->stAttr, CS_ATTR_EVADE_POINTS),
				attr_get_value(&pstRole->stAttr, CS_ATTR_HITRATE), attr_get_value(&pstRole->stAttr, CS_ATTR_HIT_POINTS),
				attr_get_value(&pstRole->stAttr, CS_ATTR_PHYSABSORB), attr_get_value(&pstRole->stAttr, CS_ATTR_MAGICABSORB),
				attr_get_value(&pstRole->stAttr, CS_ATTR_PHYSPIERCE), attr_get_value(&pstRole->stAttr, CS_ATTR_MAGICPIERCE),
				attr_get_value(&pstRole->stAttr, CS_ATTR_ANY_HPEGEN_6S), attr_get_value(&pstRole->stAttr, CS_ATTR_ANY_MPEGEN_6S),
				attr_get_value(&pstRole->stAttr, CS_ATTR_RAGEPOINTS), attr_get_value(&pstRole->stAttr, CS_ATTR_TENACITY_POINTS),
				attr_get_value(&pstRole->stAttr, CS_ATTR_ROLE_COST_VALUE)
		);
		system_msg_to_role(pstRole, szMsg);
	}
	else
	{
		snprintf(szMsg , sizeof(szMsg), "调整角色的属性: \n"
				"气血+%d   力量+%d  体质+%d  智慧+%d\n",
				stAttrAdjust.astAttr[0].iValue,stAttrAdjust.astAttr[1].iValue,
				stAttrAdjust.astAttr[2].iValue,stAttrAdjust.astAttr[3].iValue);
		system_msg_to_role(pstRole, szMsg);
		adjust_role_prim_attr(pstRole, &stAttrAdjust, 0);
	}

	return 0;
}

int gm_petattr(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	char szMsg[512] ={0};
	
	LPPET pstPet = get_pet_by_role(pstRole);
	if(NULL == pstPet)
	{
		return -1;
	}
	LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
	if(NULL == pstZonePetItem)
	{
		return -1;
	}
	
	snprintf(szMsg , sizeof(szMsg), "当前激活宠物的属性: \n"
			"1)最大生命:%d  2)最大法力:%d\n"
			"3)当前生命:%d  4)当前法力:%d\n"
			"5)物理攻击:%d-%d  6)物理防御:%d\n"
			"7)法术攻击:%d-%d  8)法术防御:%d\n"
			"9)气血:%d    10)精神:%d\n"
			"11)力量:%d    12)智慧:%d\n"
			"13)气血资质:%d    14)智慧资质:%d\n"
			"15)力量资质:%d    16)精神资质:%d\n",
			
			get_pet_maxhp(pstPet),get_pet_maxmp(pstPet),
			get_pet_curhp(pstPet),get_pet_curmp(pstPet),
			attr_get_value(&pstPet->stAttr, CS_ATTR_MINPHYSATK),attr_get_value(&pstPet->stAttr, CS_ATTR_MAXPHYSATK),
			attr_get_value(&pstPet->stAttr, CS_ATTR_PHYSDEF),
			attr_get_value(&pstPet->stAttr, CS_ATTR_MINMAGICATK),attr_get_value(&pstPet->stAttr, CS_ATTR_MAXMAGICATK),
			attr_get_value(&pstPet->stAttr, CS_ATTR_MAGICDEF),
			attr_get_value(&pstPet->stAttr, CS_ATTR_BLD),
			attr_get_value(&pstPet->stAttr, CS_ATTR_HAB),
			attr_get_value(&pstPet->stAttr, CS_ATTR_STR),
			attr_get_value(&pstPet->stAttr, CS_ATTR_INT),
			pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetPrimAttr.iCurrBldAptitude,
			pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetPrimAttr.iCurrIntAptitude,
			pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetPrimAttr.iCurrStrAptitude,
			pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetPrimAttr.iCurrHabAptitude
			);
		
	system_msg_to_role(pstRole, szMsg);

	return 0;
}

int gm_petitemattr(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	char szMsg[512] = {0};
	char szTemp[32] = {0};
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0] == 0)
	{
		return -1;
	}
	int iPetIndex = atoi(szTemp);
	LPZONEPETITEM pstZonePetItem = get_petitem_by_index(pstRole, iPetIndex);
	if(pstZonePetItem == NULL)
	{
		return -1;
	}
	snprintf(szMsg , sizeof(szMsg), "宠物的属性: \n"
			"1)当前生命:%d  2)当前法力:%d\n",
			pstZonePetItem->iCurrentHP, pstZonePetItem->iCurrentMP);
	system_msg_to_role(pstRole, szMsg);
	return 0;
}

int gm_setpetaptimax(LPROLE pstRole, const char *pszArg)
{	
	char szTemp[32] = {0};
	char chPetIndex = 0;
	int iRet = 0;
	
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "setpetaptimax chPetListIndex");
			return 0;
		}
		chPetIndex= atoi(szTemp);
	}else
	{
		return -1;
	}
	LPZONEPETITEM pstZonePetItem = get_petitem_by_index(pstRole, chPetIndex);
	if(pstZonePetItem == NULL)
	{
		return -1;
	}
	iRet = set_pet_apti_to_max(pstRole, chPetIndex);
	if(iRet < 0)
	{
		system_msg_to_role(pstRole, "set_pet_apti_to_max error");
		return iRet;
	}
	return 0;
}

int on_gm_update_res(unsigned int ulUin, LPSSGMUPDATERES pstSSGMUpdateRes)
{
	LPROLE pstRole = NULL;
	if(NULL == pstSSGMUpdateRes)
	{
		return -1;
	}

	pstRole = uin_to_role(ulUin);

	if(NULL == pstRole)
	{
		return -1;
	}

	if(pstSSGMUpdateRes->nEno)
	{
		system_msg_to_role(pstRole, "grant gm power fail");
	}else
	{
		system_msg_to_role(pstRole, "grant gm power success");
	}

	return 0;
}

int gm_allnotice(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	int iNoticeID = 0;
	LPROLEPOOL pstRolePool = NULL;
	LPROLE pstTRole = NULL;
	int i = 0;

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

		
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0] == 0)
	{
		return -1;
	}

	iNoticeID = atoi(szTemp);
	if (iNoticeID == 0)
	{
		return -1;
	}
	
	pstRolePool = get_role_pool();
	if (NULL == pstRolePool)
	{
		return -1;
	}
	
	for (i=0; i<MAX_ROLE; ++i)
	{
		pstTRole = (LPROLE)pstRolePool->sRole[i];
		if (pstTRole->stObject.ulID != 0)
		{	
			send_sys_notice_msg(pstTRole, NULL,iNoticeID, NULL, NULL, NULL,NULL);
		}
	}	

	return 0;
}

int gm_counter(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
		pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szGMMsgTemp);

	
	char szTemp[128];
	char szMsg[1024];
	int iType = 0;
	int iID = 0;
	int iNum = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0] || !strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "counter help");
		system_msg_to_role(pstRole, "counter list");
		system_msg_to_role(pstRole, "counter reset");
		system_msg_to_role(pstRole, "counter look Type ID");
		system_msg_to_role(pstRole, "counter set Type ID Num");
		return 0;
	}
	if(!strncasecmp(szTemp, "list", sizeof("list")))
	{
		dailycounter_dump(&pstDestRole->stDailyCounter, szMsg,1024);
		system_msg_to_role(pstRole, szMsg);
	}
	else if(!strncasecmp(szTemp, "reset", sizeof("reset")))
	{
		memset(pstDestRole->stDailyCounter.astPeriods,0,sizeof(pstDestRole->stDailyCounter.astPeriods[0])* CS_MAX_COUNTER_PERIOD_TYPE);
		memset(pstDestRole->stDailyCounter.typeLmt,0,sizeof(pstDestRole->stDailyCounter.typeLmt));

	}
	else if(!strncasecmp(szTemp, "look", sizeof("look")))
	{		
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iType = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iID = atoi(szTemp);		
		snprintf(szMsg,1024,"Counter Type[%d] ID[%d] Num[%d]",iType,iID,get_dailycounter_num(&pstDestRole->stDailyCounter,iType,iID));
		system_msg_to_role(pstRole, szMsg);
	}
	else if(!strncasecmp(szTemp, "set", sizeof("set")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iType = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iID = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iNum = atoi(szTemp);
		if(set_dailycounter_num(&pstDestRole->stDailyCounter,iType,iID,iNum) < 0)
		{
			system_msg_to_role(pstRole, "Set Counter Error");
		}
		else
		{
			snprintf(szMsg,1024,"Counter Type[%d] ID[%d] Num[%d]",iType,iID,get_dailycounter_num(&pstDestRole->stDailyCounter,iType,iID));
			system_msg_to_role(pstRole, szMsg);
		}
	}
	else if (!strncasecmp(szTemp, "roll", sizeof("roll")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iType = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iID = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			return -1;
		}
		iNum = atoi(szTemp);

		if (roll_dailycounter_append(&pstRole->stDailyCounter, iType, iID, iNum) < 0)
		{
			system_msg_to_role(pstRole, "Roll Counter Error");
		}
		else
		{
			snprintf(szMsg,1024,"Counter Type[%d] ID[%d] Num[%d]",iType,iID,get_dailycounter_num(&pstDestRole->stDailyCounter,iType,iID));
			system_msg_to_role(pstRole, szMsg);
		}
	}
	else
	{
		system_msg_to_role(pstRole, "counter help");
		system_msg_to_role(pstRole, "counter list");
		system_msg_to_role(pstRole, "counter reset");
		system_msg_to_role(pstRole, "counter look Type ID");
		system_msg_to_role(pstRole, "counter set Type ID Num");
	}
	return 0;	
}

int gm_autochat(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	int iTime = 0;
	int iNum = 0;
	char szMsg[256];
	int i = 0;
	int j = 0;

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	iTime = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	iNum = atoi(szTemp);
	if (0 == iTime && 0 == iNum)
	{
		return -1;
	}


	for (i=0; i<iTime; ++i)
	{
		for (j=0; j<iNum; ++j)
		{
			snprintf(szMsg, sizeof(szMsg), "%d : auto chat msg [%d].", i, j);
			system_msg_to_role(pstRole, szMsg);
		}
		
		usleep(100*1000);	
	}	

	return 0;
}

static void mail_help(LPROLE pstRole)
{/*{{{*/
	system_msg_to_role(pstRole, "mail create -- add mail func to role");
	system_msg_to_role(pstRole, "mail destory -- del mail func to role");
	system_msg_to_role(pstRole, "mail list -- show mail list");
	system_msg_to_role(pstRole, "mail sendto from togid title content money(银两) jade(金子) jadecri(金券) moneycri(银票) itemid num -- send user mail to rolename");
	system_msg_to_role(pstRole,"mail batchsendto uin item num mailnum");
	system_msg_to_role(pstRole, "mail detail mailid  -- get mail detail");
	system_msg_to_role(pstRole, "mail del mailid  -- delete mail");
}/*}}}*/
int gm_mail(LPROLE pstRole, const char *pszArg)
{/*{{{*/
	char szTemp[128];
	char szFrom[MAX_ROLE_NAME_LEN];
	char szGID[32];
	char szTitle[64];
	char szContent[256];
	char szMailID[128];
	unsigned long long ullMailID = 0;
	unsigned long long ullGID = 0;
	int iRet = 0;
	int iMoney = 0;
	int iJade  = 0;
	int iJadeCerti = 0;
	int iMoneyCerti = 0;
	int iItemID = 0;
	int iItemNum = 0;
	LPITEM pstItem = NULL;

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			mail_help(pstRole);
			return 0;
		}
		else if(!strncasecmp(szTemp, "create", sizeof("create")))
		{
			mail_role_add(pstRole->ullGID,pstRole->ulUin);
			return 0;
		}
		else if(!strncasecmp(szTemp, "list", sizeof("list")))
		{
			mail_get_list(pstRole->ullGID, 0, 0, ENM_MGLR_CLIENT, 0);
			return 0;
		}
		else if(!strncasecmp(szTemp, "batchsendto",sizeof("batchsendto")))
		{

			gm_get_val(&pszArg,szFrom,sizeof(szFrom));
			if(!szFrom[0])
			{
				mail_help(pstRole);
				return -1;
			}
			LPROLE pstTmpRole = uin_to_role(atoll(szFrom));
			if(pstTmpRole == NULL)
			{
				system_msg_to_role(pstRole,"mail batchsend to role, role not exist.");
				return -1;
			}
				
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iItemID = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iItemNum = atoi(szTemp);
			
			pstItem = dropitem_byresid(iItemID, iItemNum, 0, 
					DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL);
			if(pstItem == NULL)
			{
				log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
				mail_help(pstRole);
				return -1;
			} 
			ZONEITEM stTmpZoneItem = pstItem->stData.stItem;
			destroy_dropitem(pstItem);


			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			int iMailNum = atoi(szTemp);
			int k=0;
			for( ; k < iMailNum; k++)
			{

				iRet = mail_sys_send(ENM_MST_TEST, "systest", pstTmpRole->ullGID, "test", "testmail", 1, 1, 1, 1, &stTmpZoneItem, 1);
				if (iRet < 0)
				{
					system_msg_to_role(pstRole, "send mail error");
				}

			}

		}
		else if(!strncasecmp(szTemp, "sendto", sizeof("sendto")))
		{
			gm_get_val(&pszArg,szFrom,sizeof(szFrom));
			if(!szFrom[0])
			{
				mail_help(pstRole);
				return -1;
			}

			gm_get_val(&pszArg,szGID,sizeof(szGID));
			if(!szGID[0])
			{
				mail_help(pstRole);
				return -1;
			}
			ullGID = strtoull(szGID, NULL, 10);

			gm_get_val(&pszArg,szTitle,sizeof(szTitle));
			if(!szTitle[0])
			{
				mail_help(pstRole);
				return -1;
			}

			gm_get_val(&pszArg,szContent,sizeof(szContent));
			if(!szContent[0])
			{
				mail_help(pstRole);
				return -1;
			}

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iMoney = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iJade = atoi(szTemp);
					
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iJadeCerti = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iMoneyCerti = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iItemID = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			iItemNum = atoi(szTemp);
			
			pstItem = dropitem_byresid(iItemID, iItemNum, 0, 
					DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL);
			if(pstItem == NULL)
			{
				log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
				mail_help(pstRole);
				return -1;
			} 

			iRet = mail_sys_send(ENM_MST_TEST, szFrom, ullGID, szTitle, szContent, iMoney, iJade, iJadeCerti, iMoneyCerti, &pstItem->stData.stItem, 1);
			if (iRet < 0)
			{
				system_msg_to_role(pstRole, "send mail error");
			}
			
			destroy_dropitem(pstItem);

		}
		else if(!strncasecmp(szTemp, "detail", sizeof("detail")))
		{
			gm_get_val(&pszArg, szMailID,sizeof(szMailID));
			if(!szMailID[0])
			{
				mail_help(pstRole);
				return -1;
			}
			
			ullMailID = strtoull(szMailID, NULL, 10);
			iRet = mail_get_detail(pstRole->ullGID, ullMailID, ENM_MGDS_NORMAL, 0, 0);
			if (iRet < 0)
			{
				system_msg_to_role(pstRole, "get mail detail error");
			}
		}
		else if(!strncasecmp(szTemp, "destroy", sizeof("destroy")))
		{
			iRet = mail_role_del(pstRole->ullGID);
			if (iRet < 0)
			{
				system_msg_to_role(pstRole, "del role error");
			}
			
		}
		else if(!strncasecmp(szTemp, "del", sizeof("del")))
		{
			gm_get_val(&pszArg, szMailID,sizeof(szMailID));
			if(!szMailID[0])
			{
				mail_help(pstRole);
				return -1;
			}
			
			ullMailID = strtoull(szMailID, NULL, 10);
			iRet = mail_delete(pstRole->ullGID, ullMailID, ENM_MDR_GM, 0);
			if (iRet < 0)
			{
				system_msg_to_role(pstRole, "delete mail error");
			}
		}
		else if(!strncasecmp(szTemp, "setlocation", sizeof("setlocation")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
			unsigned char bAction = atoi(szTemp);
			mail_set_location(pstRole->ullGID, bAction);
		}
		else if(!strncasecmp(szTemp, "XXX", sizeof("XXX")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				mail_help(pstRole);
				return -1;
			}
		}	
		else
		{
			mail_help(pstRole);
			return -1;
		}
	}else
	{
		mail_help(pstRole);
		return -1;
	}

	return 0;
}/*}}}*/

void gm_init_uin_range(unsigned int ulUinBegin, unsigned int ulUinEnd)
{
	gs_ulUinBegin = ulUinBegin;
	gs_ulUinEnd = ulUinEnd;
}

int gm_check_uin(LPROLE pstRole)
{
	if (NULL == pstRole) 
	{
		return 0;
	}

	if ((pstRole->ulUin >= gs_ulUinBegin &&  pstRole->ulUin <= gs_ulUinEnd))
	{
		//在系统测试号段的都认为具有最高GM权限
		return GM_ROLE_FIRST;
	}
	return get_gmpower(pstRole);	
}

int gm_check_uin_i(unsigned int ulUin, unsigned int uiPlayerGMPower, unsigned char bRoleInDBGMPower)
{	
	if ((ulUin >= gs_ulUinBegin &&  ulUin <= gs_ulUinEnd))
	{
		//在系统测试号段的都认为具有最高GM权限
		return GM_ROLE_FIRST;
	}

	if (0 != uiPlayerGMPower)
	{
		return uiPlayerGMPower;
	}
	
	return bRoleInDBGMPower;	
}

int gm_check_official_right(LPROLE pstRole)
{
	if (NULL == pstRole) 
	{
		return 0;
	}
	
	if (pstRole->ulUin >= gs_ulUinBegin &&  pstRole->ulUin <= gs_ulUinEnd)
	{
		//测试号段都是GM权限
		return 1;
	}

	if (get_gmpower(pstRole))
	 {
		if(!(get_gmpower(pstRole) & GM_POWER_EIGHTH))
		{
			return 0;
		}
		return 1;
	}

    return 0;
}

//清理地图上怪物
int gm_clear_monster(LPROLE pstRole,const char*pszArg)
{

	if(NULL == pszArg || pstRole == NULL)
	{
		return -1;
	}

	char szTemp[128];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(strncmp(szTemp,"all",128) == 0)
	{
		//clear map all alived monster.
		system_msg_to_role(pstRole,"clear all map monster!!!");
		clear_mapinst_alived_monster(&pstRole->stObject.stMapInstIndex,0,MONSTER_DIE_MODE_SYS_RECALL);
	}		
	else if(strncmp(szTemp,"mon",128) == 0)
	{
		system_msg_to_role(pstRole,"clear gived monster.");
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0]) 	
		{
			unsigned int ulMonsterID= atoll(szTemp);
			clear_role_vision_alived_obj(pstRole,OBJ_MONSTER,ulMonsterID,MONSTER_DIE_MODE_SYS_RECALL);
		}
	}
	else
	{
		LPMAPINST   pstMapInst = find_map_inst_by_index(&pstRole->stObject.stMapInstIndex);

		//clear vision map monster.
		LPAREAINST pstAreaInst = pos_to_areainst(pstMapInst,&pstRole->stObject.stPos);	
		if(pstAreaInst == NULL)
		{
			system_msg_to_role(pstRole,"clear area monster failed. ");	
			return -1;
		}

		//clear_area_alived_monster(pstAreaInst,1,pstRole);
		clear_role_vision_alived_obj(pstRole,OBJ_MONSTER,0,MONSTER_DIE_MODE_SYS_RECALL);

		system_msg_to_role(pstRole,"clear area monster!!!");
	}

	return 0;
}

//清理视野内的物品
int gm_clear_visionitem(LPROLE pstRole,const char*pszArg)
{
	if(pstRole == NULL)
	{
		return -1;
	}
	clear_role_vision_alived_obj(pstRole,OBJ_ITEM,0,MONSTER_DIE_MODE_SYS_RECALL);
	
	system_msg_to_role(pstRole,"clear vision item!!!");
	return 0;
}

int gm_findrole(LPROLE pstRole, const char *pszArg)
{

	if(NULL == pszArg || pstRole == NULL)
	{
		return -1;
	}

	LPROLE pstFindRole = NULL;
	char szName[128];
	gm_get_val(&pszArg,szName,sizeof(szName));
	if (szName[0] == 0)
	{
		system_msg_to_role(pstRole,"Usage:findrole uin <uin> | rolename <name>");
		return -1;
	}
	if(strncmp(szName,"uin",128) == 0) 
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:findrole uin <uin> | rolename <name>");
			return -1;

		}
		pstFindRole = uin_to_role(atoll(szName));

	}
	else if(strncmp(szName,"rolename",128) == 0)
	{

		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:findrole uin <uin> | rolename <name>");
			return -1;

		}

		pstFindRole = name_to_role(szName);

	}
	else
	{
		system_msg_to_role(pstRole,"Usage:findrole uin <uin> | rolename <name>");
		return -1;

	}

	if(pstFindRole == NULL)
	{
		system_msg_to_role(pstRole,"role not online. not found.");	
		return -1;
	}

	unsigned int ulProcID = get_sys_entityid();
	unsigned int ulRoleID = 0;
	get_role_id_by_gid(&ulRoleID,pstFindRole->ullGID);	

	//show role info	
	char szMsg[1024] = { 0};
	snprintf(szMsg,sizeof(szMsg),"role(%u:%s) gid:%lld roleid:%d at pworldid(%d) mapid(%d) pos(%d:%d) birthzone:%d zoneid:%s",
		pstFindRole->ulUin,pstFindRole->szName,pstFindRole->ullGID,ulRoleID,MAP_INST_ID_TO_PWORLD_ID(pstFindRole->stObject.stMapInstIndex.ullID),MAP_INST_ID_TO_MAP_ID(pstFindRole->stObject.stMapInstIndex.ullID),pstFindRole->stObject.stPos.x,pstFindRole->stObject.stPos.y,pstFindRole->ucBirthZone,get_proc_str_by_id(ulProcID));		
	system_msg_to_role(pstRole,szMsg);
	return 0;

}

//恢复加好友功能
int gm_tmp_insert_data_to_db(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pszArg || NULL == pstRole)
	{
		return -1;
	}

	char szTmp[128];
	LPROLE pstTRole = NULL;
	unsigned int ulUin = 0;
	
	gm_get_val(&pszArg,szTmp,sizeof(szTmp));
	if (szTmp[0] == 0)
	{
		return -1;
	}

	ulUin = (unsigned int)atoll(szTmp);
	pstTRole = uin_to_role(ulUin);
	if (NULL == pstTRole)
	{
		return -1;
	}

	int iRet = 0;
	
	CHATMSG stChatMsg;
	memset(&stChatMsg, 0, sizeof(stChatMsg));
	stChatMsg.wWhich = WHICH_TMP_INSERT_DATA_TO_DB;
	stChatMsg.bType = CHAT_TMP_INSERT_DATA_TO_DB;
	stChatMsg.stWho.ullGid = pstTRole->ullGID;
	stChatMsg.stWho.nHead = pstTRole->iHeadImage;
	STRNCPY(stChatMsg.stWho.szName, pstTRole->szName, sizeof(stChatMsg.stWho.szName));

	REQUESTPKG stReqPkg;
	memset(&stReqPkg, 0 , sizeof(stReqPkg));
	stReqPkg.stBody.stChatTo = stChatMsg;
    	iRet = send_world_request(get_chat_svr_id(), pstTRole->ulUin , SS_CHATBUDDY_REQ, &stReqPkg, 0);

	return iRet;
}

//踢人
int gm_kickrole(LPROLE pstRole, const char *pszArg)
{

	if(NULL == pszArg || pstRole == NULL)
	{
		return -1;
	}

	char szName[128];
	//char szMsg[1024];
	LPROLE pstTRole = NULL;
	LPPLAYER pstTPlayer = NULL;
	LPFN_DEAL_STOP_PKG pfnDealStop = NULL;
	unsigned char bKickoffReason;
	unsigned int ulUin = 0;

	gm_get_val(&pszArg,szName,sizeof(szName));
	if (szName[0] == 0)
	{
		return -1;
	}

	if(strncmp(szName,"uin",128) == 0) 
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:kickrole uin <uin>  reason | rolename <name> reason");
			return -1;

		}
		ulUin = atoll(szName);
		pstTRole = uin_to_role(ulUin);

	}
	else if(strncmp(szName,"rolename",128) == 0)
	{

		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:kickrole uin <uin> reason | rolename <name> reason");
			return -1;

		}

		pstTRole = name_to_role(szName);

	}
	else
	{
		system_msg_to_role(pstRole,"Usage:kickrole uin <uin> reason | rolename <name> reason");
		return -1;

	}

	gm_get_val(&pszArg,szName,sizeof(szName));
	if (szName[0] == 0)
	{
		system_msg_to_role(pstRole,"Usage:kickrole uin <uin>  reason | rolename <name> reason");
		return -1;
	}
	bKickoffReason = (unsigned char)atol(szName);

	//如果角色不在本服在线的话 发全区全服踢人请求
	if (NULL == pstTRole)
	{
		//snprintf(szMsg, sizeof(szMsg), "[%s] is not online", szName);
		//szMsg[sizeof(szMsg)-1] = 0;
		//system_msg_to_role(pstRole, szMsg);

		if (0 != ulUin)
		{
			int iWorldID = 0;
			REQUESTPKG stReq;
			memset(&stReq, 0, sizeof(stReq));
			//向account发cluster级踢人请求
			stReq.stBody.stKickoffAccClusterReq.ulUin = ulUin;
			stReq.stBody.stKickoffAccClusterReq.bReason = ENM_LOGOUT_REASON_BLOCK_ROLE_OR_ACC;
			iWorldID = get_world_svr_id();
			if (0 > send_world_request(iWorldID, ulUin, SS_KICKOFF_ACC_CLUSTER_REQ, &stReq, 1))
			{
				log_info(LOG_ERR, "%s: send kickoff acc(%u) clusterly to world fail.", __FUNCTION__, ulUin);
				return -1;
			}
		}

		return 0;
	}

	pstTPlayer = role_to_player(pstTRole);
	if (NULL == pstTPlayer)
	{
		return -1;
	}
	pfnDealStop =  get_deal_stop_pkg();
	if (NULL == pfnDealStop)
	{
		return -1;
	}
	pfnDealStop(pstTPlayer, ENM_LOGOUT_REASON_GM_KICKOFF,__FUNCTION__);

	return 0;
}

/**
 **@desc 复活某角色
 **/
 int gm_revive_role(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pszArg || NULL == pstRole)
	{
		return -1;
	}

	int iRet = 0;
	char szName[128];
	char szMsg[1024];
	LPROLE pstTRole = NULL;

	gm_get_val(&pszArg, szName, sizeof(szName));
	if (0 == szName[0])
	{
		return -1;
	}
	
	if (0 == strncmp(szName, "uin", 128))
	{
		gm_get_val(&pszArg, szName, sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole, "Usage:reviverole uin <uin> | rolename <name> ");
			return -1;
		}
		pstTRole = uin_to_role(atoll(szName));
	}
	else if (0 == strncmp(szName, "rolename", 128))
	{
		gm_get_val(&pszArg, szName, sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole, "Usage:reviverole uin <uin> | rolename <name> ");
			return -1;
		}
		pstTRole = name_to_role(szName);
	}
	else
	{	
		system_msg_to_role(pstRole, "Usage:reviverole uin <uin> | rolename <name> ");
		return -1;
	}
	
	if (NULL == pstTRole)
	{
		snprintf(szMsg, sizeof(szMsg), "[%s] is not online", szName);
		szMsg[sizeof(szMsg) - 1] = 0;
		system_msg_to_role(pstRole, szMsg);
	}
	else
	{
		iRet = gm_health_revive(pstTRole);
		if (0 > iRet)
		{	
			system_msg_to_role(pstRole, "health revive failed!");
			return -1;
		}
		else
		{
			system_msg_to_role(pstRole, "health revive succeed!");
			//send_sys_notice_msg(pstTRole, NULL,CS_CODE_REVIVE_HEALTH_REVIVE, NULL, NULL, NULL,NULL);
		}
	}
	return 0;
}

int gm_boradcast(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pszArg || pstRole == NULL)
	{
		return -1;
	}

	char szTemp[128];
	LPSYSENV pstEnv = NULL;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0] == 0)
	{
		return -1;
	}

	pstEnv = get_sys_env();
	if (NULL == pstEnv)
	{
		return -1;
	}

	if (strncmp(szTemp,"use",128) == 0)
	{
		pstEnv->stConfig.bIsBoradcastPackage = 1;
		return 0;
	}
	else if (strncmp(szTemp, "nouse", 128) == 0)
	{
		pstEnv->stConfig.bIsBoradcastPackage = 0;
		return 0;
	}


	return -1;
}

int gm_senditem(LPROLE pstRole, const char *pszArg)
{
	log_info(LOG_TRACE,"%s: enter..", __FUNCTION__);

	char szID[32];
	char szNum[32];
	char szName[128];
	char szMsg[128];
	LPROLE pstTRole = NULL;
	int i = 0;
	int iRet = 0;

	int iID = 1;
	int iNum = 1;

	gm_get_val(&pszArg,szID,sizeof(szID));
	gm_get_val(&pszArg,szNum,sizeof(szNum));
	gm_get_val(&pszArg,szName,sizeof(szName));

	if (!szID[0] || !szNum[0] || !szName[0])
	{
		return -1;
	}

	LPITEM pstItem = NULL;

	iID     =   atoi(szID);
	iNum    =   atoi(szNum);
	
	pstTRole = name_to_role(szName);

	if (NULL == pstTRole)
	{
		log_info(LOG_ERR, "%s: faid name to role by name:%s.", __FUNCTION__,szName);
		return -1;
	}

	log_info(LOG_DEBUG,"%s:drop resid:%d number:%d ",__FUNCTION__,iID,iNum);
	for (i=0; i<iNum; ++i)
	{
		pstItem = dropitem_byresid(iID, 1,0,DROP_STATIC_ARM_SRC_GM, ENM_LOOT_CONTROL_CODE_NORMAL);
		if(pstItem == NULL)
		{
			log_info(LOG_ERR,"%s: fail to get new drop item.",__FUNCTION__);
			return -1;
		}
		
		iRet = put_item(pstTRole, pstItem, NULL, NULL, 1, 1);
		if (iRet)
		{
			snprintf(szMsg, sizeof(szMsg), "rendtime success[%d]", i);
			system_msg_to_role(pstRole, szMsg);
			return -1;
		}
					
	}

	return 0;
}

int gm_delitem(LPROLE pstRole, const char *pszArg)
{
	log_info(LOG_TRACE, "%s: enter..", __FUNCTION__);

	char szID[32];
	char szNum[32];
	char szName[128];
	char szMsg[128];
	LPROLE pstTRole = NULL;
	int i = 0;
	int iRet = 0;

	int iID = 1;
	int iNum = 1;

	gm_get_val(&pszArg, szID, sizeof(szID));
	gm_get_val(&pszArg, szNum, sizeof(szNum));
	gm_get_val(&pszArg, szName, sizeof(szName));

	if (!szID[0] || !szNum[0] || !szName[0])
	{
		return -1;
	}

	//LPITEM pstItem = NULL;

	iID = atoi(szID);
	iNum = atoi(szNum);

	pstTRole = name_to_role(szName);
	if (NULL == pstTRole)
	{
		log_info(LOG_ERR, "%s: failed name to role by name:%s.", __FUNCTION__, szName);
		return -1;
	}

	log_info(LOG_DEBUG, "%s: drop resid:%d number:%d ", __FUNCTION__, iID, iNum);
	for(i = 0; i < iNum; ++i)
	{
		iRet = remove_item_by_resid(pstTRole, iID, 1, 1, 1);
		if(0 == iRet || -1 == iRet)
		{
			log_info(LOG_ERR, "%s: fail to delete item.", __FUNCTION__);
			snprintf(szMsg, sizeof(szMsg), "fail to delete the [%d]ed item", i + 1);
			system_msg_to_role(pstRole, szMsg);
			return -1;
		}
	}

	send_sys_notice_msg(pstTRole, NULL,CS_CODE_GM_DELETE_ITEM_FROM_ROLE_COMMBAG, &iID, NULL, NULL,NULL);
	
	return 0;
}

int gm_close_all_sell(LPROLE pstRole)
{

	log_info(LOG_INFO,"%s:role(%u:%s) gm execute close all sell !!!!!",__FUNCTION__,pstRole->ulUin,pstRole->szName);

	// close all sell 
	LPROLEPOOL pstRolePool = NULL;
	LPROLE pstTRole = NULL;
	int i = 0;

	pstRolePool = get_role_pool();
	if (NULL == pstRolePool)
	{
		return -1;
	}
	
	for (i=0; i<MAX_ROLE; ++i)
	{
		pstTRole = (LPROLE)pstRolePool->sRole[i];
		if (pstTRole->stObject.ulID != 0)
		{	
			sell_close_list_force(pstTRole);
		}
	}	


	
	return 0;
}

int gm_sell(LPROLE pstRole,const char* pszArg)
{


	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:sell close <uin>/<all>");
		return -1;
	}

	if(strncmp(szTemp,"close",sizeof(szTemp)) == 0)
	{

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{

			system_msg_to_role(pstRole,"usage:sell close <uin>/<all>");
			return -1;	
		}

		if(strncmp(szTemp,"all", sizeof(szTemp)) == 0)
		{
			gm_close_all_sell(pstRole);
			return 0;
		}
		unsigned int ulUin = atoll(szTemp);	
		LPROLE pstTmpRole = uin_to_role(ulUin);
		if(pstTmpRole != NULL)
		{
			sell_close_list_force(pstTmpRole);	

		}
		else
		{
			system_msg_to_role(pstRole,"fail to close sell by uin:%u not found role.",__FUNCTION__,ulUin);

		}

	}

	return 0;
}

int gm_sellquery(LPROLE pstRole, const char* pszArg)
{
	if (NULL == pstRole)
	{
		return -1;
	}
	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:sellquery");
		return -1;
	}
	CSSELLQUERYC stReq;
	stReq.chOperation = CS_SELLQUERY_QUERY;
	stReq.stData.stQuery.bPage = 0;
	stReq.stData.stQuery.stConditions.nClass = atoi(szTemp);
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:sellquery");
		return -1;
	}
	stReq.stData.stQuery.stConditions.bNumSortType = atoi(szTemp);
	int i=0;
	for (i = 0; i < stReq.stData.stQuery.stConditions.bNumSortType; ++i)
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])	
		{
			system_msg_to_role(pstRole,"usage:sellquery");
			return -1;
		}
		stReq.stData.stQuery.stConditions.szSortType[i] = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])	
		{
			system_msg_to_role(pstRole,"usage:sellquery");
			return -1;
		}
		stReq.stData.stQuery.stConditions.szIsAsc[i] = atoi(szTemp);
	}

	process_sellquery_cmd(pstRole, &stReq);
	
	return 0;
}

int gm_minigame(LPROLE pstRole,const char* pszArg)
{

	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:minigame refresh  <dist> <angel>/kill <x Y> | minigame rank daily/week");
		return -1;
	}

	if(strncmp(szTemp,"rank",sizeof(szTemp)) == 0)
	{
		// 查询周排名和每日排名
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])
		{

			system_msg_to_role(pstRole,"usage:minigame refresh <dist>/kill <x y>/rank daily<week>");
			return -1;	
		}

		if(strncmp(szTemp,"daily", sizeof(szTemp)) == 0)
		{
			gm_get_val(&pszArg, szTemp, sizeof(szTemp));
			if (szTemp[0])
			{
				gm_report_minigame_daily_rank(pstRole,atoi(szTemp));
			}
			else
			{
				return -1;
			}

		}
		/**
		else if(strncmp(szTemp,"week",sizeof(szTemp)) == 0)
		{
			gm_report_minigame_week_rank(pstRole);
		}
		*/
	

	}


	return 0;

}

int gm_qboperation(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:qboperation query/charge");
		return -1;
	}
	
	LPPLAYER pstPlayer = role_to_player(pstRole);

    if(pstPlayer == NULL)
    {
            system_msg_to_role(pstRole,"fail to find player obj.");
            return -1;
    }

	CSQBACCINFOREQ stQbAccInfoReq;

	if(strncmp(szTemp,"query",sizeof(szTemp))== 0)
	{
		stQbAccInfoReq.chOpType = CS_QB_ACC_INFO_QUERY;

		process_qb_acc_req(pstPlayer,&stQbAccInfoReq);
	}
	else
	{
		//charge..

		pstPlayer->stSecuInfo.chQBAuthAnswer = -1;
		stQbAccInfoReq.chOpType = CS_QB_ACC_CHARGE;
		stQbAccInfoReq.stOpData.stQBAccCharge.iAmount = 1;
		stQbAccInfoReq.stOpData.stQBAccCharge.chAccountType = CS_QB_ACCOUNT_QB;
		process_qb_acc_req(pstPlayer,&stQbAccInfoReq);
	}
	
	return 0;
}

int gm_change_svr(LPROLE pstRole, const char *pszArg)
{
	char szMsg[1024];
	char szTemp[80];
	if(NULL == pszArg)
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		return -1;
	}
	if(!strncasecmp(szTemp, "qq", sizeof("qq")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])	
		{
			return -1;
		}
		unsigned int ulUin = atoll(szTemp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "目标不在线");
			return -1;
		}

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])	
		{
			return -1;
		}
		int iVal = atoi(szTemp);

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(!szTemp[0])	
		{
			return -1;
		}

		if(!strncasecmp(szTemp, "lasttime", sizeof("lasttime")))
		{
			if (0 == iVal)
			{
				sprintf(szMsg, "role gid=%llu name=%s lasttime=%d", 
						pstTargetRole->ullGID, pstTargetRole->szName, (int)pstTargetRole->tLastChgSvrTime);
				system_msg_to_role(pstRole, szMsg);
			}
			else
			{
				pstTargetRole->tLastChgSvrTime += iVal;
			}
		}
		else if (!strncasecmp(szTemp, "chgflag", sizeof("chgflag")))
		{
			if (0 == iVal)
			{
				sprintf(szMsg, "role gid=%llu name=%s chgflag=%d", 
						pstTargetRole->ullGID, pstTargetRole->szName, pstTargetRole->chChgSvrStat);
				system_msg_to_role(pstRole, szMsg);
			}
			else
			{
				pstTargetRole->chChgSvrStat += iVal;
			}
		}
	}
	else
	{
        return -1;
	}
	
	return 0;
}

int gm_dumprole(LPROLE pstRole, const char *pszArg)
{
	char szUin[80];
	char szType[80];
	unsigned int ulUin = 0;
	ROLEINDB stRoleData;
	LPROLE pstTRole = NULL;
	char szFileName[128];
	FILE *fp = NULL;


	gm_get_val(&pszArg,szUin,sizeof(szUin));
	gm_get_val(&pszArg,szType,sizeof(szType));

	if (szUin[0])
	{
		ulUin = strtoul(szUin, NULL, 10);
	}

	if(ulUin)
	{
		pstTRole = uin_to_role(ulUin);
	}
	else	
	{
		pstTRole = pstRole;
	}

	if (NULL == pstTRole)
	{
		return -1;
	}

	memset(&stRoleData, 0, sizeof(stRoleData));

	pack_role_info(&stRoleData, pstTRole);

	if (!strncmp(szType, "log", sizeof(szType)))
	{
		fp = safe_open_log_file(ulUin,get_sys_zoneid());
		struct timeval stCurrTime;
		gettimeofday(&stCurrTime, NULL);
		fprintf(fp, "[%s.%.6d]dump role Uin(%u): \n",  shortdatetime(stCurrTime.tv_sec), (int)stCurrTime.tv_usec, ulUin);
		db_dumprole_log(fp, &stRoleData);
		safe_close_log_file(fp);
	}
	else
	{
		snprintf(szFileName, sizeof(szFileName), "log/rolelog/%u-%s.xml", pstTRole->ulUin, pstTRole->szName);
		db_dumprole_xml(szFileName, &stRoleData);
	}

	
	return 0;
}

static void gm_award_help(LPROLE pstRole)
{/*{{{*/
	system_msg_to_role(pstRole, "award list uin-- show award list");
	system_msg_to_role(pstRole, "award pick uin awardId jade -- pick award");
}/*}}}*/

int gm_award(LPROLE pstRole, const char *pszArg)
{
	char szUin[80];
	char szJade[80];
	char szOp[80];
	char szAwardID[80];
	unsigned int ulUin = 0;
	int iJade = 0;
	LPROLE pstTRole = NULL;
	unsigned long long ullAwardID = 0;
	AWARDDATA stAward;

	gm_get_val(&pszArg,szOp,sizeof(szOp));
	if(!szOp[0])	
	{
		gm_award_help(pstRole);
		return -1;
	}
	gm_get_val(&pszArg,szUin,sizeof(szUin));
	if (!szUin[0])
	{
		gm_award_help(pstRole);
		return -1;
	}
	ulUin = strtoul(szUin, NULL, 10);

	pstTRole = uin_to_role(ulUin);
	if (NULL == pstTRole)
	{
		return -1;
	}


	else if (!strncmp(szOp, "list", sizeof(szOp)))
	{
		award_get_list(pstTRole, pstTRole->ulUin, pstTRole->ullGID, ENM_AWARD_REASON_JADE);
	}
	else if (!strncmp(szOp, "pick", sizeof(szOp)))
	{
		gm_get_val(&pszArg,szAwardID,sizeof(szAwardID));
		if (!szAwardID[0])
		{
			gm_award_help(pstRole);
			return -1;
		}
		ullAwardID = strtoull(szAwardID, NULL, 10);
		
		gm_get_val(&pszArg,szJade,sizeof(szJade));
		if (!szJade[0])
		{
			gm_award_help(pstRole);
			return -1;
		}
		iJade = atoi(szJade);

		memset(&stAward, 0, sizeof(stAward));
		stAward.ullAwardID	= ullAwardID;
		stAward.iJade = iJade;
		award_pick_up(pstTRole, &stAward);
	}
	else
	{
		gm_award_help(pstRole);
		return -1;
	}

	return 0;
}

int show_attr_for_debug_all(LPROLE pstRole,unsigned int ulObjectID,int iAttrID)
{
	//根据对象的OBJECTID 查询对象的基础属性

	char szMsg[1024];
	LPROLE pstTmpRole = zid_to_role(ulObjectID);
	if(pstTmpRole != NULL)
	{

			show_attr_for_debug(&pstTmpRole->stAttr,iAttrID,szMsg);
			system_msg_to_role(pstRole,szMsg);


	}		
	LPMONSTER pstTmpMonster = zid_to_monster(ulObjectID);
	if(pstTmpMonster != NULL)
	{

			show_attr_for_debug(&pstTmpMonster->stAttr,iAttrID,szMsg);
			system_msg_to_role(pstRole,szMsg);

	}
	return 0;

}

int gm_objectattr(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:objectattr <objectid> <attrid>");
		return -1;
	}

	unsigned int ulObjectID= atoll(szTemp);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])	
	{
		system_msg_to_role(pstRole,"usage:objectattr <objectid> <attrid>");
		return -1;
	}

	int iAttrID =atoi(szTemp);

	show_attr_for_debug_all(pstRole,ulObjectID,iAttrID);
	return 0;
}

int gm_set_systemtime(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	if(pstRole->ulUin < 4000 || pstRole->ulUin > 5000)
	{
		return -1;
	}
	
	int iRet = 0;
    char szBuff[256] = {'\0'};
    char szDate[64] = {'\0'};

    if(gm_get_val(&pszArg, szDate, sizeof(szDate)) < 0)
        return -1;

   if(!strncasecmp(szDate, "addsec", sizeof("addsec")))
   {
   	 if(gm_get_val(&pszArg, szBuff, sizeof(szBuff)) < 0)
        	return -1;

	set_systime_addsec(atoi(szBuff));
	return 0;
	
   } //else

	snprintf(szBuff, 256, "date -s \'%s\'", szDate);
	szBuff[255] = '\0';

    iRet = system(szBuff);
    if(iRet < 0)
        return iRet;

	return 0;
}

int gm_set_script_ctrlvar(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	
	int iRet = 0;
    char szBuff[256] = {'\0'};
    char szTemp[32] = {'\0'};
	int iID = 0;
	int iValue = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole,"Usage: //setscriptvar <ID> <Value>");
	}
	iID = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		system_msg_to_role(pstRole,"Usage: //setscriptvar <ID> <Value>");
	}
	iValue = atoi(szTemp);

	
	iRet = set_script_ctrlvar(iID, iValue);
	if(iRet == 0)
	{
		snprintf(szBuff, 256, "set script ctrl var successful. ID[%d] set to [%d]", iID,iValue);
	}
	else
	{
		snprintf(szBuff, 256, "set script ctrl var error. ID[%d] set to [%d]", iID,iValue);
	}
	system_msg_to_role(pstRole,szBuff);
	return 0;
}

int gm_block(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pszArg || NULL == pstRole)
	{
		return -1;
	}
	int iWorldID = 0;
	int lBlockTime = 0;
	unsigned int ulFindUin = 0;
	
	char szRoleName[32];
	char szName[256];
	char szMsg[1024];
		
	LPROLE pstFindRole = NULL;
	LPPLAYER pstTPlayer = NULL;
	LPFN_DEAL_STOP_PKG pfnDealStop = NULL;
	
	REQUESTPKG stReq;
	memset(&stReq, 0, sizeof(stReq));
	
	gm_get_val(&pszArg,szName,sizeof(szName));
	if (0 == szName[0])
	{
		system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
		return -1;
	}
	
	if(0 == strncmp(szName,"role",128)) 
	{
		//封角色
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
		STRNCPY(szRoleName, szName, sizeof(szRoleName));
		pstFindRole = name_to_role(szName);
		if (NULL != pstFindRole)
		{
			//此角色在线
			//先将此角色踢下线
			pstTPlayer = role_to_player(pstFindRole);
			if (NULL == pstTPlayer)
			{
				return -1;
			}
			pfnDealStop =  get_deal_stop_pkg();
			if (NULL == pfnDealStop)
			{
				return -1;
			}
			pfnDealStop(pstTPlayer, ENM_LOGOUT_REASON_BLOCK_ROLE_OR_ACC,__FUNCTION__);
		}
		//不管角色在线不在线都走下面的流程来封角色
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
		ulFindUin = atoll(szName);
			
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
		lBlockTime = atol(szName);
			
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (0 == szName[0])
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
			
		log_info(LOG_TRACE, "%s: block role (%u:%s) blocktime:%u", __FUNCTION__, ulFindUin, szRoleName, lBlockTime);

		stReq.stBody.stUpdateDB.bOp = ENM_UDO_BLOCK_ROLE;
		stReq.stBody.stUpdateDB.bDst = ENM_UPDATE_DB_DST_ROLE;
		stReq.stBody.stUpdateDB.stData.stBlockRole.lTime = lBlockTime;
		stReq.stBody.stUpdateDB.stData.stBlockRole.bBlockCode = 1;
		STRNCPY(stReq.stBody.stUpdateDB.stData.stBlockRole.szName, szRoleName, sizeof(stReq.stBody.stUpdateDB.stData.stBlockRole.szName));
		STRNCPY(stReq.stBody.stUpdateDB.stData.stBlockRole.szReason, szName, sizeof(stReq.stBody.stUpdateDB.stData.stBlockRole.szReason));
		stReq.stBody.stUpdateDB.stData.stBlockRole.ulUin = ulFindUin;
		iWorldID = get_world_svr_id();
		if (0 > send_world_request(iWorldID, pstRole->ulUin, SS_UPDATE_ROLE_DB_REQ, &stReq, 1))
		{
			log_info(LOG_ERR, "%s: send world fail", __FUNCTION__);
			return -1;
		}
		
		snprintf(szMsg,sizeof(szMsg),"block role (%u:%s) blocktime:%u", ulFindUin, szRoleName, lBlockTime);
		system_msg_to_role(pstRole,szMsg);
		
	}
	else if(0 == strncmp(szName,"acc",128))
	{
		//封帐号
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
		ulFindUin = atoll(szName);
		pstFindRole = uin_to_role(ulFindUin);
		if (NULL != pstFindRole)
		{
			//此帐号有角色在线
			//先踢角色
			pstTPlayer = role_to_player(pstFindRole);
			if (NULL == pstTPlayer)
			{
				return -1;
			}
			pfnDealStop =  get_deal_stop_pkg();
			if (NULL == pfnDealStop)
			{
				return -1;
			}
			pfnDealStop(pstTPlayer, ENM_LOGOUT_REASON_BLOCK_ROLE_OR_ACC,__FUNCTION__);
		}

		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}
		lBlockTime = atol(szName);

		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
			return -1;
		}

		stReq.stBody.stUpdateDB.bOp = ENM_UDO_BLOCK_ACC;
		stReq.stBody.stUpdateDB.bDst = ENM_UPDATE_DB_DST_ACCOUNT;
		stReq.stBody.stUpdateDB.stData.stBlockAcc.lTime = lBlockTime;
		stReq.stBody.stUpdateDB.stData.stBlockAcc.ulUin = ulFindUin;
		STRNCPY(stReq.stBody.stUpdateDB.stData.stBlockAcc.szReason, szName, sizeof(stReq.stBody.stUpdateDB.stData.stBlockAcc.szReason));
		iWorldID = get_world_svr_id();
		if (0 > send_world_request(iWorldID, pstRole->ulUin, SS_UPDATE_ROLE_DB_REQ, &stReq, 1))
		{
			log_info(LOG_ERR, "%s: send world fail", __FUNCTION__);
			return -1;
		}

		snprintf(szMsg,sizeof(szMsg),"block acc (%u) blocktime:%u", ulFindUin, lBlockTime);
		system_msg_to_role(pstRole,szMsg);
		
	}
	else
	{
		system_msg_to_role(pstRole,"Usage:block acc <uin> <time> <reason> | block role <nick> <uin> <time> <reason>");
		return -1;
	}

	//REQUESTPKG stReq;
	memset(&stReq, 0, sizeof(stReq));
	//int iWorldID = 0;
	//向account发cluster级踢人请求
	stReq.stBody.stKickoffAccClusterReq.ulUin = ulFindUin;
	stReq.stBody.stKickoffAccClusterReq.bReason = ENM_LOGOUT_REASON_BLOCK_ROLE_OR_ACC;
	iWorldID = get_world_svr_id();
	if (0 > send_world_request(iWorldID, ulFindUin, SS_KICKOFF_ACC_CLUSTER_REQ, &stReq, 1))
	{
		log_info(LOG_ERR, "%s: send kickoff acc(%u) clusterly to world fail.", __FUNCTION__, ulFindUin);
		return -1;
	}
	
	return 0;
}

/**
 *@desc 角色被gm禁言
 **/
 int gm_muterole(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iDay = 0;
	int iHour = 0;
	int iMinute = 0;
	LPROLE pstFindRole = NULL;
	char szName[128];

	gm_get_val(&pszArg, szName, sizeof(szName));
	if (szName[0] == 0)
	{
		system_msg_to_role(pstRole,"Usage:muterole uin <uin> <time> | rolename <name> <time>");
		return -1;
	}

	if(0 == strncmp(szName,"uin",128)) 
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:muterole uin <uin> <time> | rolename <name> <time>");
			return -1;

		}
		pstFindRole = uin_to_role(atoll(szName));
	}
	else if(0 == strncmp(szName,"rolename",128))
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:muterole uin <uin> <time> | rolename <name> <time>");
			return -1;

		}
		pstFindRole = name_to_role(szName);
	}
	else
	{
		system_msg_to_role(pstRole,"Usage:muterole uin <uin> | rolename <name>");
		return -1;

	}

	if (NULL == pstFindRole)
	{
		system_msg_to_role(pstRole, "role is not online!");
		return -1;
	}

	gm_get_val(&pszArg,szName,sizeof(szName));
	if (szName[0] == 0)
	{
		system_msg_to_role(pstRole,"Usage:muterole uin <uin> <time>| rolename <name> <time>");
		return -1;

	}

	log_info(LOG_TRACE,"%s: mute role (%u:%s) endtime:%s",__FUNCTION__,pstFindRole->ulUin,pstFindRole->szName,szName);
	
	//to mute role

	unsigned int ulUin = pstFindRole->ulUin;
	pstFindRole->iMuteEndTime = atol(szName) + time(NULL);

	char szMsg[1024];
	snprintf(szMsg, sizeof(szMsg), "mute role %d and mute time:%d", ulUin, (int)atol(szName));

	system_msg_to_role(pstRole, szMsg);

	iDay = atol(szName) / SECOND_IN_ONE_DAY;
	iHour = (atol(szName) - (iDay * SECOND_IN_ONE_DAY)) / SECOND_IN_ONE_HOUR;
	iMinute = (atol(szName) - (iDay * SECOND_IN_ONE_DAY) - (iHour * SECOND_IN_ONE_HOUR)) / SECOND_IN_ONE_MINUTE;
	send_sys_notice_msg(pstFindRole,NULL, CS_CODE_CHAT_BEING_BANNED_TALKING, &iDay, &iHour, &iMinute,NULL);
	
	return 0;
}

/**
 *@desc 角色被gm解除禁言
 **/
 int gm_unmuterole(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	LPROLE pstFindRole = NULL;
	char szName[128];

	gm_get_val(&pszArg, szName, sizeof(szName));
	if (szName[0] == 0)
	{
		system_msg_to_role(pstRole,"Usage:unmuterole uin <uin> | rolename <name> ");
		return -1;
	}

	if(0 == strncmp(szName,"uin",128)) 
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:unmuterole uin <uin> | rolename <name> ");
			return -1;

		}
		pstFindRole = uin_to_role(atoll(szName));
	}
	else if(0 == strncmp(szName,"rolename",128))
	{
		gm_get_val(&pszArg,szName,sizeof(szName));
		if (szName[0] == 0)
		{
			system_msg_to_role(pstRole,"Usage:unmuterole uin <uin> | rolename <name> ");
			return -1;

		}
		pstFindRole = name_to_role(szName);
	}
	else
	{
		system_msg_to_role(pstRole,"Usage:unmuterole uin <uin> | rolename <name> ");
		return -1;

	}

	if (NULL == pstFindRole)
	{
		system_msg_to_role(pstRole, "role is not online!");
		return -1;
	}

	log_info(LOG_TRACE,"%s: unmute role (%u:%s)",__FUNCTION__,pstFindRole->ulUin,pstFindRole->szName);
	
	//to unmute role

	unsigned int ulUin = pstFindRole->ulUin;
	pstFindRole->iMuteEndTime = time(NULL);

	char szMsg[1024];
	snprintf(szMsg, sizeof(szMsg), "unmute role %d .", ulUin);

	system_msg_to_role(pstRole, szMsg);

	send_sys_notice_msg(pstFindRole,NULL, CS_CODE_CHAT_CANCEL_BANNED_TALKING, NULL, NULL, NULL,NULL);
	
	return 0;
}

/**
 * desc : name to uin gid  
*/
int gm_namegid(LPROLE pstRole, const char *pszArg)
{
	char szOp[32];
	char szName[32];
	char szUin[32];
	char szGID[32];
	unsigned long long ullGID = 0;
	unsigned int ulUin = 0;;

	do {
		gm_get_val(&pszArg, szOp, sizeof(szOp));
		if (szOp[0] == 0)
		{
			break;
		}

		if (!strncmp(szOp, "set", sizeof(szOp)))
		{
			gm_get_val(&pszArg, szName, sizeof(szName));
			if (szName[0] == 0)
			{
				break;
			}

			gm_get_val(&pszArg, szUin, sizeof(szUin));
			if (szUin[0] == 0)
			{
				break;
			}
			ulUin = strtoul(szUin, NULL, 10);

			gm_get_val(&pszArg, szGID, sizeof(szGID));
			if (szGID[0] == 0)
			{
				break;
			}
			ullGID = strtoull(szGID, NULL, 10);

			update_gid_to_name_server(szName, ullGID, pstRole->ulUin);
			return 0;
		}
		else if(!strncmp(szOp, "get", sizeof(szOp)))
		{
			gm_get_val(&pszArg, szName, sizeof(szName));
			if (szName[0] == 0)
			{
				break;
			}
			
			get_role_name_id(szName, pstRole->ulUin, 0, ENM_GNGR_GM, 0);
			return 0;
		}
		else
		{
			break;	
		}
	}while(0);

	system_msg_to_role(pstRole,"Usage:name_to_uin_gid set name gid ");
	system_msg_to_role(pstRole,"Usage:name_to_uin_gid get name");
	return -1;
}

int gm_relation(LPROLE pstRole,const char*pszArg)
{
	#define TMP_RELATION_LIST 1
	#define TMP_RELATION_RESET 2
	#define TMP_RELATION_ROLLTICKET 3
	#define TMP_RELATION_ROLLINDEX 4

	char szTemp[80];
	short nCmd = 0;
	int iParam1 =0;
	int iParam2 =0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "relation list");
			system_msg_to_role(pstRole, "relation reset");
			system_msg_to_role(pstRole, "relation rollticket <Num>");
			system_msg_to_role(pstRole, "relation rollindex <Index1> <Index2>");
			system_msg_to_role(pstRole, "relation mentor checktime");
			system_msg_to_role(pstRole, "relation mentor set <maxlimit>");
			return 0;
		}
		if(!strncasecmp(szTemp, "list", sizeof("list")))
		{
			nCmd = TMP_RELATION_LIST;
		}
		else if(!strncasecmp(szTemp, "reset", sizeof("reset")))
		{
			nCmd = TMP_RELATION_RESET;
		}
		else if(!strncasecmp(szTemp, "rollticket", sizeof("rollticket")))
		{
			nCmd = TMP_RELATION_ROLLTICKET;
		}
		else if(!strncasecmp(szTemp, "rollindex", sizeof("rollindex")))
		{
			nCmd = TMP_RELATION_ROLLINDEX;
		}
		else if(!strncasecmp(szTemp, "mentor", sizeof("mentor")))
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(!szTemp[0])
			{
				return -1;
			}
			if(!strncasecmp(szTemp, "checktime", sizeof("checktime")))
			{
				struct timeval stTv;
				tick_mentor(_cur_tick_gettimeofday(&stTv), 1);
				return 0;
			}
			else if (!strncasecmp(szTemp, "set", sizeof("set")))
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(!szTemp[0])
				{
					return -1;
				}
				int iMaxLimit = atoi(szTemp);
				return set_max_num_mentor_reg_limit(iMaxLimit);
			}
		
			return 0;
		}
		
	}else
	{
		return -1;
	}
	snprintf(szTemp ,sizeof(szTemp) ,"0");
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		iParam1 = atoi(szTemp);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0])
		{
			iParam2 = atoi(szTemp);
		}
	}
	switch(nCmd)
	{
		case TMP_RELATION_LIST:
		{
			system_msg_to_role(pstRole, pack_relation_info());
			break;	
		}
		case TMP_RELATION_RESET:
		{
			gm_reset_relation_qualification();
			break;	
		}
		case TMP_RELATION_ROLLTICKET:
		{
			roll_assult_join_num(iParam1);
			break;	
		}
		case TMP_RELATION_ROLLINDEX:
		{
			roll_zone_qualification_index(iParam1,iParam2);
			break;	
		}
		default:
			system_msg_to_role(pstRole, "Unknow Coef.");
			break;
	}
	return 0;
}

/*序号ID为misc中的使用序号，当misc向zone发送消息时，统一使用活动ID，而zone向misc使用GM的时候，使用序号ID,(可以理解为只有Misc要求zone启动活动的时候使用活动ID，其他均使用序号)*/
int gm_act(LPROLE pstRole,const char*pszArg)
{
	#define TMP_ACT_CMD_QUERY 1
	#define TMP_ACT_CMD_OPEN 2
	#define TMP_ACT_CMD_CLOSE 3
	#define TMP_ACT_CMD_CHANGE_SLICE 4
	#define TMP_ACT_CMD_ADD_ZONE 5
	#define TMP_ACT_CMD_DEL_ZONE 6
	#define TMP_ACT_CMD_LIST 7
	#define TMP_ACT_CMD_DAILY 8

	char szTemp[80];
	short nCmd = 0;
	int iParam1 =-1;
	int iParam2 =-1;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "act list");
			system_msg_to_role(pstRole, "act query [act|ann] <ID>");
			system_msg_to_role(pstRole, "act open [act|ann] <ID>");
			system_msg_to_role(pstRole, "act close [act|ann] <ID>");
			system_msg_to_role(pstRole, "act slice [act|ann] <ID> <HH:MM:SS> <HH:MM:SS>");
			system_msg_to_role(pstRole, "act addzone [act|ann] <ID> <ZoneID1> ...");
			system_msg_to_role(pstRole, "act delzone [act|ann] <ID> <ZoneID1> ...");
			return 0;
		}
		if(!strncasecmp(szTemp, "query", sizeof("query")))
		{
			nCmd = TMP_ACT_CMD_QUERY;
		}
		else if(!strncasecmp(szTemp, "open", sizeof("open")))
		{
			nCmd = TMP_ACT_CMD_OPEN;
		}
		else if(!strncasecmp(szTemp, "close", sizeof("close")))
		{
			nCmd = TMP_ACT_CMD_CLOSE;
		}
		else if(!strncasecmp(szTemp, "slice", sizeof("slice")))
		{
			nCmd = TMP_ACT_CMD_CHANGE_SLICE;
		}
		else if(!strncasecmp(szTemp, "addzone", sizeof("addzone")))
		{
			nCmd = TMP_ACT_CMD_ADD_ZONE;
		}
		else if(!strncasecmp(szTemp, "delzone", sizeof("delzone")))
		{
			nCmd = TMP_ACT_CMD_DEL_ZONE;
		}
		else if(!strncasecmp(szTemp, "list", sizeof("list")))
		{
			nCmd = TMP_ACT_CMD_LIST;
		}
		else if(!strncasecmp(szTemp, "today", sizeof("today")))
		{
			nCmd = TMP_ACT_CMD_DAILY;
		}		
		
	}else
	{
		return -1;
	}

	snprintf(szTemp ,sizeof(szTemp) ,"0");
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!strncasecmp(szTemp, "ann", sizeof("ann")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0)
		{
			iParam2 = atoi(szTemp);
		}
	}
	else if(!strncasecmp(szTemp, "act", sizeof("act")))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0)
		{
			iParam1 = atoi(szTemp);
		}
	}
	else
	{
		//默认act
		iParam1 = atoi(szTemp);
	}

	
	
	
	switch(nCmd)
	{
		case TMP_ACT_CMD_QUERY:
		{
			act_deal_misc_gmquery(pstRole, iParam1,iParam2);
			break;	
		}
		case TMP_ACT_CMD_OPEN:
		{
			act_deal_misc_gmopen(pstRole, iParam1,iParam2);
			break;	
		}
		case TMP_ACT_CMD_CLOSE:
		{
			act_deal_misc_gmclose(pstRole, iParam1,iParam2);
			break;	
		}
		case TMP_ACT_CMD_CHANGE_SLICE:
		{
			int iHour,iMin,iSec;
			int iEndHour,iEndMin,iEndSec;

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				return system_msg_to_role(pstRole, "act slice [act|ann] <ID>  <HH:MM:SS> <HH:MM:SS>");
			}
			if(splittimeSlice(szTemp, &iHour,&iMin,&iSec) < 0)
			{
				return system_msg_to_role(pstRole, "act slice [act|ann] <ID>  <HH:MM:SS> <HH:MM:SS>");
			}

			if(iParam2 == -1)
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				if(szTemp[0] == 0)
				{
					return system_msg_to_role(pstRole, "act slice [act|ann] <ID>  <HH:MM:SS> <HH:MM:SS>");
				}
				if(splittimeSlice(szTemp, &iEndHour,&iEndMin,&iEndSec) < 0)
				{
					return system_msg_to_role(pstRole, "act slice [act|ann] <ID>  <HH:MM:SS> <HH:MM:SS>");
				}
			}
			act_deal_misc_gm_chgslice(pstRole, iParam1,iParam2,0,iHour,iMin,iSec,iEndHour,iEndMin,iEndSec);
			break;	
		}
		case TMP_ACT_CMD_ADD_ZONE:
		{
			unsigned char bZoneID[CS_MAX_ZONE_NUMBER];
			int iNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			while(szTemp[0] != 0 && iNum < CS_MAX_ZONE_NUMBER)
			{
				bZoneID[iNum] = atoi(szTemp);
				++iNum;
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			}
			
			act_deal_misc_gm_addzone(pstRole, iParam1,iParam2,iNum,bZoneID,1);
			break;	
		}
		case TMP_ACT_CMD_DEL_ZONE:
		{
			unsigned char bZoneID[CS_MAX_ZONE_NUMBER];
			int iNum = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			while(szTemp[0] != 0 && iNum < CS_MAX_ZONE_NUMBER)
			{
				bZoneID[iNum] = atoi(szTemp);
				++iNum;
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			}
			
			act_deal_misc_gm_addzone(pstRole, iParam1,iParam2,iNum,bZoneID,0);
			break;	
		}
		case TMP_ACT_CMD_LIST:
		{
			return send_act_msg_to_role(pstRole);
			break;
		}
		case TMP_ACT_CMD_DAILY:
		{
			return send_daily_act_msg_to_role(pstRole);
			break;
		}
		default:
			return -1;
	}
	return 0;
}

int gm_recharge_raffle(LPROLE pstRole,const char*pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}

#define GENERAL_RECHARGE_COMM_PRIZEPOOL 0 //充值翻翻奖池
#define GENERAL_BLESS_TOTAL_POINT 0 //累计获得祈福点值
#define GENERAL_BLESS_CURR_POINT 1 //当前剩余祈福点值
#define GENERAL_BLESS_CURR_VALUE 2 //当前剩余祈福原值

	char szTmp[128];
	char szMsg[1024];

	int i, j, iRet;
	int iArray[5];

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	if (!szTmp[0])
	{
		return -1;
	}

	if(!strncasecmp(szTmp, "info", sizeof("info")))
	{
		for ( i = 0 , j = 0 ; i < ACT_DATA_FOR_ROLE_VALUE_MAX ; i++ )
		{
			iRet = get_role_act_event_var(pstRole, MINIGAME_RECHARGE_RAFFLE_ACT_ID, i, &iArray[j]);
			j++;
			if (0 != iRet)
			{
				return -1;
			}
			if ( (i+1)%5 == 0)
			{
				snprintf(szMsg, sizeof(szMsg), 
						"%d=%d %d=%d %d=%d %d=%d %d=%d", 
						i-4,iArray[0],i-3,iArray[1],i-2,iArray[2],i-1,iArray[3],i,iArray[4]);
				j = 0;
				system_msg_to_role(pstRole,szMsg);
			}
		}
	}

	if(!strncasecmp(szTmp, "set", sizeof("set")))
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (!szTmp[0])
		{
			return -1;
		}
		iArray[0] = atoi(szTmp);

		if (iArray[0] < 0 || iArray[0] >= ACT_DATA_FOR_ROLE_VALUE_MAX)
		{
			return -1;
		}

		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (!szTmp[0])
		{
			return -1;
		}
		iArray[1] = atoi(szTmp);
		iRet = set_role_act_event_var(pstRole, MINIGAME_RECHARGE_RAFFLE_ACT_ID,	iArray[0], iArray[1]);
		if (0 != iRet)
		{
			return -1;
		}
	}
	
	if(!strncasecmp(szTmp, "comm", sizeof("comm")))
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (!szTmp[0])
		{
			return -1;
		}
		iArray[0] = atoi(szTmp);
		int iPrizePool;
		//获取奖池数额
		iRet = get_comm_act_event_var(MINIGAME_RECHARGE_RAFFLE_ACT_ID, GENERAL_RECHARGE_COMM_PRIZEPOOL, &iPrizePool);
		if (0 != iRet)
		{
			log_info_m(LOG_MODULE_ACT, LOG_ERR, "%s: get recharge prizepool[%d] error", __FUNCTION__, iPrizePool);
			return -1;
		}
	
		if (0 == iArray[0])
		{
			snprintf(szMsg, sizeof(szMsg), "PrizePool Value: %d", iPrizePool);
			system_msg_to_role(pstRole,szMsg);
		}
		else
		{
			iPrizePool += iArray[0];
			//更新奖池数额
			iRet = set_comm_act_event_var(MINIGAME_RECHARGE_RAFFLE_ACT_ID, GENERAL_RECHARGE_COMM_PRIZEPOOL, iPrizePool);
			if (0 != iRet)
			{
				log_info_m(LOG_MODULE_ACT, LOG_ERR, "%s: set recharge prizepool[%d] error", __FUNCTION__, iPrizePool);
				return -1;
			}
		}
	}

	if(!strncasecmp(szTmp, "bless", sizeof("bless")))
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (!szTmp[0])
		{
			return -1;
		}

		LPACTNEWYEARBLESSDATA pstNewYearBlessData = get_newyear_bless_comm_act_data();
		if (NULL == pstNewYearBlessData)
		{
			//通用活动数据获取失败
			log_info_m(LOG_MODULE_ACT, LOG_ERR, "%s: get act recharge bless data error", __FUNCTION__);
			return -1;
		}

		if(!strncasecmp(szTmp, "tree", sizeof("tree")))
		{
			if (pstNewYearBlessData->chTreeNum <= 0)
			{
				snprintf(szMsg, sizeof(szMsg), "==Tree Num: %d==", pstNewYearBlessData->chTreeNum);
				system_msg_to_role(pstRole,szMsg);
			}
			else
			{
				snprintf(szMsg, sizeof(szMsg), "==Tree Num: %d==", pstNewYearBlessData->chTreeNum);
				system_msg_to_role(pstRole,szMsg);
				int i;
				for ( i = 0 ; i < pstNewYearBlessData->chTreeNum && i < RECHARGE_BLESS_MAX_TREE_NUM ; i++ )
				{
					snprintf(szMsg, sizeof(szMsg), 
							"Tree: %d\nlistid=%u x=%d y=%d gid=%"PRIu64" name=%s ble=%d sub=%d add=%d", 
							i+1,
							pstNewYearBlessData->astTreeData[i].ulNPCObjID,
							pstNewYearBlessData->astTreeData[i].iXVal,
							pstNewYearBlessData->astTreeData[i].iYVal,
							pstNewYearBlessData->astTreeData[i].ullGID,
							pstNewYearBlessData->astTreeData[i].szName,
							pstNewYearBlessData->astTreeData[i].iBlessVal,
							pstNewYearBlessData->astTreeData[i].iSubVal,
							pstNewYearBlessData->astTreeData[i].iAddPoint);
					system_msg_to_role(pstRole,szMsg);
				}
			}
		}
		if(!strncasecmp(szTmp, "del", sizeof("del")))
		{
			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			iArray[0] = atoi(szTmp);

			if (iArray[0] < 0)
			{
				return -1;
			}

			if (pstNewYearBlessData->chTreeNum <= 0)
			{
				return 0;
			}
			if (iArray[0] >= pstNewYearBlessData->chTreeNum)
			{
				return -1;
			}
			log_info_m(LOG_MODULE_ACT, LOG_ERR, 
					   "%s: GM del christmas tree:[listid=%u gid=%"PRIu64" name=%s bleval=%d subval=%d addpoint=%d].",
					   __FUNCTION__, 
					   pstNewYearBlessData->astTreeData[iArray[0]].ulNPCObjID,
					   pstNewYearBlessData->astTreeData[iArray[0]].ullGID,
					   pstNewYearBlessData->astTreeData[iArray[0]].szName,
					   pstNewYearBlessData->astTreeData[iArray[0]].iBlessVal,
					   pstNewYearBlessData->astTreeData[iArray[0]].iSubVal,
					   pstNewYearBlessData->astTreeData[iArray[0]].iAddPoint);
			if (iArray[0] == pstNewYearBlessData->chTreeNum - 1)
			{
				pstNewYearBlessData->chTreeNum--;
			}
			else
			{
				pstNewYearBlessData->astTreeData[iArray[0]] 
					= pstNewYearBlessData->astTreeData[pstNewYearBlessData->chTreeNum-1];
				pstNewYearBlessData->chTreeNum--;
			}
		}
		if(!strncasecmp(szTmp, "rank", sizeof("rank")))
		{
			if (pstNewYearBlessData->bRoleNum <= 0)
			{
				snprintf(szMsg, sizeof(szMsg), "==Role Num: %d==", pstNewYearBlessData->bRoleNum);
				system_msg_to_role(pstRole,szMsg);
			}
			else
			{
				snprintf(szMsg, sizeof(szMsg), "==Role Num: %d==", pstNewYearBlessData->bRoleNum);
				system_msg_to_role(pstRole,szMsg);
				int i;
				for ( i = 0 ; i < pstNewYearBlessData->bRoleNum && i < RECHARGE_BLESS_MAX_RANK_SIZE ; i++ )
				{
					snprintf(szMsg, sizeof(szMsg), 
							"Role: %d gid=%"PRIu64" name=%s total=%d lvl=%d pro=%d", 
							i+1,
							pstNewYearBlessData->astBlessRank[i].ullGID,
							pstNewYearBlessData->astBlessRank[i].szName,
							pstNewYearBlessData->astBlessRank[i].iTotalPoint,
							pstNewYearBlessData->astBlessRank[i].bLevel,
							pstNewYearBlessData->astBlessRank[i].chProf);
					system_msg_to_role(pstRole,szMsg);
				}
			}
		}
		if(!strncasecmp(szTmp, "rankreset", sizeof("rankreset")))
		{
			pstNewYearBlessData->bRoleNum = 0;
		}
		if(!strncasecmp(szTmp, "rankrole", sizeof("rankrole")))
		{
			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			unsigned long long ullGIDTmp = strtoull(szTmp, NULL, 10);

			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			iArray[0] = atoi(szTmp);

			bless_update_newyear_bless_rank_by_gid(ullGIDTmp, iArray[0]);

		}
		if(!strncasecmp(szTmp, "ranktest", sizeof("ranktest")))
		{
			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			iArray[0] = atoi(szTmp);
			test_update_general_rank(iArray[0]);
		}
		if(!strncasecmp(szTmp, "recvr", sizeof("recvr")))
		{
			if (0 != recvr_all_bless_tree_in_map())
			{
				log_info_m(LOG_MODULE_GM, LOG_ERR, "%s: GM[actraffle bless recvr] recover tree fail.", __FUNCTION__);
				return -1;
			}
		}
		if(!strncasecmp(szTmp, "clr", sizeof("clr")))
		{
			if (0 != clr_all_bless_tree_in_map())
			{
				log_info_m(LOG_MODULE_GM, LOG_ERR, "%s: GM[actraffle bless clr] clear all tree fail.", __FUNCTION__);
				return -1;
			}
		}
		if(!strncasecmp(szTmp, "info", sizeof("info")))
		{
			int iRet, iTotalPoint, iBlessPoint, iBlessVal;
			iRet = get_role_act_event_var(pstRole, MINIGAME_NEWYEAR_BLESS_DATA_ACT_ID, 
					GENERAL_BLESS_TOTAL_POINT, &iTotalPoint);
			if (0 != iRet) { return -1; }
			iRet = get_role_act_event_var(pstRole, MINIGAME_NEWYEAR_BLESS_DATA_ACT_ID, 
					GENERAL_BLESS_CURR_POINT, &iBlessPoint);
			if (0 != iRet) { return -1; }
			iRet = get_role_act_event_var(pstRole, MINIGAME_NEWYEAR_BLESS_DATA_ACT_ID, 
					GENERAL_BLESS_CURR_VALUE, &iBlessVal);
			if (0 != iRet) { return -1; }
			snprintf(szMsg, sizeof(szMsg), "total(0)=%d curr(1)=%d bless(2)=%d", iTotalPoint, iBlessPoint, iBlessVal);
			system_msg_to_role(pstRole,szMsg);
		}
		if(!strncasecmp(szTmp, "set", sizeof("set")))
		{
			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			iArray[0] = atoi(szTmp);
			if (iArray[0] < 0 || iArray[0] > 2)
			{
				return -1;
			}
			gm_get_val(&pszArg, szTmp, sizeof(szTmp));
			if (!szTmp[0])
			{
				return -1;
			}
			iArray[1] = atoi(szTmp);
			int iRet;
			iRet = set_role_act_event_var(pstRole, MINIGAME_NEWYEAR_BLESS_DATA_ACT_ID, iArray[0], iArray[1]);
			if (0 != iRet) { return -1; }
		}
	}
	return 0;
}

int gm_lootprob_test(LPROLE pstRole,const char*pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	//该操作仅提供测试，会耗尽系统cpu，因此不对外开放
	if(pstRole->ulUin < 4000 || pstRole->ulUin > 5000)
	{
		return -1;
	}

	int iMaxLootItemProb = -1;
	int iMaxLootItemPos = -1;
	int iTmpLootItemProb = 0;
	int i , j;
	int iID = 0;
	int iTimes = 100;
	char szTemp[80];
	char szInfo[1024];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] == 0)
	{
		return system_msg_to_role(pstRole, "No LootID input");
	}
	iID = atoi(szTemp);
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] == 0)
	{
		system_msg_to_role(pstRole, "Default Times = 1000");
	}
	else
	{
		iTimes = atoi(szTemp);
	}


	int aiHitNum[MAX_LOOT_ITEM];
	memset(aiHitNum,0,sizeof(aiHitNum));

	LPRESLOOTSOLUTION pstResLootSolution = NULL;
	pstResLootSolution = find_loot_solution_by_resid(iID, NULL);
	if(pstResLootSolution == NULL)
	{
		return system_msg_to_role(pstRole, "Not Find LootID.");
	}

	switch(pstResLootSolution->chLootType)
	{
		case RES_LOOT_TYPE_CHOOSE_BY_RATIO:
		{
			//在MinNum和MaxNum中随机一个数字，并根据需要衰减
			int iLootNum = rand_range(pstResLootSolution->chMinNum, pstResLootSolution->chMaxNum);
			if(pstResLootSolution->chMinNum > 0 && iLootNum <= 0)
			{
				//为保证副本最少获得一个物品，这里进行强制限制
				iLootNum = 1;
			}

			int iCurTimes = 0;
			int iRandProp = 0;
			for(iCurTimes = 0; iCurTimes < iTimes; ++iCurTimes)
			{
				for(i = 0; i < iLootNum; ++i)
				{
					//初始化
					iMaxLootItemPos = -1;
					iRandProp = rand_range(1,RES_LOOT_DENOMINATOR);
					for(j = 0; j < pstResLootSolution->chLootNumber; ++j)
					{
						if(iRandProp <= pstResLootSolution->astLoot[j].iProb)
						{
							iMaxLootItemPos = j;
							break;
						}

						iRandProp -= pstResLootSolution->astLoot[j].iProb;
					}
					

					//找到按照比值掉落的物品位置
					if(iMaxLootItemPos >= 0 && iMaxLootItemPos < pstResLootSolution->chLootNumber)
					{
						aiHitNum[iMaxLootItemPos] ++;
					}

				}
			}
			break;
		}
		case RES_LOOT_TYPE_CHOOSE_BY_PROB:
		{
			//在MinNum和MaxNum中随机一个数字，并根据需要衰减
			int iLootNum = rand_range(pstResLootSolution->chMinNum, pstResLootSolution->chMaxNum);
			if(pstResLootSolution->chMinNum > 0 && iLootNum <= 0)
			{
				//为保证副本最少获得一个物品，这里进行强制限制
				iLootNum = 1;
			}

			int iCurTimes = 0;
			for(iCurTimes = 0; iCurTimes < iTimes; ++iCurTimes)
			{
				for(i = 0; i < iLootNum; ++i)
				{

					//初始化，开始选择一个物品
					iMaxLootItemProb = -1;
					iMaxLootItemPos = -1;

					//将所有可掉落物品，从0 到 该掉落物的最大掉落概率取一个随机数
					for(j = 0; j < pstResLootSolution->chLootNumber; ++j)
					{
						iTmpLootItemProb  = rand_range(0, pstResLootSolution->astLoot[j].iProb);
						if(iMaxLootItemProb < iTmpLootItemProb)
						{
							iMaxLootItemProb = iTmpLootItemProb;
							iMaxLootItemPos = j;
						}
					}

					//找出最大的值
					if(iMaxLootItemPos >= 0 && iMaxLootItemPos < pstResLootSolution->chLootNumber)
					{
						aiHitNum[iMaxLootItemPos] ++;
					}

				}
			}
			break;
		}
		default:
			return system_msg_to_role(pstRole, "Not Support This Loot Type.");
			break;
	}

	


	szInfo[0] = 0;
	snprintf(szInfo+strlen(szInfo),sizeof(szInfo) - strlen(szInfo),"Loot[%d] LootType[%d]\n",pstResLootSolution->iID,pstResLootSolution->chLootType);
	snprintf(szInfo+strlen(szInfo),sizeof(szInfo) - strlen(szInfo),"MinLoot[%d] MaxLoot[%d]\n",pstResLootSolution->chMinNum,pstResLootSolution->chMaxNum);
	snprintf(szInfo+strlen(szInfo),sizeof(szInfo) - strlen(szInfo),"ItemConf[%d] TestTimes[%d]\n",pstResLootSolution->chLootNumber,iTimes);
	system_msg_to_role(pstRole, szInfo);
	for(i = 0; i < pstResLootSolution->chLootNumber;++i)
	{
		LPRESLOOT pstLoot = &pstResLootSolution->astLoot[i];
		snprintf(szInfo,sizeof(szInfo),"%d) Prob[%d] HitTimes[%d]\n   RealProb[%f]\n",i,pstLoot->iProb,aiHitNum[i],(float)((aiHitNum[i] * 1.0f)/iTimes));
		system_msg_to_role(pstRole, szInfo);
	}

	
	return 0;
}

/* 精炼曲线分析GM指令 */
int gm_refine_test(LPROLE pstRole,const char*pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	//该操作仅提供测试，会耗尽系统cpu，因此不对外开放
	if(pstRole->ulUin < 4000 || pstRole->ulUin > 5000)
	{
		return -1;
	}

	#define REFINE_TEST_MODE_1 1
	#define REFINE_TEST_MODE_2 2
	#define REFINE_TEST_MODE_3 3

	#define REFINE_STUFF_ID 20346030
	#define REFINE_STUFF_PIPLENUM 10
	log_info_m(LOG_MODULE_TEST,LOG_ERR, "====================Begin==================");
	int iMode = 0;
	int iArmID = 0;

	char szTemp[80];
	char szResInfo[256];
	char szGenArm[256];
	char szGenStuff[256];
	CSREFINEDATA stRefineC;
	LPREFINEBASELIB pstRefineLib;
	LPZONEITEM pstZoneArm = NULL;
	LPZONEITEM pstZoneStuff = NULL;
	int i ,j ;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] == 0)
	{
		system_msg_to_role(pstRole, "No Mode input");
		return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<RefineTimes> <AppointLevel>] | [<WantNum> <RefineLevel>]");
	}
	
	iMode = atoi(szTemp);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] == 0)
	{
		system_msg_to_role(pstRole, "No ArmID input");
		return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<RefineTimes> <AppointLevel>] | [<WantNum> <RefineLevel>]");
	}
	
	iArmID = atoi(szTemp);
	
	switch(iMode)
	{
		case REFINE_TEST_MODE_1:
		{
			int iRefineTimes = 0;
			int iAppointLevel = 0;
			int iTestTimes = 0;
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No TestTime input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<TestArmNum> <RefineTimes> <AppointLevel>]");
			}
			
			iTestTimes = atoi(szTemp);
	
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No RefineTimes input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<TestArmNum>  <RefineTimes> <AppointLevel>]");
			}
			
			iRefineTimes = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No AppointLevel input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<TestArmNum>  <RefineTimes> <AppointLevel>]");
			}
			
			iAppointLevel = atoi(szTemp);
			if(iAppointLevel <= 0 || iAppointLevel > MAX_REFINEBASE_TIMES)
			{
				return system_msg_to_role(pstRole, "AppointLevel Error");
			}
			
			snprintf(szGenArm ,256 ,"%d",iArmID);
			for(i = 0 ; i < iTestTimes; ++i)
			{
				int iCousumeSum = 0;
				int iSucSum = 0;
				int iFailSum = 0;
				int aiSucc[MAX_REFINEBASE_TIMES] = {0};
				int aiFail[MAX_REFINEBASE_TIMES] = {0};
				int aiConsume[MAX_REFINEBASE_TIMES] = {0};
			
				gm_clearbag(pstRole, (const char*)NULL);
				if(gm_item(pstRole, (const char*)&szGenArm) < 0)
				{
					return system_msg_to_role(pstRole, "Create Arm Err");
				}
				pstZoneArm = &pstRole->stRoleItem.stData.stCommItem.astItems[0];
				if(pstZoneArm->iResId != iArmID)
				{
					return system_msg_to_role(pstRole, "refinetest <Mode><ArmID> [<TestArmNum>  <RefineTimes> <AppointLevel>]");
				}
				
				stRefineC.stItemID.chType = CS_LISTTYPE_COMMITEM;
				stRefineC.stItemID.chItemIndex = pstZoneArm->chGridIndex;
				stRefineC.stItemID.chNum = pstZoneArm->chNumber;
				stRefineC.stItemID.chBagIndex = 0;
				//stRefineC.chUseCharmDirect = 1;
				
				for(j = 0 ; j < iRefineTimes; ++j)
				{
					int iToRefine = pstZoneArm->stItemAttr.stArmAttr.chRefineNum + 1;
					char chBefore = pstZoneArm->stItemAttr.stArmAttr.chRefineNum;
					char chRefineResult = -1;
					pstRefineLib = find_refine_base_lib_by_refine_num(iToRefine);
					if (NULL == pstRefineLib)
					{
						return system_msg_to_role(pstRole, "Error 1");
					}
					int iStuffNum = pstRefineLib->nConsumeNum;
					iCousumeSum += iStuffNum;
					aiConsume[iToRefine-1] += iStuffNum;

					stRefineC.nTotal = 0;

					if(pstRole->stRoleItem.iBagMoney < 10000000)
					{
						change_role_property(pstRole,10000000, 0, 0, 0, LOG_PROPERTY_GM_CMD);
					}
					//生成材料
					while(iStuffNum > 0)
					{
						snprintf(szGenStuff ,256 ,"%d  %d",REFINE_STUFF_ID,iStuffNum > REFINE_STUFF_PIPLENUM ? REFINE_STUFF_PIPLENUM : iStuffNum);
						iStuffNum -= REFINE_STUFF_PIPLENUM;
						
						if(gm_item(pstRole, (const char*)&szGenStuff) < 0)
						{
							return system_msg_to_role(pstRole, "Create Stuff Err");;
						}
						pstZoneStuff = &pstRole->stRoleItem.stData.stCommItem.astItems[pstRole->stRoleItem.stData.stCommItem.iCount - 1];
						stRefineC.astUsedItemID[stRefineC.nTotal].chType = CS_LISTTYPE_COMMITEM;
						stRefineC.astUsedItemID[stRefineC.nTotal].chItemIndex = pstZoneStuff->chGridIndex;
						stRefineC.astUsedItemID[stRefineC.nTotal].chNum = pstZoneStuff->chNumber;
						stRefineC.astUsedItemID[stRefineC.nTotal].chBagIndex = 0;
						++stRefineC.nTotal;
					}

					int iRet = refine_arm_base(pstRole, &stRefineC, &chBefore, &chRefineResult);
					if(iRet == 0)
					{
						++iSucSum;
						++aiSucc[iToRefine-1];
					}
					else if(iRet == CS_CODE_ARM_REFINE_FAILED)
					{
						++iFailSum;
						++aiFail[iToRefine-1];
					}
					else
					{
						snprintf(szResInfo ,256 ,"Refine Base Error Ret %d",iRet);
						log_info_m(LOG_MODULE_TEST,LOG_ERR, szResInfo);
						return system_msg_to_role(pstRole, szResInfo);
					}

					if(pstZoneArm->stItemAttr.stArmAttr.chRefineNum >= iAppointLevel)
					{
						//++j;
						pstZoneArm->stItemAttr.stArmAttr.chRefineNum = 0;
						change_arm_basevalue_i(pstZoneArm,0);//改装备属性
						//break;
					}
				
				}

				int k=0;
				for (k=0; k<iAppointLevel; k++)
				{
					log_info_m(LOG_MODULE_TEST,LOG_ERR, "Test %d MaxRefine %d AppointLevel %d CurRefine %d Suc %d Fail %d Consume %d",
						i, iRefineTimes, iAppointLevel, k+1, aiSucc[k], aiFail[k], aiConsume[k]);
				}
				//log_info_m(LOG_MODULE_TEST,LOG_ERR, "Test %d MaxRefine %d CurRefine %d OutLevel %d AppointLevel %d Suc %d Fail %d Consume %d",
				//	i,iRefineTimes,j,pstZoneArm->stItemAttr.stArmAttr.chRefineNum,iAppointLevel,iSucSum,iFailSum,iCousumeSum);
				
			}

			break;
		}
		case REFINE_TEST_MODE_2:
		{
			int iWantNum = 0;
			int iOut = 0;
			int iWantRefineLevel = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No WantNum input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<WantNum> <RefineLevel>]");
			}
			
			iWantNum = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No WantRefineLevel input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<WantNum> <RefineLevel>]");
			}
			iWantRefineLevel = atoi(szTemp);
			if(iWantRefineLevel <= 0 || iWantRefineLevel > MAX_REFINEBASE_TIMES)
			{
				return system_msg_to_role(pstRole, "iWantRefineLevel Error");
			}

			while(iOut < iWantNum)
			{
				snprintf(szGenArm ,256 ,"%d",iArmID);
				gm_clearbag(pstRole, NULL);
				if(gm_item(pstRole, (const char*)&szGenArm) < 0)
				{
					return system_msg_to_role(pstRole, "Create Arm Err");
				}
				pstZoneArm = &pstRole->stRoleItem.stData.stCommItem.astItems[0];
				if(pstZoneArm->iResId != iArmID)
				{
					return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<WantNum> <RefineLevel>]");
				}
				
				stRefineC.stItemID.chType = CS_LISTTYPE_COMMITEM;
				stRefineC.stItemID.chItemIndex = pstZoneArm->chGridIndex;
				stRefineC.stItemID.chNum = pstZoneArm->chNumber;
				stRefineC.stItemID.chBagIndex = 0;
				//stRefineC.chUseCharmDirect = 1;
				int iCousumeSum = 0;
				int iSucSum = 0;
				int iFailSum = 0;
				int iCurRefine = 0;
				while(pstZoneArm->stItemAttr.stArmAttr.chRefineNum < iWantRefineLevel)
				{
					char chBefore = pstZoneArm->stItemAttr.stArmAttr.chRefineNum;
					char chRefineResult = -1;
					pstRefineLib = find_refine_base_lib_by_refine_num(pstZoneArm->stItemAttr.stArmAttr.chRefineNum + 1);
					if (NULL == pstRefineLib)
					{
						return system_msg_to_role(pstRole, "Error 1");
					}
					int iStuffNum = pstRefineLib->nConsumeNum;
					iCousumeSum += iStuffNum;

					stRefineC.nTotal = 0;

					if(pstRole->stRoleItem.iBagMoney < 10000000)
					{
						change_role_property(pstRole,10000000, 0, 0, 0, LOG_PROPERTY_GM_CMD);
					}
					//生成材料
					while(iStuffNum > 0)
					{
						snprintf(szGenStuff ,256 ,"%d  %d",REFINE_STUFF_ID,iStuffNum > REFINE_STUFF_PIPLENUM ? REFINE_STUFF_PIPLENUM : iStuffNum);
						iStuffNum -= REFINE_STUFF_PIPLENUM;
						
						if(gm_item(pstRole, (const char*)&szGenStuff) < 0)
						{
							return system_msg_to_role(pstRole, "Create Stuff Err");;
						}
						pstZoneStuff = &pstRole->stRoleItem.stData.stCommItem.astItems[pstRole->stRoleItem.stData.stCommItem.iCount - 1];
						stRefineC.astUsedItemID[stRefineC.nTotal].chType = CS_LISTTYPE_COMMITEM;
						stRefineC.astUsedItemID[stRefineC.nTotal].chItemIndex = pstZoneStuff->chGridIndex;
						stRefineC.astUsedItemID[stRefineC.nTotal].chNum = pstZoneStuff->chNumber;
						stRefineC.astUsedItemID[stRefineC.nTotal].chBagIndex = 0;
						++stRefineC.nTotal;
					}

					int iRet = refine_arm_base(pstRole, &stRefineC, &chBefore, &chRefineResult);
					if(iRet == 0)
					{
						++iSucSum;
					}
					else if(iRet == CS_CODE_ARM_REFINE_FAILED)
					{
						++iFailSum;
					}
					else
					{
						snprintf(szResInfo ,256 ,"Refine Base Error Ret %d",iRet);
						log_info_m(LOG_MODULE_TEST,LOG_ERR, szResInfo);
						return system_msg_to_role(pstRole, szResInfo);
					}

					++iCurRefine;
				
				}

				++iOut;
				log_info_m(LOG_MODULE_TEST,LOG_ERR, "Test %d CurRefine %d OutLevel %d  Suc %d Fail %d Consume %d",
					iOut,iCurRefine,pstZoneArm->stItemAttr.stArmAttr.chRefineNum,iSucSum,iFailSum,iCousumeSum);
			}
			
			break;
		}
		case 3:
		{
			int iTestLevel = 0;
			int iTestTimes = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No WantNum input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<RefineLevel> <WantNum> ]");
			}
			
			iTestLevel = atoi(szTemp);

			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] == 0)
			{
				system_msg_to_role(pstRole, "No WantRefineLevel input");
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<RefineLevel> <WantNum>]");
			}
			iTestTimes = atoi(szTemp);

			gm_clearbag(pstRole, (const char*)NULL);
			snprintf(szGenArm ,256 ,"%d",iArmID);
			if(gm_item(pstRole, (const char*)&szGenArm) < 0)
			{
				return system_msg_to_role(pstRole, "Create Arm Err");
			}
			pstZoneArm = &pstRole->stRoleItem.stData.stCommItem.astItems[0];
			if(pstZoneArm->iResId != iArmID)
			{
				return system_msg_to_role(pstRole, "refinetest <Mode> <ArmID> [<WantNum> <RefineLevel>]");
			}
			pstRefineLib = find_refine_base_lib_by_refine_num(pstZoneArm->stItemAttr.stArmAttr.chRefineNum + 1);
			int iStuffNum = pstRefineLib->nConsumeNum;
			int iSucc = 0;
			for (i=0; i< iTestTimes; i++)
			{
				pstZoneArm->stItemAttr.stArmAttr.chRefineNum = (char)iTestLevel;

				char chBefore = pstZoneArm->stItemAttr.stArmAttr.chRefineNum;
				char chRefineResult = -1;
				stRefineC.nTotal = 0;
				
				if(pstRole->stRoleItem.iBagMoney < 10000000)
				{
					change_role_property(pstRole,10000000, 0, 0, 0, LOG_PROPERTY_GM_CMD);
				}
				//生成材料
				while(iStuffNum > 0)
				{
					snprintf(szGenStuff ,256 ,"%d  %d",REFINE_STUFF_ID,iStuffNum > REFINE_STUFF_PIPLENUM ? REFINE_STUFF_PIPLENUM : iStuffNum);
					iStuffNum -= REFINE_STUFF_PIPLENUM;
					
					if(gm_item(pstRole, (const char*)&szGenStuff) < 0)
					{
						return system_msg_to_role(pstRole, "Create Stuff Err");;
					}
					pstZoneStuff = &pstRole->stRoleItem.stData.stCommItem.astItems[pstRole->stRoleItem.stData.stCommItem.iCount - 1];
					stRefineC.astUsedItemID[stRefineC.nTotal].chType = CS_LISTTYPE_COMMITEM;
					stRefineC.astUsedItemID[stRefineC.nTotal].chItemIndex = pstZoneStuff->chGridIndex;
					stRefineC.astUsedItemID[stRefineC.nTotal].chNum = pstZoneStuff->chNumber;
					stRefineC.astUsedItemID[stRefineC.nTotal].chBagIndex = 0;
					++stRefineC.nTotal;
				}
				
				int iRet = refine_arm_base(pstRole, &stRefineC, &chBefore, &chRefineResult);
				iSucc += (iRet == 0) ? 1 : 0;
			}
			snprintf(szGenStuff ,256 ,"refine: %d succ: %d", iTestTimes, iSucc);
			system_msg_to_role(pstRole, szGenStuff);
			break;
		}
		default:
			return -1;
	}
	
	log_info_m(LOG_MODULE_TEST,LOG_ERR, "====================Finished==================");

	return 0;
}

//宠物蛋相关
int gm_egg(LPROLE pstRole, const char *pszArg)
{
	char szTmp[128];
	char chArg;

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	chArg = 0;
	if (szTmp[0])
	{
		chArg = atoi(szTmp);
	}

	LPPETEGGINFO pstEggInfo = &pstRole->stPetEggInfo;
	if (chArg == 0)//read 
	{
		sprintf(szTmp, "egg state:%d, visittimes:%d, time passed:%d, eggID:%d", pstEggInfo->chEggstate, pstEggInfo->chVisitTimes, (int)(_cur_time() - pstEggInfo->lTime), pstEggInfo->iEggID);
		system_msg_to_role(pstRole, szTmp);
	}
	else if (0 < chArg && chArg < 4)//set
	{
		int iVar = 0;
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		
		iVar = 0;
		if (szTmp[0])
		{
			iVar = atoi(szTmp);
		}

		if (chArg == 1)
		{
			pstEggInfo->chVisitTimes = iVar;
		}
		else if (chArg == 2)
		{
			pstEggInfo->iEggID = iVar;
		}
		else if (chArg == 3)
		{
			pstEggInfo->lTime += iVar;
		}
	}
	else//clear
	{
		clr_commstat(pstRole, RES_COMMSTAT_PET_EGG);
		role_remove_specstat(pstRole, get_pet_egg_stat_id());
		pstEggInfo->chVisitTimes = 0;
		pstEggInfo->lTime = 0;
		pstEggInfo->iEggID = 0;
	}

	return 0;
}

/**
 *@desc 单次在线游戏时间设定(防沉迷用)
 **/
 int gm_set_play_time(LPROLE pstRole, const char*pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	
	char szTmp[128] = {0};
	char chHour = 0;
	unsigned int ulUin = 0;
	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (0 == szTmp[0])
	{
		system_msg_to_role(pstRole, "Usage:notifyplaytime uin hour");
		return -1;
	}
	else
	{
		ulUin = atoll(szTmp);
	}

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	if (0 == szTmp[0])
	{
		system_msg_to_role(pstRole, "Usage:notifyplaytime uin hour");
		return -1;
	}
	else
	{
		chHour = atoi(szTmp);
	}

	CSMISCS  stMiscS;
	stMiscS.nEno = CS_ENO_NOERR;
	stMiscS.chReq = CS_MISC_REQ_ANTIADDICT;
	stMiscS.stData.stAntiAddict.iOnlineHours = chHour;

	reply_server_pkg(ulUin, CS_CMD_MISC, &stMiscS);

	return 0;
}


int gm_auth(LPROLE pstRole, const char *pszArg)
{

	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,
		pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szGMMsgTemp);




	
#define TMP_AUTH_CMD_ASK 1
#define TMP_AUTH_CMD_ANSWER 2
#define TMP_AUTH_CMD_DISABLE 3
#define TMP_AUTH_CMD_REFRESH 4

	char szTemp[80];
	short nCmd = 0;
	int iAnswer = -1;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "auth ask");
			system_msg_to_role(pstRole, "auth answer");
			system_msg_to_role(pstRole, "auth disable");
			system_msg_to_role(pstRole, "auth refresh");
			return 0;
		}
		if(!strncasecmp(szTemp, "ask", sizeof("ask")))
		{
			nCmd = TMP_AUTH_CMD_ASK;
		}else if(!strncasecmp(szTemp, "answer", sizeof("answer")))
		{
			nCmd = TMP_AUTH_CMD_ANSWER;
		}else if(!strncasecmp(szTemp, "disable", sizeof("disable")))
		{
			nCmd = TMP_AUTH_CMD_DISABLE;
		}
		else if(!strncasecmp(szTemp, "refresh", sizeof("refresh")))
		{
			nCmd = TMP_AUTH_CMD_REFRESH;
		}
		
	}else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iAnswer = atoi(szTemp);
	}
	
	switch(nCmd)
	{
		case TMP_AUTH_CMD_ASK:
		{
			pstRole->stAuthInfo.bMaxVerifyChance = MAX_AUTH_TIMES;
			pstRole->stAuthInfo.bLeftVerifyChance = MAX_AUTH_TIMES;
			pstRole->stAuthInfo.nCountDown = MAX_AUTH_PERIOD;
			pstRole->stAuthInfo.bLeftRefreshChance = CS_MAX_AUTH_REFRESH_CHANCE;
			deal_role_auth(pstDestRole,(iAnswer != 2) ? CS_AUTH_SOURCE_GAMESVR : CS_AUTH_SOURCE_CENTER);
			break;	
		}
		case TMP_AUTH_CMD_ANSWER:
		{
			CSAUTHC stAuthC;
			stAuthC.bCmd = CS_AUTH_OP_PROCESS;
			stAuthC.bAuthSrc = pstDestRole->stAuthInfo.bAuthState;
			stAuthC.stData.stAuthProcess.iIdentify = pstDestRole->stAuthInfo.iIdentify;
			stAuthC.stData.stAuthProcess.iSignature = pstDestRole->stAuthInfo.iSignature;
			if(stAuthC.bAuthSrc == CS_AUTH_SOURCE_GAMESVR)
			{
				stAuthC.stData.stAuthProcess.stAnswer.nType = CS_AUTH_INT;
				stAuthC.stData.stAuthProcess.stAnswer.stData.iInt = (iAnswer == -1) ? pstDestRole->stAuthInfo.iStandAnswer : iAnswer;
			}
			else
			{
				stAuthC.stData.stAuthProcess.stAnswer.nType = CS_AUTH_STR;
				STRNCPY(stAuthC.stData.stAuthProcess.stAnswer.stData.szStr,pstDestRole->stAuthInfo.szStandAnswerStr,CS_MAX_AUTH_STR);
			}
			
			process_auth_cmd(pstDestRole, &stAuthC);
			break;
		}
		case TMP_AUTH_CMD_REFRESH:
		{
			CSAUTHC stAuthC;
			stAuthC.bCmd = CS_AUTH_OP_REFRESH_PIC;
			stAuthC.bAuthSrc = pstDestRole->stAuthInfo.bAuthState;
			process_auth_cmd(pstDestRole, &stAuthC);
			break;
		}		
		case TMP_AUTH_CMD_DISABLE:
		{
			pstDestRole->stAuthInfo.tLastAuthTime = time(NULL) + 6 * 60 * 60;;
			pstDestRole->stAuthInfo.bAuthState = 0;
			break;	
		}
		default:
			return -1;
	}
	return 0;
}


int gm_security(LPROLE pstRole, const char *pszArg)
{

#define TMP_SECU_CMD_CLEAR_LOCK 2
#define TMP_SECU_CMD_DISP_PWD 3
#define TMP_SECU_CMD_SET_QUERYED 4
#define TMP_SECU_CMD_RESET_KEYMAP 7
#define TMP_SECU_CMD_LOGIN_PROTECT 8
#define TMP_SECU_CMD_RESET_PWD 9
#define TMP_SECU_CMD_SECU_LEVEL 10
#define TMP_SECU_CMD_SECU_USE 11
#define TMP_SECU_CMD_SECU_FREQ 12
#define TMP_SECU_CMD_SECU_SHOW 13
#define TMP_SECU_CMD_LOCK_USER 14
#define TMP_SECU_CMD_TRANS_PWD 16
#define TMP_SECU_CMD_PROTECTMODE 17
#define TMP_SECU_CMD_FORCEUNLOCK 18

	char szTemp[80];
	short nCmd = 0;
	int iParam1 = 1;
	char szTempInfo[1024];
	szTempInfo[0]='\0';
	
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if(pstDestRole == NULL)
	{
		pstDestRole = pstRole;
	}
	snprintf(szTemp,sizeof(szTemp),"GM [%s] Operate to Role[%u %s %u]",pstRole->szName,pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
	system_msg_to_role(pstRole, szTemp);

	LPPLAYER pstDestPlayer = role_to_player(pstRole);
	if(NULL == pstDestPlayer)
	{
		snprintf(szTemp,sizeof(szTemp),"No player find for role[%u %s %u]",pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szTemp);
		return -1;
	}
	

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "secu clearlock");
			system_msg_to_role(pstRole, "secu disppwd");
			system_msg_to_role(pstRole, "secu resetpwd");
			system_msg_to_role(pstRole, "secu forceunlock <Sec>");
			system_msg_to_role(pstRole, "secu show");			
			system_msg_to_role(pstRole, "secu queryed");
			system_msg_to_role(pstRole, "secu resetkeymap");
			system_msg_to_role(pstRole, "secu loginprotect");			
			system_msg_to_role(pstRole, "secu level");
			system_msg_to_role(pstRole, "secu use");
			system_msg_to_role(pstRole, "secu frenq");			
			system_msg_to_role(pstRole, "secu lockuser");
			system_msg_to_role(pstRole, "secu startmb");
			return 0;
		}
		if(!strncasecmp(szTemp, "clearlock", sizeof("clearlock")))
		{
			nCmd = TMP_SECU_CMD_CLEAR_LOCK;
		}
		else if(!strncasecmp(szTemp, "disppwd", sizeof("disppwd")))
		{
			nCmd = TMP_SECU_CMD_DISP_PWD;
		}		
		else if(!strncasecmp(szTemp, "queryed", sizeof("queryed")))
		{
			nCmd = TMP_SECU_CMD_SET_QUERYED;
		}
		else if(!strncasecmp(szTemp, "resetkeymap", sizeof("resetkeymap")))
		{
			nCmd = TMP_SECU_CMD_RESET_KEYMAP;
		}
		else if(!strncasecmp(szTemp, "loginprotect", sizeof("loginprotect")))
		{
			nCmd = TMP_SECU_CMD_LOGIN_PROTECT;
		}
		else if(!strncasecmp(szTemp, "resetpwd", sizeof("resetpwd")))
		{
			nCmd = TMP_SECU_CMD_RESET_PWD;
		}
		else if(!strncasecmp(szTemp, "level", sizeof("level")))
		{
			nCmd = TMP_SECU_CMD_SECU_LEVEL;
		}
		else if(!strncasecmp(szTemp, "use", sizeof("use")))
		{
			nCmd = TMP_SECU_CMD_SECU_USE;
		}
		else if(!strncasecmp(szTemp, "freq", sizeof("freq")))
		{
			nCmd = TMP_SECU_CMD_SECU_FREQ;
		}
		else if(!strncasecmp(szTemp, "show", sizeof("show")))
		{
			nCmd = TMP_SECU_CMD_SECU_SHOW;
		}
		else if(!strncasecmp(szTemp, "lockuser", sizeof("lockuser")))
		{
			nCmd = TMP_SECU_CMD_LOCK_USER;
		}
		else if(!strncasecmp(szTemp, "transpwd", sizeof("transpwd")))
		{
			nCmd = TMP_SECU_CMD_TRANS_PWD;
		}
		else if(!strncasecmp(szTemp, "protectstate", sizeof("protectstate")))
		{
			nCmd = TMP_SECU_CMD_PROTECTMODE;
		}
		else if(!strncasecmp(szTemp, "forceunlock", sizeof("forceunlock")))
		{
			nCmd = TMP_SECU_CMD_FORCEUNLOCK;
		}		
		
	}else
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0])
	{
		iParam1 = atoi(szTemp);
	}

	
	
	switch(nCmd)
	{
		case TMP_SECU_CMD_CLEAR_LOCK:
		{
			if(get_role_security_used(&pstDestRole->stSecuInfo)== ROLE_SECU_USE_LOCK)
			{
				reset_role_secuinfo(&pstDestRole->stSecuInfo,pstDestRole->ulUin,__FUNCTION__);
				update_role_security_info(pstDestRole);
			}
			break;
		}
		case TMP_SECU_CMD_DISP_PWD:
		{
			snprintf(szTempInfo,1024 ,"Role[%u %s] IsUseLock[%d]\n",pstDestRole->ulUin,pstDestRole->szName,
				get_role_security_used(&pstDestRole->stSecuInfo)== ROLE_SECU_USE_LOCK ? 1 : 0);
			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo) ,"Pwd[%s] PwdLen[%d]",pstDestRole->stSecuInfo.stLockPwd.szLockKey,
				pstDestRole->stSecuInfo.stLockPwd.wLockKeyLen);
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		case TMP_SECU_CMD_SET_QUERYED:
		{
			pstDestPlayer->stSecuInfo.bIsQueryMB = iParam1;	
			pstDestPlayer->stSecuInfo.bHasSeniorMB = 0;	
			pstDestPlayer->stSecuInfo.bIsUseMB = 0;	
			break;
		}
		case TMP_SECU_CMD_RESET_KEYMAP:
		{
			reset_key_map();
			break;
		}
		case TMP_SECU_CMD_LOGIN_PROTECT:
		{
			pstDestRole->stSecuInfo.stSecuSetInfo.wLoginProtectTime = iParam1;
			break;
		}
		case TMP_SECU_CMD_RESET_PWD:
		{
			if(get_role_security_used(&pstDestRole->stSecuInfo) != ROLE_SECU_USE_LOCK)
			{
				snprintf(szTempInfo,1024 ,"Role[%u %s] is Not Lock User",pstDestRole->ulUin,pstDestRole->szName);
				return system_msg_to_role(pstRole, szTempInfo);
			}

			if(reset_role_lock_pwd(pstDestPlayer, &pstDestRole->stSecuInfo) < 0)
			{
				snprintf(szTempInfo,1024 ,"Reset Role[%u %s] Lock Pwd Error",pstDestRole->ulUin,pstDestRole->szName);
			}
			else
			{
				snprintf(szTempInfo,1024 ,"Role[%u %s] is reseted to[%s]",pstDestRole->ulUin,pstDestRole->szName,LOCK_INIT_PWD);
			}
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		case TMP_SECU_CMD_SECU_LEVEL:
		{
			pstDestRole->stSecuInfo.stSecuSetInfo.bSecuLevel = iParam1;
			break;
		}
		case TMP_SECU_CMD_SECU_USE:
		{
			pstDestRole->stSecuInfo.stSecuSetInfo.bSecuUsed = iParam1;
			break;
		}
		case TMP_SECU_CMD_SECU_FREQ:
		{
			pstDestRole->stSecuInfo.stSecuSetInfo.bSecuFrequency = iParam1;
			break;
		}
		case TMP_SECU_CMD_FORCEUNLOCK:
		{
			pstDestRole->stSecuInfo.stSecuSetInfo.ulForceUnlockDeadline = time(NULL) + iParam1;
			update_role_security_info(pstDestRole);
			snprintf(szTempInfo,1024,"Role[%u %s] ForceUnlock Deadline Set to [%s]\n",
				pstDestRole->ulUin,pstDestRole->szName,compactdatetime(pstDestRole->stSecuInfo.stSecuSetInfo.ulForceUnlockDeadline));
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}		
		case TMP_SECU_CMD_LOCK_USER:
		{
			pstDestPlayer->stSecuInfo.bIsQueryMB = 1;
			pstDestPlayer->stSecuInfo.bHasSeniorMB = 0;
			pstDestPlayer->stSecuInfo.bIsUseMB = 0;
			reset_role_secuinfo(&pstDestRole->stSecuInfo,pstDestRole->ulUin,__FUNCTION__);
			pstDestRole->stSecuInfo.stSecuSetInfo.bSecuUsed = ROLE_SECU_USE_LOCK;
			if(reset_role_lock_pwd(pstDestPlayer, &pstDestRole->stSecuInfo) < 0)
			{
				snprintf(szTempInfo,1024 ,"Reset Role[%u %s] Lock Pwd Error",pstDestRole->ulUin,pstDestRole->szName);
			}
			else
			{
				snprintf(szTempInfo,1024 ,"Role[%u %s] is reseted to lock use, init pwd is [%s]",pstDestRole->ulUin,pstDestRole->szName,LOCK_INIT_PWD);
			}
			update_role_security_info(pstDestRole);
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		case TMP_SECU_CMD_SECU_SHOW:
		{
			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo),"========Uin[%u]=======\n,",pstDestPlayer->ulUin);
			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo),"Player: Queryed[%d] Verify[%d] UseMB[%d] HasSeniorMB[%d] InProtectMode[%d]\n",
				(int)pstDestPlayer->stSecuInfo.bIsQueryMB,(int)is_player_verified(pstDestPlayer),(int)pstDestPlayer->stSecuInfo.bIsUseMB
				,(int)pstDestPlayer->stSecuInfo.bHasSeniorMB,(int)pstDestPlayer->stSecuInfo.bIsInProtectMode);
			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo),"LastOpt[%d] RoleIndex[%d] SSCMD[%d]\n",
				(int)pstDestPlayer->stSecuInfo.iLastVitalOpt,(int)pstDestPlayer->stSecuInfo.chVerifyDelRoleIndex,(int)pstDestPlayer->stSecuInfo.iSSOpCmd);

			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo),"Role:Used[%d] Level[%d] Frequence[%d] StartMB[%d]\n",
				(int)get_role_security_used(&pstDestRole->stSecuInfo),(int)pstDestRole->stSecuInfo.stSecuSetInfo.bSecuLevel,
				(int)pstDestRole->stSecuInfo.stSecuSetInfo.bSecuFrequency,(int)pstDestRole->stSecuInfo.stSecuSetInfo.bIsStartMB);
			snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo),"Protect[%d] UnlockTime[%d] IsVerify[%d]\n",
				(int)pstDestRole->stSecuInfo.stSecuSetInfo.wLoginProtectTime,(int)pstDestRole->stSecuInfo.stSecuSetInfo.ulForceUnlockDeadline,
				(int)is_role_verified(pstDestPlayer, pstDestRole->ullGID));
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		case TMP_SECU_CMD_PROTECTMODE:
		{
			change_protect_state_level(pstDestRole->ulUin,iParam1);
			snprintf(szTempInfo ,1024 ,"Uin[%u %s] ProtectState ChangeTo[%d]\n,",pstDestRole->ulUin,pstDestRole->szName,pstDestPlayer->stSecuInfo.bIsInProtectMode);
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		case TMP_SECU_CMD_TRANS_PWD:
		{
			char    Md5[MD5_DIGEST_LENGTH];
			int a = 0;
			memset(Md5,0,sizeof(Md5));
			Md5Buffer(Md5, szTemp, strlen(szTemp));
			char szKey[SECU_LOCK_KEY_LEN] ;
			int b = 0;

			b = a;
		    int iKeyLen = SECU_LOCK_KEY_LEN ;

		    memset(szKey , 0 , sizeof(szKey)) ;
		    if(convert_bin2str(Md5, MD5_DIGEST_LENGTH, szKey , (size_t *)&iKeyLen)< 0)
			{
				system_msg_to_role(pstRole, "convert_bin2str Error");
				return -1;
			}
			snprintf(szTempInfo,1024 ,"Input Pwd[%s] Len[%d].",szTemp, (int)strlen(szTemp));
			system_msg_to_role(pstRole, szTempInfo);
			snprintf(szTempInfo,1024 ,"Md5 Pwd[%s] Len[%d].",Md5, (int)strlen(Md5));
			system_msg_to_role(pstRole, szTempInfo);
			snprintf(szTempInfo,1024 ,"Md52Key Key[%s] Len[%d] Strlen[%d].",szKey,iKeyLen, (int)strlen(szKey));
			system_msg_to_role(pstRole, szTempInfo);
			int m = 0;
			szTempInfo[0] = 0;
			for(m = 0; m < iKeyLen; ++m)
			{
				snprintf(szTempInfo + strlen(szTempInfo),1024 - strlen(szTempInfo) ," %d ",szKey[m]);
			}
			system_msg_to_role(pstRole, szTempInfo);
			break;
		}
		
		
		default:
			return -1;
	}
	return 0;
}


int gm_updateclientinfo(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iUpdateTime = 0;
	int iDelayTime = 0;
	int i = 0;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iUpdateTime = atoi(szTemp);
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iDelayTime = atoi(szTemp);
	}	
	
	LPSYSENV pstSysEnv = get_sys_env();
	if(pstSysEnv == NULL)
	{
		return -1;
	}
	if (iUpdateTime > 0)
	{
		 pstSysEnv->stConfig.iUCI_UpdateTime = iUpdateTime;
	}
	if (iDelayTime > 0)
	{
		pstSysEnv->stConfig.iUCI_DelayTime = iDelayTime;
	}

	LPROLEPOOL pstRolePool = get_role_pool();
	if (NULL == pstRolePool)
	{
		return -1;
	}
	for (i=0; i<MAX_ROLE; ++i)
	{
		LPROLE pstTRole = (LPROLE)pstRolePool->sRole[i];
		if (pstTRole->stObject.ulID != 0)
		{	
			update_clientinfo_set(pstTRole->ulUin, pstSysEnv->stConfig.iUCI_UpdateTime, pstSysEnv->stConfig.iUCI_DelayTime);
		}
	}
	return 0;

}

/*
 *@Desc 更新商城热销排行榜信息
 */
 int gm_update_mall_hot_list(LPROLE pstRole, const char *pszArg)
{
	LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_HOT_LIST);
	update_hot_list(pstCommData);
	return 0;
}

//清空商城商品本日已卖数量信息
int gm_reset_commo_sell_limit(LPROLE pstRole, const char *pszArg)
{
	reset_commo_sell_day_limit();
	return 0;
}

/*
 *@Desc 直接改变当前激活宠物的寿命值
 */
 int gm_change_pet_life_span(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	//int iRet = 0;
	int iChangeValue = 0;

	if (NULL == pstRole)
	{
		return -1;
	}

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if(szTemp[0])
	{
		if(!strncasecmp(szTemp, "help", sizeof("help")))
		{
			system_msg_to_role(pstRole, "changepetlifespan changevalue");
			return 0;
		}
		iChangeValue = atoi(szTemp);
	}else
	{
		return -1;
	}


	LPPET pstPet = get_pet_by_role(pstRole);
	if (NULL == pstPet)
	{
		system_msg_to_role(pstRole,"no active pet ! fail to change pet life.");
		return -1;
	}
	else
	{
		LPZONEPETITEM pstZonePetItem = get_pet_item_by_pet(pstPet);
		if (NULL == pstZonePetItem)
		{
			return -1;
		}
		else
		{

			system_msg_to_role(pstRole,"cur active pet life:%d  pet max life:%d",
				pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan ,
				pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpanMax);

			if (iChangeValue < 0)
			{
				if (pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan <= 0)
				{
					return -1;
				}
				else if ((pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan + iChangeValue) < 0)
				{
					return -1;
				}
				else
				{
					pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan += iChangeValue;
				}
			}
			else if (iChangeValue > 0)
			{
				if (pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan == pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpanMax)
				{
					return -1;
				}
				else if ((pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan + iChangeValue) > pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpanMax)
				{
					pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan = pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpanMax;
				}
				else
				{
					pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan += iChangeValue;
				}
			}
			else
			{
				return -1;
			}
			CSMISCS stMiscS;
			memset(&stMiscS, 0, sizeof(stMiscS));
			stMiscS.chReq = CS_MISC_RES_PET_LIFE_SPAN_UPDATE;
			stMiscS.nEno = CS_ENO_NOERR;
			stMiscS.stData.stPetLifeSpanUpdate.iCurrLifeSpan = pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan;
			stMiscS.stData.stPetLifeSpanUpdate.chPetPos = pstRole->stPetForRole.chCurrentActivePet;

			int iRet = reply_server_pkg(pstRole->ulUin, CS_CMD_MISC, (void *)&stMiscS);
			if (0 != iRet)
			{
				log_info_m(LOG_MODULE_PET, LOG_ERR, "%s: failed to send pkg to client.", __FUNCTION__);
				return iRet;
			}
			system_msg_to_role(pstRole,"change sucess :cur active pet life:%d  pet max life:%d",
				pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpan ,
				pstZonePetItem->stPetItem.stItemAttr.stPetBaseAttr.stPetAttrMisc.iLifeSpanMax);


		}
	}

	return 0;
}

/*
 *@Desc 直接改变当前激活宠物的寿命上限值
 */
int gm_change_pet_life_span_max(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole)
	{
		return -1;
	}

	int iRet = 0;
	
	return iRet;
}

int gm_set_config(LPROLE pstRole, const char *pszArg)
{
	
	char szTemp[80];
	LPSYSENV pstSysEnv = get_sys_env();
	if(pstSysEnv == NULL)
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!szTemp[0])
	{
		system_msg_to_role(pstRole,"current sys max online:%d :(hardcode:%d)  shuntfence[%d] GMSpecNotice[%d].",
					pstSysEnv->stConfig.iMaxOnline,MAX_ROLE,pstSysEnv->stConfig.iShuntFence,(int)pstSysEnv->stConfig.bGMSpecNotice);
				
		return -1;
	}
	if (!strcmp(szTemp, "maxonline"))
	{
		int iMaxOnline = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			iMaxOnline = atoi(szTemp);
		}
		if (0 >= iMaxOnline)
		{
			system_msg_to_role(pstRole, "max online:%d", pstSysEnv->stConfig.iMaxOnline);
		}
		else
		{
			pstSysEnv->stConfig.iMaxOnline = iMaxOnline;
		}	
	}
	else if(!strcmp(szTemp, "shuntfence"))
	{
		int iMaxLogin = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			iMaxLogin = atoi(szTemp);
		}
		if (0 >= iMaxLogin)
		{
			system_msg_to_role(pstRole, "shuntfence:%d", pstSysEnv->stConfig.iShuntFence);
		}
		else
		{
			pstSysEnv->stConfig.iShuntFence = iMaxLogin;
		}	

	}
	else if(!strcmp(szTemp, "gmnotice"))
	{
		int iNotice  = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			iNotice = atoi(szTemp);
		}

		if(iNotice)
		{
			pstSysEnv->stConfig.bGMSpecNotice = 1;
		}
		else
		{
			pstSysEnv->stConfig.bGMSpecNotice = 0;
		}	
	}
	else if(!strcmp(szTemp, "threeqizi"))
	{
		int iMaxQizi  = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			iMaxQizi = atoi(szTemp);
		}

		if(iMaxQizi > 0 && iMaxQizi < 256)
		{
			pstSysEnv->stConfig.bMaxThreeQiziLimit = (unsigned char)iMaxQizi;
		}
		system_msg_to_role(pstRole,"Three qizi Limit Change To [%d].",pstSysEnv->stConfig.bMaxThreeQiziLimit);
	}	
	else
	{
		system_msg_to_role(pstRole,"Usage://set_config <maxonline> or <shuntfence> <num> to set."
					"current sys max online:%d :(hardcode:%d)  shuntfence[%d])",
					pstSysEnv->stConfig.iMaxOnline,MAX_ROLE,pstSysEnv->stConfig.iShuntFence);

		return -1;
	}
	
	system_msg_to_role(pstRole,"current sys max online:%d :(hardcode:%d)  shuntfence[%d] GMSpecNotice[%d]",
					pstSysEnv->stConfig.iMaxOnline,MAX_ROLE,pstSysEnv->stConfig.iShuntFence,(int)pstSysEnv->stConfig.bGMSpecNotice);

	return 0;

}

//测试MISC 数据库通用存储
int gm_testcommdata(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!szTemp[0])
	{
		return -1;
	}
	if (!strcmp(szTemp, "save"))
	{
		int iValue = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			iValue = atoi(szTemp);
		}
		LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_TEST);
		if (!pstCommData)
		{
			return -1;
		}
		pstCommData->stTest.iValue = iValue;
		pstCommData->stTest.ulUin = pstRole->ulUin;
	}
	else if (!strcmp(szTemp, "get"))
	{
		commdata_op_get(ENM_COMMDATA_KEY_TEST);
	}
	
	return 0;	
}

//测试MISC 离线消息系统
int gm_testoffline(LPROLE pstRole, const char *pszArg)
{
	char szTemp[80];
	int iNum = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iNum = atoi(szTemp);
	}

	ROLEOFFLINEMSGDATA stOfflineMsg;
	stOfflineMsg.stTest.ulUin = pstRole->ulUin;
	int i = 0;
	for (i=0; i<iNum; ++i)
	{
		stOfflineMsg.stTest.iValue = i;
		roleofflinemsg_op_send(pstRole->ullGID, ENM_ROLE_OFFLINE_MSG_CMDID_TEST,  &stOfflineMsg);
	}
	
	return 0;	
}

//测试抽奖
int gm_testraffle(LPROLE pstRole, const char *pszArg)
{
	CSRAFFLEC stRaffleC;
	memset(&stRaffleC, 0, sizeof(stRaffleC));

	/*
	stRaffleC.bRaffleID = 1;
	
	char szTemp[80];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		stRaffleC.chType = atoi(szTemp);
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		stRaffleC.bPseudoNum = atoi(szTemp);
	}
	*/
	
	process_raffle_op_cmd(pstRole, &stRaffleC);
	
	return 0;	
}

/*
 *@Desc 改变天缘值
 */
 int gm_changetianyuanvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};

	int iAddLuckyValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddLuckyValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	iRet = chg_relation_value(pstRole, MAIN_RELATION_TYPE_TIANYUAN, iAddLuckyValue, 1);
	
	return iRet;
}

/*
 *@Desc 改变地缘值
 */
 int gm_changediyuanvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};

	int iAddLuckyValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddLuckyValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	iRet = change_diyuan_value(pstRole, iAddLuckyValue, DIYUAN_CHANGE_SCENE_TYPE_GM, 1);
	
	return iRet;
}

/*
 *@Desc 改变魅力度
 */
 int gm_changecharmingvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};

	int iAddLuckyValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddLuckyValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	iRet = chg_relation_value(pstRole, MAIN_RELATION_TYPE_BOSOM, iAddLuckyValue, 1);
	
	return iRet;
}

/*
 *@Desc 改变知名度
 */
 int gm_changefamousvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};

	int iAddLuckyValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddLuckyValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	iRet = change_famous_value(pstRole, iAddLuckyValue, 1);
	
	return iRet;

}

/*
 *@Desc 增加关系人
 */
 int gm_addrelationer(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};
	unsigned int ulTargetUin = 0;
	char chMainRelation = 0;
	char chSecondRelation =0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		ulTargetUin = atoll(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		chMainRelation = atoi(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		chSecondRelation = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	LPROLE pstTargetRole = uin_to_role(ulTargetUin);
	if (NULL == pstTargetRole)
	{
		return -1;
	}

	if (chMainRelation < MAIN_RELATION_TYPE_MIN_VALUE  || chMainRelation > MAIN_RELATION_TYPE_MAX_VALUE)
	{
		return -1;
	}
	
	iRet = check_second_relation_effective(chMainRelation, chSecondRelation);
	if (0 != iRet)
	{
		return -1;
	}
	
	iRet = add_relationer(pstRole, pstTargetRole, NULL, chMainRelation, chSecondRelation, 1, 1);
	if (0 != iRet)
	{
		return -1;
	}

	switch (chMainRelation)
	{
		case MAIN_RELATION_TYPE_TIANYUAN://天缘
		{
			iRet = chg_relation_value(pstRole, MAIN_RELATION_TYPE_TIANYUAN, SKY_LOVE_VALUE_ADD_ONE_PERSON, 1);
			iRet = chg_relation_value(pstTargetRole, MAIN_RELATION_TYPE_TIANYUAN, SKY_LOVE_VALUE_ADD_ONE_PERSON, 1);
			break;
		}
		case MAIN_RELATION_TYPE_BOSOM://红颜知己
		{
			iRet = chg_relation_value(pstRole, MAIN_RELATION_TYPE_BOSOM, get_charm_add_value_by_relation(chSecondRelation), 1);
			//iRet = change_diyuan_value(pstRole, get_diyuan_add_value_by_relation(chSecondRelation), DIYUAN_CHANGE_SCENE_TYPE_GM, 1);
			iRet = chg_relation_value(pstTargetRole, MAIN_RELATION_TYPE_BOSOM, get_charm_add_value_by_relation(chSecondRelation), 1);
			//iRet = change_diyuan_value(pstTargetRole, get_diyuan_add_value_by_relation(chSecondRelation), DIYUAN_CHANGE_SCENE_TYPE_GM, 1);
			break;
		}
		case MAIN_RELATION_TYPE_MENTOR://师徒关系
		{
			
			break;
		}
		default:
		{
			return -1;
		}
	}

	return iRet;
}

/*
 *@Desc 增加好友间的缘分度
 */
 int gm_addluckyvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};
	unsigned int ulSourceUin = 0;
	unsigned int ulTargetUin = 0;
	int iAddLuckyValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		ulSourceUin = atoll(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		ulTargetUin = atoll(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddLuckyValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	LPROLE pstTargetRole = uin_to_role(ulTargetUin);
	LPROLE pstSourceRole = uin_to_role(ulSourceUin);
	if (NULL == pstTargetRole || NULL == pstSourceRole)
	{
		return -1;
	}
	else
	{
		CHATMSG stChatMsg;
		memset(&stChatMsg, 0, sizeof(stChatMsg));
		REQUESTPKG stReq;
		memset(&stReq, 0, sizeof(stReq));

		unsigned char ucWorldID = get_sys_worldid();
		int iServiceID = 0;
		FO2_GENERATE_ENTITYID(iServiceID, ucWorldID, get_sys_zoneid(), FUNC_ZONE_SVR, 1);
		
		stChatMsg.bDstZoneID = get_sys_zoneid();
		stChatMsg.bType = CHAT_BODY_FRIEND_CHANGE_FRIEND_LUCKY;
		stChatMsg.wWhich = WHICH_CHANGE_FRIEND_LUCKY_VALUE;
		stChatMsg.stWho.ullGid = pstSourceRole->ullGID;
		stChatMsg.stBody.stFriendLuckyValueChange.chOptype = ADD_OR_DECREASE_LUCKY_VALUE;
		stChatMsg.stBody.stFriendLuckyValueChange.ullDataIndex = -1;
		stChatMsg.stBody.stFriendLuckyValueChange.ullTargetGID = pstTargetRole->ullGID;
		stChatMsg.stBody.stFriendLuckyValueChange.ullZoneEntityID = iServiceID;
		stChatMsg.stBody.stFriendLuckyValueChange.iLuckyChange = iAddLuckyValue;

		stReq.stBody.stChatTo = stChatMsg;
		
		iRet = send_world_request(get_chat_svr_id(), pstSourceRole->ulUin, SS_CHATBUDDY_REQ, &stReq, 0);
		if (0 != iRet)
		{
			return -1;
		}
	}

	return iRet;
}

/*
 *@Desc 清空竞价商城最近售卖列表
 */
int gm_clear_recent_bid_sold_list(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	return clear_recent_sold_bid_list();
}

/*
 *@Desc 设置是否允许非GM角色登录(在限制登录IP的情形下)
 */
int gm_confine_non_gm_login(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[128] = {0};
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!strcasecmp(szTemp, "get"))
	{
		system_msg_to_role(pstRole, "%d", gs_iIfPermitNonGMLogin);
	}
	else if(!strcasecmp(szTemp, "set"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (szTemp[0])
		{
			gs_iIfPermitNonGMLogin = atoi(szTemp);
		}
		else
		{
			system_msg_to_role(pstRole, "confine_non_gm_login type(get/set) [flag(0:限制 其它:不限制)]");
			return -1;
		}
	}
	else
	{
		system_msg_to_role(pstRole, "confine_non_gm_login type(get/set) [flag(0:限制 其它:不限制)]");
		return -1;
	}

	return 0;
}

/*
 *@Desc 改变师缘度
 */
 int gm_changementorvalue(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};
	unsigned int ulTargetUin = 0;
	int iAddMentorValue = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		ulTargetUin = atoll(szTemp);
	}
	else
	{
		return -1;
	}
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddMentorValue = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	LPROLE pstTargetRole = uin_to_role(ulTargetUin);
	if (NULL == pstTargetRole)
	{
		return -1;
	}

	iRet = chg_special_relation_value(pstRole, pstTargetRole->ullGID, MAIN_RELATION_TYPE_MENTOR, -1, iAddMentorValue, 1, 1);

	return iRet;
}

/*
 *@Desc 催熟天缘仙果
 */
 int gm_ripenfruit(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	int iRet = 0;

	char szTemp[128] = {0};

	int iAddTime = 0;
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (szTemp[0])
	{
		iAddTime = atoi(szTemp);
	}
	else
	{
		return -1;
	}

	LPTIANYUANFRUITLIST pstTianYuanFruitList = get_tianyuan_fruit_list();
	if (NULL == pstTianYuanFruitList)
	{
		return -1;
	}

	//if (pstTianYuanFruitList->chFlag == 0)
	//{
	//	return -1;
	//}
	int i = 0;
	for (i = 0; i < pstTianYuanFruitList->nTotal; i++)
	{
          	pstTianYuanFruitList->astFruit[i].lFruitTime -= iAddTime * 60;
	}

	iRet = get_tianyuan_fruit_list_req(pstRole);
	if (0 != iRet)
	{
		return -1;
	}
	
	return iRet;
}

int gm_richflag(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	
	if (!strcasecmp(szTemp, "Save"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		char chValue = atoi(szTemp);
		INTERFACEDATAREQ stData;
		stData.stRichFlagSave.ulUin = ulUin;
		stData.stRichFlagSave.chValue = chValue;
		send_interface_req(pstRole->ulUin, ENM_INTERFACE_TYPE_RICHFLAG_SAVE, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);

		//防止
	}
	else if (!strcasecmp(szTemp, "Get"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		INTERFACEDATAREQ stData;
		stData.stRichFlagGet.ulUin = ulUin;
		send_interface_req(pstRole->ulUin, ENM_INTERFACE_TYPE_RICHFLAG_GET, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);
	}
	else if (!strcasecmp(szTemp, "GetMember"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		INTERFACEDATAREQ stData;
		stData.stMssFlagGet.ulUin = ulUin;
		send_interface_req(pstRole->ulUin, ENM_INTERFACE_TYPE_MSSFLAG_GET, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);
	}
	else if (!strcasecmp(szTemp, "AddWebAward"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int dwFunc = strtoul(szTemp, NULL, 10);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		char chTimes = atoi(szTemp);
		INTERFACEDATAREQ stData;
		stData.stWebCommData.ulUin = ulUin;
		stData.stWebCommData.dwAwardFunc = dwFunc;
		stData.stWebCommData.chAwardTimes = chTimes;
		send_interface_req(pstRole->ulUin, ENM_INTERFACE_TYPE_WEB_DATA_SAVE, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);
	}
	else if (!strcasecmp(szTemp, "AddQQBarScore"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		int iAmount = atoi(szTemp);
		INTERFACEDATAREQ stData;
		stData.stQQBarScore.ulUin = ulUin;
		stData.stQQBarScore.dwAddedScore = iAmount;
		send_interface_req(ulUin, ENM_INTERFACE_TYPE_QQ_BAR_SCORE, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);
	}
	else if (!strcasecmp(szTemp, "GetSuperQQ"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned int ulUin = strtoul(szTemp, NULL, 10);
		INTERFACEDATAREQ stData;
		stData.stSuperQQ.bCount  = 1;
		stData.stSuperQQ.list[0] = ulUin;
		send_interface_req(ulUin, ENM_INTERFACE_TYPE_SUPERQQ, &stData, ENM_INTERFACE_FLAG_REQ_TRACE|ENM_INTERFACE_FLAG_RES_TRACE);
	}
	else 
	{
		return -1;
	}
	return 0;
}

int gm_vip(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	LPPLAYER pstPlayer = uin_to_player(pstRole->ulUin);

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!strcasecmp(szTemp, "SetMember"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned char bValue = atoi(szTemp);
		pstPlayer->stExAccInfo.stVip.bMemberLevel = bValue;
		pstPlayer->stExAccInfo.stVip.lMemberLevelUpdateTime  = time(NULL) + VIP_MEMBER_UPDATE_TIME;
		compute_join_vip_level(&pstPlayer->stExAccInfo.stVip);
		reply_vip_info(pstPlayer);
	}
	else if (!strcasecmp(szTemp, "GetMember"))
	{
		system_msg_to_role(pstRole, "Member Level [%d]", get_member_level(pstRole));
	}
	else if (!strcasecmp(szTemp, "SetBlue"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned char bValue = atoi(szTemp);
		pstPlayer->stExAccInfo.stVip.bBlueVip = bValue;
		pstPlayer->stExAccInfo.stVip.lBlueVipUpdateTime  = time(NULL) + VIP_MEMBER_UPDATE_TIME;
		compute_join_vip_level(&pstPlayer->stExAccInfo.stVip);
		reply_vip_info(pstPlayer);
	}
	else if (!strcasecmp(szTemp, "GetBlue"))
	{
		system_msg_to_role(pstRole, "Blue Vip [%d]", get_blue_vip(pstRole));
	}
	else if (!strcasecmp(szTemp, "SetPink"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned char bValue = atoi(szTemp);
		pstPlayer->stExAccInfo.stVip.bPinkLevel = bValue;
		pstPlayer->stExAccInfo.stVip.lPinkLevelUpdateTime  = time(NULL) + VIP_PINK_UPDATE_TIME;
		compute_join_vip_level(&pstPlayer->stExAccInfo.stVip);
		reply_vip_info(pstPlayer);
	}
	else if (!strcasecmp(szTemp, "GetPink"))
	{
		system_msg_to_role(pstRole, "Pink Level [%d]", get_pink_level(pstRole));
	}
	else if (!strcasecmp(szTemp, "SetMonthDonate"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned char bValue = atoi(szTemp);
		pstPlayer->stExAccInfo.stVip.bMonthDonate = bValue;
		pstPlayer->stExAccInfo.stVip.lMonthDonateUpdateTime  = time(NULL) + VIP_MONTH_DONATE_UPDATE_TIME;
	}
	else if (!strcasecmp(szTemp, "GetMonthDonate"))
	{
		system_msg_to_role(pstRole, "Month Donate [%d]", get_role_month_donate(pstRole));
	}
	else if (!strcasecmp(szTemp, "SetSuperQQ"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		unsigned char bValue = atoi(szTemp);
		pstPlayer->stExAccInfo.stVip.bSuperQQ = bValue;
		pstPlayer->stExAccInfo.stVip.lSuperQQUpdateTime = time(NULL) + VIP_SUPERQQ_UPDATE_TIME;
	}
	else if (!strcasecmp(szTemp, "GetSuperQQ"))
	{
		system_msg_to_role(pstRole, "Super QQ [%d]", get_superqq_vip(pstRole));
	}
	else
	{
		return -1;
	}

	return 0;
}

/*
 *@Desc 自定义参数进行宠物属性提升 -- 当前激活宠物
 */
int gm_promotepet(LPROLE pstRole, const char *pszArg)
{
	return 0;
}

/*
 *@Desc 精简客户更新资源 
 */
int gm_reducedclient(LPROLE pstRole, const char *pszArg)
{
	char szTemp[128];
	int  v;

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	LPPLAYER pstPlayer = uin_to_player(pstRole->ulUin);
	CHECK_PARAM_RET(pstPlayer, -1);

	REDUCEDRESOURCE stReducedResource;
	memset(&stReducedResource, 0, sizeof(stReducedResource));

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!strcasecmp(szTemp, "set"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		stReducedResource.bIsReduced = atoi(szTemp);
		do {
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			v = atoi(szTemp);
			if (0 == v) break;
			stReducedResource.resourceID[stReducedResource.iResourceCount++] = v;
		} while(1);		
	
		update_reduced_resource(pstPlayer, &stReducedResource);
	}
	else if (!strcasecmp(szTemp, "show"))
	{
		if (pstPlayer->stReducedResource.bIsReduced)
		{
			system_msg_to_role(pstRole, "Is Reduce Client. resouce count[%d]", pstPlayer->stReducedResource.iResourceCount);
			int i = 0;
			int iOff = 0;
			for (i=0; i<pstPlayer->stReducedResource.iResourceCount; ++i)
			{
				iOff += snprintf(szTemp+iOff,sizeof(szTemp)-iOff, "%d ", pstPlayer->stReducedResource.resourceID[i]);
				if ((i+1)%10 == 0 || i == pstPlayer->stReducedResource.iResourceCount-1)
				{
					system_msg_to_role(pstRole, szTemp);
					iOff = 0;
				}
			}
		}
		else
		{
			system_msg_to_role(pstRole, "Is complete Client.");
		}
	}

	return 0;
}

//老友相关
int gm_old_friend(LPROLE pstRole, const char * pszArg)
{
	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[128] = {0};
	char szTmp[128] = {0};

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (!strcasecmp(szTemp, "set"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (1 == atoi(szTemp))
		{
			set_role_act_event_var(pstRole, MINIGAME_OLD_FRIEND, ACTDATA_PARAM_INDEX_IFOLDFRIEND, OLD_FRIEND);
		}
		else if (0 == atoi(szTemp))
		{
			set_role_act_event_var(pstRole, MINIGAME_OLD_FRIEND, ACTDATA_PARAM_INDEX_IFOLDFRIEND, NON_OLD_FRIEND);
		}
		else
		{
			system_msg_to_role(pstRole, "oldfriend set 0/1 (0:取消老友资格 1:设置老友资格)");
			return -1;
		}
	}
	else if (!strcasecmp(szTemp, "list"))
	{
		unsigned long long ullGID = get_recruiter_gid(pstRole);
		sprintf(szTmp, "%llu", ullGID);
		system_msg_to_role(pstRole, szTmp);
		return 0;
	}
	else if (!strcasecmp(szTemp, "get"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		switch (atoi(szTemp))
		{
			case 0:
			{
				sprintf(szTmp, "%d", check_role_old_friend_type(pstRole));
				break;
			}
			case 1:
			{
				sprintf(szTmp, "%d", get_role_offline_days(pstRole));
				break;
			}
			case 2:
			{
				sprintf(szTmp, "%llu", get_recruiter_gid(pstRole));
				break;
			}
			case 4:
			{
				sprintf(szTmp, "%d", get_recruiter_score(pstRole));
				break;
			}
			case 5:
			{
				sprintf(szTmp, "%d", get_old_friend_num(pstRole, 1));
				break;
			}
			case 6:
			{
				sprintf(szTmp, "%d", get_old_friend_num(pstRole, 2));
				break;
			}
			case 7:
			{
				sprintf(szTmp, "%d", get_old_friend_num(pstRole, 3));
				break;
			}
			case 8:
			{
				sprintf(szTmp, "%d", get_total_old_friend_charming_gain(pstRole));
				break;
			}
			case 9:
			{
				sprintf(szTmp, "%d", get_self_gain_charm(pstRole));
				break;
			}
			case 10:
			{
				sprintf(szTmp, "%d", get_dailycounter_num(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_OTHER_WEEK, OTHER_WEEK_COUNTER_ID_CHARM_GAIN));
				break;
			}
			default:
			{
				system_msg_to_role(pstRole, "oldfriend get/add 0/1/2/4/5/6/7/8/9 value (取或者改变对应数字代表的相关值)");
				return -1;
			}
		}
		system_msg_to_role(pstRole, szTmp);
		return 0;
	}
	else if (!strcasecmp(szTemp, "add"))
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		switch (atoi(szTemp))
		{
			case 0:
			{
				system_msg_to_role(pstRole, "此值只读");
				break;
			}
			case 1:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				add_old_friend_offline_days(pstRole, atoi(szTemp));
				break;
			}
			case 2:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				save_recruiter_gid(pstRole, strtoull(szTemp, NULL, 10));
				break;
			}
			case 4:
			{	
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				add_recruiter_score(pstRole, atoi(szTemp));
				break;
			}
			case 5:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				add_old_friend_num(pstRole, 1, atoi(szTemp));
				add_recruiter_score(pstRole, 1 * atoi(szTemp));
				break;
			}
			case 6:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				add_old_friend_num(pstRole, 3, atoi(szTemp));
				add_recruiter_score(pstRole, 3 * atoi(szTemp));
				break;
			}
			case 7:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				add_old_friend_num(pstRole, 5, atoi(szTemp));
				add_recruiter_score(pstRole, 5 * atoi(szTemp));
				break;
			}
			case 8:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				roll_recruiter_charm(pstRole, atoi(szTemp));
				break;
			}
			case 9:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				roll_self_gain_charm(pstRole, atoi(szTemp));
				break;
			}
			case 10:
			{
				gm_get_val(&pszArg,szTemp,sizeof(szTemp));
				roll_dailycounter_append(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_OTHER_WEEK, OTHER_WEEK_COUNTER_ID_CHARM_GAIN, atoi(szTemp));
				break;
			}
			default:
			{
				system_msg_to_role(pstRole, "oldfriend get/add 0/1/2/4/5/6/7/8/9 value (取或者改变对应数字代表的相关值)");
				return -1;
			}
		}
		return 0;	
	}
	else if (!strcasecmp(szTemp, "help"))
	{
		system_msg_to_role(pstRole, "请正确使用此GM:");
		system_msg_to_role(pstRole, "oldfriend set 0/1 (0:取消老友资格 1:设置老友资格)");
		system_msg_to_role(pstRole, "oldfriend list 招募者GID");
		system_msg_to_role(pstRole, "oldfriend get/add 0/1/2/4/5/6/7/8/9 value (取或者改变对应数字代表的相关值)");
		system_msg_to_role(pstRole, " *0 角色类型(1 //只是未认证的老友 2 //只是已认证的老友 3 //只是招募者 4 //既是未认证的老友又是招募者 5 //既是已认证的老友又是招募者 6 //什么都不是的普通玩家)");
	 	system_msg_to_role(pstRole, "	*1 老友在回归前连续离线天数");
		system_msg_to_role(pstRole, "	*2 招募者GID");
		system_msg_to_role(pstRole, "	*4 招募者召回老友所获得的积分");
		system_msg_to_role(pstRole, "	*5 招募者召回的45-60级老友数");
		system_msg_to_role(pstRole, "	*6 招募者召回的61-75级老友数");
		system_msg_to_role(pstRole, "	*7 招募者召回的76-90级老友数");
		system_msg_to_role(pstRole, "	*8 招募者召回的老友们在回归后所获得的总威望");
		system_msg_to_role(pstRole, "	*9 老友个体在活动开放后所获得的威望");
		system_msg_to_role(pstRole, "	*10 老友本周获得威望");
	}
	else
	{
		system_msg_to_role(pstRole, "oldfriend help");
		return -1;
	}

	return 0;
}

/*
 *@Desc 团购活动GM
 */
int gm_groupbuy(LPROLE pstRole, const char *pszArg)
{
	char szCmd[128];
	char szTemp[128];
	char szInfo[1024];
	int  iItemID = 0;
	int  iNum = 0;

	if(NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	gm_get_val(&pszArg,szCmd,sizeof(szTemp));
	szTemp[0] = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iItemID = atoi(szTemp);
	}
	szTemp[0] = 0;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iNum = atoi(szTemp);
	}

	LPRESGROUPBUYLIST pstThis = NULL;
	LPRESGROUPBUYLIST pstNext = NULL;
	LPCOMMGROUPBUYITEM pstCommGrouBuyItem = NULL;
	get_current_groupbuy_list(&pstThis,&pstNext);
	if(pstThis == NULL)
	{
		return system_msg_to_role(pstRole, "Can not Find This GroupBuy List");
	}
	char chThisGroupRunning = 0;
	int iCurTime = time(NULL);
	if(iCurTime >= pstThis->iOpenTime && iCurTime <= pstThis->iCloseTime)
	{
		chThisGroupRunning = 1;
	}
	SNPRINTF(szInfo,sizeof(szInfo),"-----CurTime[%s]----",currcompactdatetime());
	system_msg_to_role(pstRole, szInfo);
	SNPRINTF(szInfo,sizeof(szInfo),"This GroupBuy[%d] IsRunning[%d]\n"
									"Open[%s] Close[%s]",
									pstThis->iGroupID,chThisGroupRunning,
									pstThis->szOpenTimeStr,pstThis->szCloseTimeStr);
	system_msg_to_role(pstRole, szInfo);
	system_msg_to_role(pstRole, "------------------------------------");
	
	if (!strcasecmp(szCmd, "query"))
	{		
		int i = 0;
		for(i = 0; i < pstThis->chNum; ++i)
		{
			pstCommGrouBuyItem =  get_commdata_groupbuy_item(pstThis->iGroupID,pstThis->astItems[i].iItemID,0);
			snprintf(szInfo,sizeof(szInfo),	"%d) ID[%d] Num[%d] Price[%d] CurJoin[%d]",										
						i,pstThis->astItems[i].iItemID,pstThis->astItems[i].iItemNum,pstThis->astItems[i].iSellPrice,
						(pstCommGrouBuyItem == NULL) ? 0 : pstCommGrouBuyItem->iListNum);
			system_msg_to_role(pstRole, szInfo);									
		}
		
		if(pstNext == NULL)
		{
			return system_msg_to_role(pstRole, "Can not Find Next GroupBuy List");
		}
		
		SNPRINTF(szInfo,sizeof(szInfo),"Next GroupBuy[%d]\n"
										"Open[%s] Close[%s]",pstNext->iGroupID,
										pstNext->szOpenTimeStr,pstNext->szCloseTimeStr);
		system_msg_to_role(pstRole, szInfo);
		for(i = 0; i < pstNext->chNum; ++i)
		{
			snprintf(szInfo,sizeof(szInfo),	"%d) ID[%d] Num[%d] Price[%d]",							
						i,pstNext->astItems[i].iItemID,pstNext->astItems[i].iItemNum,pstNext->astItems[i].iSellPrice);
			system_msg_to_role(pstRole, szInfo);									
		}
	}
	else if (!strcasecmp(szCmd, "setnum"))
	{
		LPGROUPBUYITEM pstResGroupItem = get_groupbuy_item_def_by_id(pstThis,iItemID);
		if(pstResGroupItem == NULL)
		{
			return system_msg_to_role(pstRole, "在本期团购列表中，没有找到该物品信息");
		}
		
		if(chThisGroupRunning == 0)
		{
			return system_msg_to_role(pstRole, "团购活动未开启，不可设置购买人数");
		}
		
		pstCommGrouBuyItem =  get_commdata_groupbuy_item(pstThis->iGroupID,iItemID,1);
		if(pstCommGrouBuyItem == NULL)
		{
			return system_msg_to_role(pstRole, "系统错误，联系开发。");
		}
		if(iNum < 0 || iNum > MAX_GROUPBUY_ITEM_JOINNUM)
		{
			return system_msg_to_role(pstRole, "设置的团购人数必须在0 到 3000之间");
		}
		memset(pstCommGrouBuyItem->memberList + pstCommGrouBuyItem->iListNum,0,
			sizeof(pstCommGrouBuyItem->memberList[0])*(MAX_GROUPBUY_ITEM_JOINNUM - pstCommGrouBuyItem->iListNum));

		pstCommGrouBuyItem->iListNum = iNum;

		SNPRINTF(szInfo,sizeof(szInfo),"GroupID[%d] ItemID[%d] MemberNum Set to [%d]",pstThis->iGroupID,iItemID,iNum);
		log_info_m(LOG_MODULE_GROUPBUY, LOG_WARN, "%s: Role[%u %s] Use SetNum GM for GroupID[%d] ItemID[%d],Member Changeto [%d].", __FUNCTION__,
			pstRole->ulUin,pstRole->szName,pstThis->iGroupID,iItemID,iNum);
		
		system_msg_to_role(pstRole, szInfo);
		
	}
	else if (!strcasecmp(szCmd, "opentime"))
	{
		if(pstRole->ulUin > 10000)
		{
			return system_msg_to_role(pstRole, "本功能危险，只对内网提供");
		}

		if(chThisGroupRunning == 1)
		{
			return system_msg_to_role(pstRole, "本期团购活动正在开启。不可设置。");
		}		

		pstThis->iOpenTime = time(NULL) + iItemID;
		snprintf(szInfo,sizeof(szInfo),	"GoupBuyID[%d] Open after[%d] sec",pstThis->iGroupID,iItemID);
		system_msg_to_role(pstRole, szInfo);

		log_info_m(LOG_MODULE_GROUPBUY, LOG_WARN, "%s: Role[%u %s] Use SetTime GM for GroupID[%d], Time[%d].", __FUNCTION__,
			pstRole->ulUin,pstRole->szName,pstThis->iGroupID,iItemID);
		
	}
	else if (!strcasecmp(szCmd, "reckon"))
	{
		if(chThisGroupRunning == 0)
		{
			return system_msg_to_role(pstRole, "No GroupBuy Act is Running.");
		}

		log_info_m(LOG_MODULE_GROUPBUY, LOG_WARN, "%s: Role[%u %s] Use Reckon GM for GroupID[%d].", __FUNCTION__,
			pstRole->ulUin,pstRole->szName,pstThis->iGroupID);
		
		set_group_buy_state(pstThis->iGroupID, GROUP_BUY_STATE_RECKON);
		
		
	}
	else
	{
		system_msg_to_role(pstRole, "请正确使用GM\0");
		system_msg_to_role(pstRole, "//groupbuy query");
		system_msg_to_role(pstRole, "//groupbuy opentime <Sec>");
		system_msg_to_role(pstRole, "//groupbuy setnum <ItemID> <Num>");
		system_msg_to_role(pstRole, "//groupbuy reckon");
	}

	return 0;
}

//commdata数据清空并初始化
int gm_commdata_reset(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[128] = {0};
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (0 == szTemp[0])
	{
		system_msg_to_role(pstRole, "请慎用此GM指令!!!外网环境用错后果很严重!!!");
		system_msg_to_role(pstRole, "commdatareset appkey(各应用所使用的commdata key值 请向后台同事索取)");
		return -1;
	}
	else
	{	
		LPCOMMDATA pstCommData = commdata_cache_op_get(atoi(szTemp));
		if (NULL == pstCommData)
		{
			return -1;
		}
		if (commdata_init_app_data(pstCommData, atoi(szTemp)))
		{
			return -1;
		}
	}

	return 0;
}

int gm_rentstorage(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[128] = {0};
	
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
    if (!strcasecmp(szTemp, "expire"))
	{
	    gm_get_val(&pszArg,szTemp,sizeof(szTemp));
        char chBagIndex = atoi(szTemp);
	    gm_get_val(&pszArg,szTemp,sizeof(szTemp));
        int t = atoi(szTemp);
		if (chBagIndex < 0 || chBagIndex >= pstRole->stRoleItem.stData.stStorageList.chRentStorageTagCount)
		{
			return -1;
		}
        pstRole->stRoleItem.stData.stStorageList.astRentStorageTags[chBagIndex].lExpiretime = time(NULL) + t;
		system_msg_to_role(pstRole, "设置 第%d页租赁仓库 %d 后过期成功.", chBagIndex, t);

	}

	return 0;
}

int gm_add_xpchange_attr(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	int iXPAttrPillType=0;

	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	if (szTemp[0]) iXPAttrPillType = atoi(szTemp);

	deal_role_attr_pill_point(pstRole, iXPAttrPillType, 1);

	return 0;
}

int gm_del_xpchange_attr(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	unsigned long long ullGID = 0;
	int iXPAttrPillType = -1;
	int iXPAttrPillNum = 0;

	//1:角色GID，0表示自己
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	if (szTemp[0])
	{
		ullGID = strtoull(szTemp, NULL, 10);
	}	

	//2:经验属性丹类型
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	if (szTemp[0])
	{
		iXPAttrPillType = atoi(szTemp);
	}	

	if (0 >= iXPAttrPillType)
	{
		return -1;
	}	

	//3:经验属性丹的使用次数
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	if (szTemp[0])
	{
		iXPAttrPillNum = atoi(szTemp);
	}	

	if (0 == iXPAttrPillNum || abs(iXPAttrPillNum) > XP_ATTR_PILL_MAX_TIMES)
	{
		return -1;
	}	

	LPROLE pstOtherRole = NULL;
	if (0 == ullGID)
	{
		pstOtherRole = pstRole;
	}
	else if	(NULL == (pstOtherRole=gid_to_role(ullGID)))
	{
		return -1;
	}
		
	return deal_role_attr_pill_point(pstOtherRole, iXPAttrPillType, iXPAttrPillNum);
}

int gm_role_tiredmin(LPROLE pstRole, const char *pszArg)
{
	
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	
	int iTiredMin = get_dailycounter_num(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_OTHER, OTHER_COUNTER_ID_TIME_OL_EXCEPT_CITY);
	
	system_msg_to_role(pstRole, "角色疲劳时间为%d分钟.", iTiredMin);

	return 0;
}

//重置神龙殿排行榜
int gm_resetdragonrank(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}
	
	//重置神龙殿排行榜
	reset_god_dragon_rank(NULL);
	return 0;
}

//设置角色记录的指定宝典活动的上次完成时间
int gm_set_bible_act_last_jointime(LPROLE pstRole, const char *pszArg)
{
	#define ONE_DAY_SECONDS 86400
	
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	short nActID = -1;

	//1.提取活动ID
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		nActID = atoi(szTemp);
	}	
	else
	{
		system_msg_to_role(pstRole, "<Usage>://setbibleactjointime ActID DaysBeforeToday");
		return -1;
	}
	
	//2.提取设置的距离今天之前天数
	int iDaysBeforeNow = 0;
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));
	if (szTemp[0])
	{
		iDaysBeforeNow = atoi(szTemp);
	}
	else
	{
		system_msg_to_role(pstRole, "<Usage>://setbibleactjointime ActID DaysBeforeToday");
		return -1;
	}
	
	set_bible_act_last_jointime(pstRole, nActID, time(NULL) - iDaysBeforeNow * ONE_DAY_SECONDS );

	return 0;
}

//答题活动相关GM
int gm_quizact(LPROLE pstRole, const char *pszArg)
{
	#define TMP_QUIZ_SET_RIGHT_NUM 	1 //设置答对题目数
	#define TMP_QUIZ_INFO 			2 //查询答题信息
	#define TMP_QUIZ_SET_RANK_POS	3 //设置指定名次为当前角色 
		
	char szTemp[80];
	
	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//quizact setrightnum <num: 0-100>");
		system_msg_to_role(pstRole, "//quizact info <1:begintime 2:rightnum 3:helptimes>");
		system_msg_to_role(pstRole, "//quizact setrankpos <pos:1-50> <time>");
		return 0;
	}

	short nCmd = -1;
	if (!strncasecmp(szTemp, "setrightnum", sizeof("setrightnum")))
	{
		nCmd = TMP_QUIZ_SET_RIGHT_NUM;
	}
	else if (!strncasecmp(szTemp, "info", sizeof("info")))
	{
		nCmd = TMP_QUIZ_INFO;			
	}
	else if (!strncasecmp(szTemp, "setrankpos", sizeof("setrankpos")))
	{
		nCmd = TMP_QUIZ_SET_RANK_POS;			
	}
		
	int iParam1=-1;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam1 = atoi(szTemp);
	}	

	int iParam2 = -1;
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam2 = atoi(szTemp);
	}

	char szGMMsg[128];
	switch(nCmd)
	{
		case TMP_QUIZ_SET_RIGHT_NUM:
		{
			set_role_quiz_right_num(pstRole, iParam1);
			break;
		}	
		case TMP_QUIZ_INFO:
		{
			int iQuizInfo = get_role_quiz_act_info(pstRole, iParam1);
			snprintf(szGMMsg,sizeof(szGMMsg),"role quiz info type[%d] value[%d].",
				iParam1, iQuizInfo);
			system_msg_to_role(pstRole, szGMMsg);
			break;
		}
		case TMP_QUIZ_SET_RANK_POS:
		{
			int iRet = set_quiz_rank_info_by_pos(pstRole, iParam1, iParam2);
			snprintf(szGMMsg,sizeof(szGMMsg),"role set rank pos result[%d].",
				iRet);
			system_msg_to_role(pstRole, szGMMsg);
			break;
		}
		default:
			return -1;
	}

	return 0;
}

static unsigned int lottery_act_npc_no_2_bitmap(int NPCNoList[], int NPCNum)
{
	unsigned int result=0;
	int i=0;
	for (i=0; i<NPCNum; ++i)
	{
		result |= (0x1 << NPCNoList[i]);
	}

	return result;
}

//抽奖活动相关GM，便于测试
//达人秀活动: 投注NPC ...描述下活动:desc....
int gm_lotteryact(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	
	#define TMP_SIGN_IN_SET_DAY_INFO 	1 	//设置角色指定第几天的签到信息
	#define TMP_LOTTERY_CLEAR_DATA 		2   //强制清除抽奖活动commdata数据
	#define TMP_LOTTERY_SET_RESULT 		3 	//设置本期开奖结果
	#define TMP_LOTTERY_SET_POOL 		4	//设置奖池
	#define TMP_LOTTERY_SET_AWARD 		5 	//设置本服本期指定奖等信息
	#define TMP_LOTTERY_SET_PERIOD 		6 	//设置抽奖活动当前期数
	
	char szTemp[80];
	
	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//lotteryact setsign <dayno: 1-30> <new value: 0 or 1>");
		system_msg_to_role(pstRole, "//lotteryact cleardata");
		system_msg_to_role(pstRole, "//lotteryact setresult <result: npc1 npc2 npc3 npc4 npc5>");
		system_msg_to_role(pstRole, "//lotteryact setpool <zone:1 world:2> <val>");
		system_msg_to_role(pstRole, "//lotteryact setaward <awardLevel> <awardNum> <awardMoney>");
		system_msg_to_role(pstRole, "//lotteryact setperiod <period: 1-4>");
		return 0;
	}

	short nCmd = -1;
	if (!strncasecmp(szTemp, "setsign", sizeof("setsign")))
	{
		nCmd = TMP_SIGN_IN_SET_DAY_INFO;
	}
	else if (!strncasecmp(szTemp, "cleardata", sizeof("cleardata")))
	{
		nCmd = TMP_LOTTERY_CLEAR_DATA;
	}
	else if (!strncasecmp(szTemp, "setresult", sizeof("setresult")))
	{
		nCmd = TMP_LOTTERY_SET_RESULT;
	}
	else if (!strncasecmp(szTemp, "setpool", sizeof("setpool")))
	{
		nCmd = TMP_LOTTERY_SET_POOL;
	}
	else if (!strncasecmp(szTemp, "setaward", sizeof("setaward")))
	{
		nCmd = TMP_LOTTERY_SET_AWARD;
	}
	else if (!strncasecmp(szTemp, "setperiod", sizeof("setperiod")))
	{
		nCmd = TMP_LOTTERY_SET_PERIOD;
	}
	
	#define MAX_LOTTERY_ACT_GM_PARAM 8
	int aiParam[MAX_LOTTERY_ACT_GM_PARAM];
	memset(aiParam, -1, sizeof(aiParam));

	int i=0;
	for (i=0; i< MAX_LOTTERY_ACT_GM_PARAM; ++i)
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] == 0)
		{
			break;
		}	

		aiParam[i] = atoi(szTemp);
	}

	CSMISCLOTTERYC stLotteryC;
	memset(&stLotteryC, 0x00, sizeof(stLotteryC));
	int iRet = -1;
	char szGMMsg[128];
	switch(nCmd)
	{
		case TMP_SIGN_IN_SET_DAY_INFO:
		{
			change_role_sign_info_by_dayno(pstRole, aiParam[0], aiParam[1]);
			return 0;
		}	
		case TMP_LOTTERY_CLEAR_DATA:
		{
			LPACTLOTTERYDATA pstCommData = (LPACTLOTTERYDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_LOTTERY_ACT);
			if (NULL == pstCommData)
			{
				log_info_m(LOG_MODULE_ACT, LOG_WARN, "%s : No Lottery Act Data Get",
						__FUNCTION__);
				return -1;
			}
			pstCommData->iUpdateTime = 0;
			return 0;
		}	
		case TMP_LOTTERY_SET_RESULT:
		{
			int iResult = lottery_act_npc_no_2_bitmap(aiParam, MAX_LOTTERY_BET_NPC);	
			deal_lottery_act_gmset_result(iResult);			
			return 0;
		}
		case TMP_LOTTERY_SET_POOL:
		{
			int iPoolChg = 0;
			if (aiParam[0] == 1)//修改本服DB奖池,外网慎用
			{
				LPACTLOTTERYDATA pstCommData = (LPACTLOTTERYDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_LOTTERY_ACT);
				if (NULL == pstCommData)
				{
					log_info_m(LOG_MODULE_ACT, LOG_WARN, "%s : No Lottery Act Data Get",
						__FUNCTION__);
					return -1;
				}

				iPoolChg = aiParam[1] - pstCommData->iPrizePool;
				pstCommData->iPrizePool = aiParam[1];
			}
			else if (aiParam[0] == 2)//修改本区奖池，前台显示数值
			{
				LPZONELOTTERYMANAGE pstLotteryManage = get_zone_lottery_manage();
				if (NULL == pstLotteryManage)
				{
					log_info_m(LOG_MODULE_ACT, LOG_ERR, "%s : get zone lottery manage failed",
						__FUNCTION__);
					return -1;
				}

				iPoolChg = aiParam[1] - pstLotteryManage->iPrizePool;//本区奖池变化量
			}	
			//同步本服奖池变化量到misc
			syn_lottery_bet_info(iPoolChg);
			return 0;
		}
		case TMP_LOTTERY_SET_AWARD://修改本服指定奖等获奖信息，影响前台显示和领奖，需要在每个zone执行一下
		{
			deal_gmset_lottery_act_award_by_level(pstRole, aiParam[0], aiParam[1], aiParam[2]);
			return 0;
		}
		case TMP_LOTTERY_SET_PERIOD:
		{
			LPACTLOTTERYDATA pstCommData = (LPACTLOTTERYDATA)commdata_cache_op_get(ENM_COMMDATA_KEY_LOTTERY_ACT);
			if (NULL == pstCommData)
			{
				log_info_m(LOG_MODULE_ACT, LOG_WARN, "%s : No Lottery Act Data Get",
					__FUNCTION__);
				return -1;
			}

			if (aiParam[0] < 1 || aiParam[0] > CS_MISC_MAX_LOTTERY_PERIOD)
			{
				return -1;
			}
			pstCommData->bPeriod = aiParam[0] - 1;
			pstCommData->iBetTime = 0;
			return 0;
		}
		default:
			return -1;
	}

	iRet = process_lottery_act_req(pstRole, &stLotteryC);
	snprintf(szGMMsg, sizeof(szGMMsg), "lottery op Ret=%d.", iRet);
	system_msg_to_role(pstRole, szGMMsg);
	return 0;
}


#define TMP_AIRSHIPWAR_ENTER_SCEEN 1
#define TMP_AIRSHIPWAR_SET_CAMP_MEMBERNUM 2
#define TMP_AIRSHIPWAR_RANK_LIST 3 
#define TMP_AIRSHIPWAR_RANK_SHIFT 4 
#define TMP_AIRSHIPWAR_RANK_RESET 5
#define TMP_AIRSHIPWAR_SET_MAX_KILLNUM 6 //设置可以获取经验的全场最大杀人数
int gm_airshipwar(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	short nCmd = 0;
	int iParam1 = -1;
	char szGMMsg[128];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//airshipwar entersceen");
		system_msg_to_role(pstRole, "//airshipwar setcampmembernum <camp max member num>");
		system_msg_to_role(pstRole, "//airshipwar rankshift");
		system_msg_to_role(pstRole, "//airshipwar rankreset");
		system_msg_to_role(pstRole, "//airshipwar ranklist");
		system_msg_to_role(pstRole, "//airshipwar setmaxkillnum <num>");
		return 0;
	}
	
	if(!strncasecmp(szTemp, "entersceen", sizeof("entersceen")))
	{
		nCmd = TMP_AIRSHIPWAR_ENTER_SCEEN;
	}
	else if(!strncasecmp(szTemp, "setcampmembernum", sizeof("setcampmembernum")))
	{
		nCmd = TMP_AIRSHIPWAR_SET_CAMP_MEMBERNUM;
	}
	else if(!strncasecmp(szTemp, "rankshift", sizeof("rankshift")))
	{
		nCmd = TMP_AIRSHIPWAR_RANK_SHIFT;
	}
	else if(!strncasecmp(szTemp, "rankreset", sizeof("rankreset")))
	{
		nCmd = TMP_AIRSHIPWAR_RANK_RESET;
	}
	else if(!strncasecmp(szTemp, "ranklist", sizeof("ranklist")))
	{
		nCmd = TMP_AIRSHIPWAR_RANK_LIST;
	}
	else if(!strncasecmp(szTemp, "setmaxkillnum", sizeof("setmaxkillnum")))
	{
		nCmd = TMP_AIRSHIPWAR_SET_MAX_KILLNUM;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam1 = atoi(szTemp);
	}	
	
	switch(nCmd)
	{
		case TMP_AIRSHIPWAR_ENTER_SCEEN:
			role_enter_airshipwar_pworld(pstRole);
			break;
		case TMP_AIRSHIPWAR_SET_CAMP_MEMBERNUM:
			if(iParam1 > MAX_AIRSHIP_WAR_CAMP_MEMBER || 0 >= iParam1)
			{
				snprintf(szGMMsg,sizeof(szGMMsg),"Set Num[%d] Must Less Than [%d], Set Failed.",
					iParam1, MAX_AIRSHIP_WAR_CAMP_MEMBER);
				return -1;
			}
			set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_AIRSHIPWAR_LIMIT,0,iParam1);
			snprintf(szGMMsg,sizeof(szGMMsg),"Set Camp Max Join AirShip Member In Battle Num To [%d]  Successful.",iParam1);
			log_info_m(LOG_MODULE_SPEC_ACT, LOG_INFO, "%s: GM [%llu %s]  Set AirShipWar Camp Max Join Memerber Num to[%d].", __FUNCTION__,
					pstRole->ullGID,pstRole->szName,iParam1);
			break;
		case TMP_AIRSHIPWAR_RANK_SHIFT:
			shift_airshipwar_rank(NULL, 0);//GM命令不清本月排行数据
			break;
		case TMP_AIRSHIPWAR_RANK_RESET:
			reset_airshipwar_rank(NULL);
			break;
		case TMP_AIRSHIPWAR_RANK_LIST:
			send_airshipwar_rank_msg_to_role(pstRole);
			break;	
		case TMP_AIRSHIPWAR_SET_MAX_KILLNUM:
			if(0 >= iParam1)
			{
				snprintf(szGMMsg,sizeof(szGMMsg),"Set Num[%d] invalid.", iParam1);
				return -1;
			}
			set_hardcode_value_by_id_and_index(SVR_HARDCODE_ID_AIRSHIPWAR_ROUND_RECKON_SETTING,9,iParam1);
			snprintf(szGMMsg,sizeof(szGMMsg),"Set AirShipWar Max KillNum for KillXP To [%d] Successful.",iParam1);
			log_info_m(LOG_MODULE_SPEC_ACT, LOG_INFO, "%s: GM[%llu %s] Set AirShipWar Max KillNum for KillXP To [%d].", __FUNCTION__,
					pstRole->ullGID,pstRole->szName,iParam1);
			break;	
		default:
			return -1;
	}
	return 0;
}

#if 0
#define OPT_PET_2_ARMELITE  1
#define OPT_ARMELITE_REVIVE 2
#define OPT_ARMELITE_MERGE  3
#define OPT_ARMELITE_INSERT 4
#define OPT_ARMELITE_REMOVE 5
#define OPT_ARMELITE_ATTR   6
#define OPT_ARMELITE_SETATTR 7
int armelite_create_pre_scene(LPROLE pstRole, short nCmd)
{
	char arrPreSceneData[5][5][256] = {
		{"Create Pet Err",    "21213031", "22202011", "\0", "\0",}, 
		{"Create Revive Err", "22201010", "22208011", "22201010", "22201010",}, 
		{"Create Merge Err",  "22201010", "22201010", "22207011", "\0",}, 
		{"Create Insert Err", "13320205", "22201010", "22203011", "\0",}, 
		{"Create Remove Err",        "0", "22204011", "\0", "\0",}, 
	};

	gm_clearbag(pstRole, NULL);

	char (*ppCmdList)[256] = arrPreSceneData[nCmd-1];

	char *pErr = ppCmdList[0];

	int index = 1;
	for (index = 1; index < 5; ++index)
	{
		char *pCmd = ppCmdList[index];
		if (0 != strlen(pCmd))
		{
			if(gm_item(pstRole, pCmd) < 0)
			{
				return system_msg_to_role(pstRole, pErr);
			}
		}
	}

	if (OPT_PET_2_ARMELITE == nCmd)
	{
		gm_setlevel(pstRole, "30");

		// 宠物：加载、激活、加经验升级、卸载
		gm_loadpet(pstRole, "1 -1 0 0");
		gm_calluppet(pstRole, "0");
		gm_addpetxp(pstRole, "100000000000");

		gm_strengthenpet(pstRole, "");
		gm_calluppet(pstRole, "0");
		gm_strengthenpet(pstRole, "");
		gm_calluppet(pstRole, "0");
		gm_strengthenpet(pstRole, "");
		gm_calluppet(pstRole, "0");
		gm_strengthenpet(pstRole, "");
		gm_calluppet(pstRole, "0");
		gm_strengthenpet(pstRole, "");
		gm_calluppet(pstRole, "0");
		gm_strengthenpet(pstRole, "");

		gm_unloadpet(pstRole, "1 -1 0 0");
	}

	return 0;
}

static void init_csitemid(LPCSITEMID pstCSItemID, char chType, 
		char chItemIndex, char chNum, char chBagIndex)
{
	if (NULL == pstCSItemID) 
	{
		return;
	}
	pstCSItemID->chType = chType;
	pstCSItemID->chItemIndex = chItemIndex;
	pstCSItemID->chNum = chNum;
	pstCSItemID->chBagIndex = chBagIndex;
}

static LPZONEITEM gm_get_armelite_zoneitem(LPROLE pstRole, LPCSITEMID pstEliteID)
{
	// 取装备精魄物品
	LPZONEITEM pstZoneArmElite = get_zoneitem(pstRole, pstEliteID);

	if (NULL == pstZoneArmElite || CS_RES_ITEM != pstZoneArmElite->chResType)
	{
		log_info_m(LOG_MODULE_ARMELITE, LOG_ERR,
				"%s: error occurred as invoking get_zoneitem for ArmElite.",
				__FUNCTION__);
		return NULL;
	}

	// 取装备精魄资源定义，在接口内部判断其大类、子类
	LPRESARMELITE pstResArmElite = get_armelite_res_by_zoneitem(pstZoneArmElite);
	if (NULL == pstResArmElite)
	{
		log_info_m(LOG_MODULE_ARMELITE, LOG_ERR,
				"%s: Uin[%u] get null pstResArmElite(ResID: %d).",
				__FUNCTION__, pstRole->ulUin, pstZoneArmElite->iResId);
		return NULL;
	}

	return pstZoneArmElite;
}

static int armelite_invoke_pet(LPROLE pstRole)
{
	CSPET2ARMELITEC stCSPet2ArmEliteC;
	init_csitemid(&stCSPet2ArmEliteC.stPetID, CS_LISTTYPE_COMMITEM, 0, 1, 0);
	init_csitemid(&stCSPet2ArmEliteC.stAuxID, CS_LISTTYPE_COMMITEM, 1, 1, 0);

	return armelite_op_pet_2_armelite(pstRole, &stCSPet2ArmEliteC);
}
static int armelite_invoke_revive(LPROLE pstRole)
{
	CSARMELITEREVIVEC stCSArmEliteReviveC;
	init_csitemid(&stCSArmEliteReviveC.stEliteID, CS_LISTTYPE_COMMITEM, 0, 1, 0);
	init_csitemid(&stCSArmEliteReviveC.stAuxID, CS_LISTTYPE_COMMITEM, 1, 1, 0);

	CSARMELITEREVIVES stCSArmEliteReviveS;

	char chAux = armelite_op_revive(pstRole, &stCSArmEliteReviveC, &stCSArmEliteReviveS);
	return chAux;

	init_csitemid(&stCSArmEliteReviveC.stEliteID, CS_LISTTYPE_COMMITEM, 2, 1, 0);
	init_csitemid(&stCSArmEliteReviveC.stAuxID, CS_LISTTYPE_COMMITEM, 3, 1, 0);

	char chElite = armelite_op_revive(pstRole, &stCSArmEliteReviveC, &stCSArmEliteReviveS);

	return (chAux && chElite);
}
static int armelite_invoke_merge(LPROLE pstRole)
{
	CSARMELITEMERGEC stCSArmEliteMergeC;
	init_csitemid(&stCSArmEliteMergeC.stEliteID, CS_LISTTYPE_COMMITEM, 0, 1, 0);
	init_csitemid(&stCSArmEliteMergeC.stMergedEliteID, CS_LISTTYPE_COMMITEM, 1, 1, 0);
	init_csitemid(&stCSArmEliteMergeC.stAuxID, CS_LISTTYPE_COMMITEM, 2, 1, 0);

	LPZONEITEM pstZoneArmElite = gm_get_armelite_zoneitem(pstRole, &stCSArmEliteMergeC.stEliteID);
	if (NULL == pstZoneArmElite)
	{
		return -1;
	}
	LPARMELITEATTRUNIT pstAttr = &pstZoneArmElite->stItemAttr.stItemBaseAttr.stMiscAttr.stArmEliteAttr.stArmEliteAttrUnit; 
	pstAttr->bLevel = 15;
	pstAttr->dwXP = 10000;

	pstZoneArmElite = gm_get_armelite_zoneitem(pstRole, &stCSArmEliteMergeC.stMergedEliteID);
	if (NULL == pstZoneArmElite)
	{
		return -1;
	}
	pstAttr = &pstZoneArmElite->stItemAttr.stItemBaseAttr.stMiscAttr.stArmEliteAttr.stArmEliteAttrUnit; 
	pstAttr->bLevel = 20;
	pstAttr->dwXP = 10000;

	return armelite_op_merge(pstRole, &stCSArmEliteMergeC);
}
static int armelite_invoke_insert(LPROLE pstRole)
{
	return 0;
}
static int armelite_invoke_remove(LPROLE pstRole)
{
	return 0;
}
static int armelite_invoke_attr(LPROLE pstRole)
{
	CSITEMID stEliteID;
	init_csitemid(&stEliteID, CS_LISTTYPE_COMMITEM, 0, 1, 0);

	LPZONEITEM pstZoneArmElite = gm_get_armelite_zoneitem(pstRole, &stEliteID);
	if (NULL == pstZoneArmElite)
	{
		return -1;
	}

	LPARMELITEATTRUNIT pstAttr = &pstZoneArmElite->stItemAttr.stItemBaseAttr.stMiscAttr.stArmEliteAttr.stArmEliteAttrUnit; 

	char szTemp[256];
	snprintf(szTemp, 256, "ArmElite[Level: %d].", pstAttr->bLevel);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[XP: %d].", pstAttr->dwXP);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[Lazy: %d].", pstAttr->wLazy);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[ConstCoef: %d].", pstAttr->bConstCoef);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[LinearCoef: %d].", pstAttr->bLinearCoef);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[bEatTimes: %d].", pstAttr->bEatTimes);
	system_msg_to_role(pstRole, szTemp);
	snprintf(szTemp, 256, "ArmElite[LastEatTime: %s].", stddatetime((time_t)pstAttr->iLastEatTime));
	system_msg_to_role(pstRole, szTemp);
	return 0;
}

static int armelite_invoke_setattr(LPROLE pstRole, int iLevel, int iXP, int iLazy)
{
	CSITEMID stEliteID;
	init_csitemid(&stEliteID, CS_LISTTYPE_COMMITEM, 0, 1, 0);

	LPZONEITEM pstZoneArmElite = gm_get_armelite_zoneitem(pstRole, &stEliteID);
	if (NULL == pstZoneArmElite)
	{
		return -1;
	}

	LPARMELITEATTRUNIT pstAttr = &pstZoneArmElite->stItemAttr.stItemBaseAttr.stMiscAttr.stArmEliteAttr.stArmEliteAttrUnit; 

	if (iLevel > 0 && iLevel <= CS_ARMELITE_MAX_LEVEL)
	{
		pstAttr->bLevel = iLevel;
	}
	/*
	if (iXP >= 0)
	{ 
		int iXPLevelup = get_armelite_xp_need_levelup(pstAttr->bLevel);
		if (iXP <= iXPLevelup)
		{
			pstAttr->dwXP = iXP; 
		}
		else
		{
			pstAttr->dwXP = iXPLevelup;
		}
	}
	*/
	if (iLazy >= 0 && iLazy <= MAX_ARMELITE_LAZY_VALUE)
	{ 
		pstAttr->wLazy = iLazy;
	}

	return 0;
}

int gm_armelite(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	short nCmd = 0;
	//int iParam1 = -1;
	//char szGMMsg[128];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//armelite pet [pre]");
		system_msg_to_role(pstRole, "//armelite revive [pre]");
		system_msg_to_role(pstRole, "//armelite merge [pre]");
		system_msg_to_role(pstRole, "//armelite insert [pre]");
		system_msg_to_role(pstRole, "//armelite remove [pre]");
		system_msg_to_role(pstRole, "//armelite attr");
		system_msg_to_role(pstRole, "//armelite setattr Level XP Lazy");
		return 0;
	}
	
	if (!strncasecmp(szTemp, "pet", sizeof("pet")))             nCmd = OPT_PET_2_ARMELITE;
	else if (!strncasecmp(szTemp, "revive", sizeof("revive")))  nCmd = OPT_ARMELITE_REVIVE;
	else if (!strncasecmp(szTemp, "merge", sizeof("merge")))    nCmd = OPT_ARMELITE_MERGE;
	else if (!strncasecmp(szTemp, "insert", sizeof("insert")))  nCmd = OPT_ARMELITE_INSERT;
	else if (!strncasecmp(szTemp, "remove", sizeof("remove")))  nCmd = OPT_ARMELITE_REMOVE;
	else if (!strncasecmp(szTemp, "attr", sizeof("attr")))      nCmd = OPT_ARMELITE_ATTR;
	else if (!strncasecmp(szTemp, "setattr", sizeof("setattr")))      nCmd = OPT_ARMELITE_SETATTR;

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		if (!strncasecmp(szTemp, "pre", sizeof("pre")))
		{
			if (0 != armelite_create_pre_scene(pstRole, nCmd) || 
				OPT_ARMELITE_ATTR == nCmd ||
				OPT_ARMELITE_SETATTR == nCmd)
			{
				return -1;
			}
			else
			{
				return 0;
			}
		}
	}

	typedef int (*PFNARMELITEINVOKEE)(LPROLE pstRole);
	static PFNARMELITEINVOKEE ls_pfnArmEliteFuncList[OPT_ARMELITE_ATTR] =
	{
		armelite_invoke_pet,
		armelite_invoke_revive,
		armelite_invoke_merge,
		armelite_invoke_insert,
		armelite_invoke_remove,
		armelite_invoke_attr,
	};

	if (OPT_ARMELITE_SETATTR == nCmd)
	{
		int iLevel = 0;
		int iXP = 0;
		int iLazy = 0;

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0) { iLevel = atoi(szTemp); }

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0) { iXP = atoi(szTemp); }

		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0) { iLazy = atoi(szTemp); }

		return armelite_invoke_setattr(pstRole, iLevel, iXP, iLazy);
	}
	else
	{
		return (ls_pfnArmEliteFuncList[nCmd - 1])(pstRole);
	}

	return -1;
}
#endif

int gm_lover_day(LPROLE pstRole, const char *pszArg)
{
	if(NULL == pstRole)
	{
		return -1;
	}

	char szTmp[128];
	char szMsg[1024];

	gm_get_val(&pszArg, szTmp, sizeof(szTmp));

	if (!szTmp[0])
	{
		return -1;
	}

	if(!strncasecmp(szTmp, "qq", sizeof("qq")))
	{
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
	
		if (!szTmp[0])
		{
			return -1;
		}
		unsigned int ulUin = atoll(szTmp);
		LPROLE pstTargetRole = uin_to_role(ulUin);
		if(NULL == pstTargetRole)
		{
			system_msg_to_role(pstRole, "目标不在线");
			return -1;
		}
		gm_get_val(&pszArg, szTmp, sizeof(szTmp));
		if (!szTmp[0])
		{
			return -1;
		}
		int iVal = atoi(szTmp);
		gm_get_val(&pszArg,szTmp,sizeof(szTmp));
		if(!szTmp[0])
		{
			return -1;
		}
		if(!strncasecmp(szTmp, "vote", sizeof("vote")))
		{
			if (0 == iVal)
			{
				sprintf(szMsg, "Role[name=%s gid=%llu] vote : %d.", 
						pstTargetRole->szName, pstTargetRole->ullGID, get_lover_day_role_vote(pstTargetRole));
				return	system_msg_to_role(pstRole, szMsg);
			}
			return add_lover_day_role_vote(pstTargetRole, iVal);
		}
	}
	else if(!strncasecmp(szTmp, "rank", sizeof("rank")))
	{
		LPACTLOVERDAYDATA pstLoverDayData = get_lover_day_comm_act_data();
		if (NULL == pstLoverDayData)
		{
			return -1;
		}

		sprintf(szMsg, "rank num : %d", pstLoverDayData->nNum);
		system_msg_to_role(pstRole, szMsg);

		int i = 0;
		for ( ; i < pstLoverDayData->nNum ; i++ )
		{
			sprintf(szMsg, "%d : name=%s gid=%"PRIu64" vote=%d", 
					i+1, 
					pstLoverDayData->astRankData[i].szName,
					pstLoverDayData->astRankData[i].ullGID,
					pstLoverDayData->astRankData[i].iVote);
			system_msg_to_role(pstRole, szMsg);
		}
		return 0;

	}

	return 0;
}

int get_if_permit_non_gm_login(void)
{
	return gs_iIfPermitNonGMLogin;
}

/*
 *@Desc:幻世VIP相关指令集
 */
int gm_wofvip(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[128];
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if (0 == szTemp[0])
	{
		return -1;
	}
	else if (!strncasecmp(szTemp, "renewal", sizeof("renewal")))//续期
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));

		int iDay = atoi(szTemp);

		renewal_role_wof_vip(pstRole, iDay*86400);
		
		return 0;
	}
	else if (!strncasecmp(szTemp, "acce", sizeof("acce")))//活动替身加速
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if (0 == szTemp[0])
		{
			return -1;
		}

		int iActID = atoi(szTemp);

		CSACCEC stCSAcceC;
		stCSAcceC.nActID = iActID;

		wof_vip_handle_acce(pstRole, &stCSAcceC);

		return 0;
	}
	else if (!strncasecmp(szTemp, "goldcoin", sizeof("goldcoin")))//加小金币
	{
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		
		int iGoldCoin = atoi(szTemp);
		
		int iCurr = get_dailycounter_num(&pstRole->stDailyCounter, 
			ENM_COUNTER_TYPE_WOF_VIP, WOF_VIP_COUNTER_ID_GOLD_COIN);
		if (0 <= iCurr)
		{
			iCurr += iGoldCoin;
			if (0 >= iCurr)
			{
				iCurr = -1;
			}
		}
		else
		{
			if (0 >= iGoldCoin)
			{
				iCurr = -1;
			}
		}
		
		set_dailycounter_num(&pstRole->stDailyCounter, ENM_COUNTER_TYPE_WOF_VIP, 
			WOF_VIP_COUNTER_ID_GOLD_COIN, iCurr);

		send_wof_vip_gold_coin(pstRole);

		return 0;
	}
	else
	{
		return -1;
	}

	return 0;
}


#define TMP_MARRY_MAKE_COUPLE 1 		//结为夫妻关系,不检查条件
#define TMP_MARRY_CLEAR_FLOW_DATA 2 	//清除自身婚礼流程数据
#define TMP_MARRY_ADD_LOVE_VALUE 3 		//增加恩爱值
#define TMP_MARRY_SET_AUCTION_TIMES 4 	//设置结婚场景竞拍次数
#define TMP_MARRY_RESET_PARADE_TIME 5 	//重置婚礼游行时间
#define TMP_MARRY_RESET_MARRY_DATA 6	//重置结婚数据
#define TMP_MARRY_REGISTER_NUM 7 		//查看或修改每日结婚对数
#define TMP_MARRY_BID_MARRY_TIME 8      //直接让二人竞拍结婚时间成功
int gm_marry(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	/*提取操作对象*/
	char szGMMsgTemp[80];
	LPROLE pstDestRole = gm_extract_target_role(&pszArg, NULL);
	if (NULL != pstDestRole)
	{
		snprintf(szGMMsgTemp,sizeof(szGMMsgTemp),"GM[%s] Operate to Role[%u %s %u]",pstRole->szName,
			pstDestRole->ulUin,pstDestRole->szName,pstDestRole->stObject.ulID);
		system_msg_to_role(pstRole, szGMMsgTemp);
	}
	else
	{
		pstDestRole = pstRole;
	}

	char szTemp[80];
	short nCmd = 0;
	int iNum = -1;
	char szMsg[128];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//marry makecouple <qq1> <qq2>");
		system_msg_to_role(pstRole, "//marry clearflowdata");
		system_msg_to_role(pstRole, "//marry addlovevalue <num>");
		system_msg_to_role(pstRole, "//marry setauctiontimes <num>");
		system_msg_to_role(pstRole, "//marry resetparadetime <time>");
		system_msg_to_role(pstRole, "//marry resetmarrydata");
		system_msg_to_role(pstRole, "//marry registernum <num>");
		system_msg_to_role(pstRole, "//marry bidmarrytime <time> <price> <qq>");
		
		return 0;
	}
	
	if(!strncasecmp(szTemp, "makecouple", sizeof("makecouple")))
	{
		nCmd = TMP_MARRY_MAKE_COUPLE;
	}
	else if(!strncasecmp(szTemp, "clearflowdata", sizeof("clearflowdata")))
	{
		nCmd = TMP_MARRY_CLEAR_FLOW_DATA;
	}
	else if(!strncasecmp(szTemp, "addlovevalue", sizeof("addlovevalue")))
	{
		nCmd = TMP_MARRY_ADD_LOVE_VALUE;
	}
	else if(!strncasecmp(szTemp, "registernum", sizeof("registernum")))
	{
		nCmd = TMP_MARRY_REGISTER_NUM;
	}
	else if(!strncasecmp(szTemp, "setauctiontimes", sizeof("setauctiontimes")))
	{
		nCmd = TMP_MARRY_SET_AUCTION_TIMES;
	}
	else if(!strncasecmp(szTemp, "resetparadetime", sizeof("resetparadetime")))
	{
		nCmd = TMP_MARRY_RESET_PARADE_TIME;
	}
	else if(!strncasecmp(szTemp, "resetmarrydata", sizeof("resetmarrydata")))
	{
		nCmd = TMP_MARRY_RESET_MARRY_DATA;
	}
	else if(!strncasecmp(szTemp, "bidmarrytime", sizeof("bidmarrytime")))
	{
		nCmd = TMP_MARRY_BID_MARRY_TIME;
	}
	
	switch(nCmd)
	{
		case TMP_MARRY_BID_MARRY_TIME://直接让二人竞拍结婚时间成功
		{
			int iTime = 0;
			int iPrice = 0;
			unsigned int ulTargetUin = 0;
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iTime = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry bidmarrytime <time> <price> <qq>");
				return -1;
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iPrice = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry bidmarrytime <time> <price> <qq>");
				return -1;
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				ulTargetUin = atoll(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry bidmarrytime <time> <price> <qq>");	
				return -1;
			}
			
			LPROLE pstTargetRole = uin_to_role(ulTargetUin);
			if (NULL == pstTargetRole)
			{
				return -1;
			}
			else
			{
				//竞拍数据是否已从DB拉取到
				LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_MARRY_AUCTION);
				if (NULL == pstCommData)
				{
					return -1;
				}
				//取当日的竞拍数据
				LPSINGLEDAYAUCTIONDATA pstSingleDayAuctionData = 
									&pstCommData->stMarryAuction.astAuctionData
									[(iTime / SINGLE_DAY_SECONDS) % MARRY_AUCTION_MAX_RECORD_DAY_NUM];
				if (pstSingleDayAuctionData->bRankNum >= MARRY_AUCTION_TOP_NUM)
				{
					log_info_m(LOG_MODULE_MARRY, LOG_ERR, 
						"%s:marry auction num is full when gm insert new.", __FUNCTION__);
					return -1;
				}
				
				//将自己插入
				AUCTIONPRICEDATA stAuctionPriceData;
				memset(&stAuctionPriceData, 0, sizeof(stAuctionPriceData));
				stAuctionPriceData.dwBid = iPrice;
				stAuctionPriceData.iBidTime = _cur_tick_time();
				stAuctionPriceData.ullGID = pstTargetRole->ullGID;
				stAuctionPriceData.ullMateGID = pstTargetRole->stMarryInfo.ullMateGID;
				STRNCPY(stAuctionPriceData.szName, pstTargetRole->szName, sizeof(stAuctionPriceData.szName));
				STRNCPY(stAuctionPriceData.szMateName, pstTargetRole->stMarryInfo.szMateName, sizeof(stAuctionPriceData.szMateName));
				
				int iRankNum = pstSingleDayAuctionData->bRankNum;
				int iRet = my_binsert(&stAuctionPriceData, pstSingleDayAuctionData->astRankData, &iRankNum, (int)sizeof(AUCTIONPRICEDATA), 0, cmp_marry_bid);
				if (0 != iRet)
				{
					return -1;
				}
				pstSingleDayAuctionData->bRankNum = iRankNum;

				pstSingleDayAuctionData->dwIndex = iTime / SINGLE_DAY_SECONDS;
			}
			break;
		}
		case TMP_MARRY_MAKE_COUPLE:
		{
			unsigned int ulSourceUin = 0;
			unsigned int ulTargetUin = 0;
			
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				ulSourceUin = atoll(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry makecouple <qq1> <qq2>");
				return -1;
			}
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				ulTargetUin = atoll(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry makecouple <qq1> <qq2>");	
				return -1;
			}
			
			LPROLE pstTargetRole = uin_to_role(ulTargetUin);
			LPROLE pstSourceRole = uin_to_role(ulSourceUin);
			if (NULL == pstTargetRole || NULL == pstSourceRole)
			{
				return -1;
			}
			else
			{
				make_couple(pstTargetRole, pstSourceRole);
				
				CSMARRYS stMarryS;
				stMarryS.bOp = MARRY_OP_TYPE_REGISTER;
				stMarryS.nEno = CS_CODE_NOERR;
				stMarryS.stData.stMarryRegister.chType = MARRY_OP_TYPE_REGISTER_RESULT;
				stMarryS.stData.stMarryRegister.stData.stResult = pstTargetRole->stMarryInfo;
				int iRet = reply_server_pkg(pstTargetRole->ulUin, CS_CMD_MARRY, (void*)&stMarryS);
				if (0 != iRet)
				{
					log_info_m(LOG_MODULE_MARRY, LOG_ERR, "%s: send choose pkg to Uin[%u] failed.", __FUNCTION__, pstTargetRole->ulUin);
				}
				stMarryS.stData.stMarryRegister.stData.stResult = pstSourceRole->stMarryInfo;
				iRet = reply_server_pkg(pstSourceRole->ulUin, CS_CMD_MARRY, (void*)&stMarryS);
				if (0 != iRet)
				{
					log_info_m(LOG_MODULE_MARRY, LOG_ERR, "%s: send choose pkg to Uin[%u] failed.", __FUNCTION__, pstSourceRole->ulUin);
				}
			}
			break;
		}
		case TMP_MARRY_CLEAR_FLOW_DATA:
		{
			clear_marry_act_data(pstDestRole);
			break;
		}	
		case TMP_MARRY_ADD_LOVE_VALUE:
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iNum = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry addlovevalue <num>");
				return -1;
			}

			chg_role_love_value(pstDestRole, iNum, 0, 1);//修改姻缘值，通知前台
			break;
		}	
		case TMP_MARRY_SET_AUCTION_TIMES:
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iNum = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry setauctiontimes <num>");
				return -1;
			}

			pstDestRole->stMarryInfo.bAuctionTimes = iNum;
			break;
		}
		case TMP_MARRY_RESET_PARADE_TIME:
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iNum = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstRole, "//marry resetparadetime <time>");
				return -1;
			}

			LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_GLOBAL_SVR_VAR);
			if (NULL == pstCommData)
			{
				log_info_m(LOG_MODULE_MARRY, LOG_ERR, "%s: get global svr var commdata failed by key[%d]", __FUNCTION__, ENM_COMMDATA_KEY_GLOBAL_SVR_VAR);
				return -1;
			}
			pstCommData->stGlobalSvrVar.iMarryParadeTime = 0;
			break;
		}
		case TMP_MARRY_RESET_MARRY_DATA:
		{
			memset(&pstDestRole->stMarryInfo, 0, sizeof(pstDestRole->stMarryInfo));//初始化角色的婚姻数据
			break;
		}
		case TMP_MARRY_REGISTER_NUM:
		{
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if (szTemp[0])
			{
				iNum = atoi(szTemp);
			}
			else
			{
				system_msg_to_role(pstDestRole, "//marry registernum <num>");
				return -1;
			}

			LPCOMMDATA pstCommData = commdata_cache_op_get(ENM_COMMDATA_KEY_GLOBAL_SVR_VAR);
			if (NULL == pstCommData)
			{
				log_info_m(LOG_MODULE_MARRY, LOG_ERR, "%s: get global svr var commdata failed by key[%d]", __FUNCTION__, ENM_COMMDATA_KEY_GLOBAL_SVR_VAR);
				return -1;
			}

			if (0 < iNum)
			{
				pstCommData->stGlobalSvrVar.iMarrySuccNum += iNum;
				pstCommData->stGlobalSvrVar.iMarrySuccNumTime = _cur_tick_time();
			}
			
			snprintf(szMsg, sizeof(szMsg), "marry succ num today change to %d ok", get_marry_succ_num_today());
			system_msg_to_role(pstDestRole, szMsg);
			break;
		}
		default:
			return -1;
	}
	return 0;
}

int gm_raffle(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if (!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//raffle get [offset]");
		system_msg_to_role(pstRole, "//raffle all");
		system_msg_to_role(pstRole, "//raffle award");
		return 0;
	}
	else if (!strncasecmp(szTemp, "get", sizeof("pet")))
	{
		int offset = 0;
		gm_get_val(&pszArg,szTemp,sizeof(szTemp));
		if(szTemp[0] != 0) { offset = atoi(szTemp); }
		else { return -1; } 

		CSRAFFLEC stRaffleC;
		stRaffleC.bRaffleID = 1;
		stRaffleC.chType = ENM_RAFFLE_OP_OPEN_GRID;
		stRaffleC.chGridOffset = offset;
		process_raffle_op_cmd(pstRole, &stRaffleC);
		return 0;
	}
	else if (!strncasecmp(szTemp, "all", sizeof("all")))
	{
		CSRAFFLEC stRaffleC;
		stRaffleC.bRaffleID = 1;
		stRaffleC.chType = ENM_RAFFLE_OP_GET_ALL_GRID;
		process_raffle_op_cmd(pstRole, &stRaffleC);
		return 0;
	} 
	else if (!strncasecmp(szTemp, "award", sizeof("award")))
	{
		CSRAFFLEC stRaffleC;
		stRaffleC.bRaffleID = 1;
		stRaffleC.chType = ENM_RAFFLE_OP_GET_FINAL_AWARD;
		process_raffle_op_cmd(pstRole, &stRaffleC);
		return 0;
	}

	return -1;
}

int gm_equipsoul(LPROLE pstRole, const char * pszArg)
{
	return -1;
}

static void init_csitemid(LPCSITEMID pstCSItemID, char chType, char chItemIndex, char chNum, char chBagIndex)
{
	if (NULL == pstCSItemID)
	{
		return;
	}
	pstCSItemID->chType = chType;
	pstCSItemID->chItemIndex = chItemIndex;
	pstCSItemID->chNum = chNum;
	pstCSItemID->chBagIndex = chBagIndex;
}

int gm_armrefine(LPROLE pstRole, const char *pszArg)
{
	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}

	if (!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//armrefine help");
		system_msg_to_role(pstRole, "//armrefine pre");
		system_msg_to_role(pstRole, "//armrefine go");
		return 0;
	}
	else if (!strncasecmp(szTemp, "pre", sizeof("pre")))
	{
		gm_clearbag(pstRole, NULL);
		char *pArmCmd = "16000037";
		if (gm_item(pstRole, pArmCmd) < 0)
		{
			system_msg_to_role(pstRole, "Arm Create Failed");
			return -1;
		}
		char *pCharmCmd = "20738399";
		if (gm_item(pstRole, pCharmCmd) < 0)
		{
			system_msg_to_role(pstRole, "Charm Create Failed");
			return -1;
		}
		return 0;
	}
	else if (!strncasecmp(szTemp, "go", sizeof("go")))
	{
		BENCHTIME stBenchTime;
		struct timeval stCltTime;

		CSLISTUSE stUseC;

		CSITEMID stArmItemID;
		init_csitemid(&stArmItemID, CS_LISTTYPE_COMMITEM, 0, 1, 0);

		stUseC.chType = CS_LISTTYPE_COMMITEM;
		stUseC.chBagIndex = 1;
		stUseC.chItemIndex = 1;
		stUseC.chExtFlag = CS_LISTUSEEXT_USE_FOR_ROLE_ITEM;
		stUseC.stExtInfo.stItemPos = stArmItemID;

		use_item(&stBenchTime, &stCltTime, pstRole, &stUseC);

		return 0;
	}

	return -1;
}

int gm_rewardtoken(LPROLE pstRole, const char *pszArg)
{
#define TMP_REWARD_TOKEN_ACCE 1
#define TMP_REWARD_TOKEN_RESET 2 

	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	short nCmd = 0;
	int iParam1 = -1;
	//char szGMMsg[128];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//rewardtoken acce");
		system_msg_to_role(pstRole, "//rewardtoken reset");
		return 0;
	}
	
	if(!strncasecmp(szTemp, "acce", sizeof("acce")))
	{
		nCmd = TMP_REWARD_TOKEN_ACCE;
	}
	else if(!strncasecmp(szTemp, "reset", sizeof("reset")))
	{
		nCmd = TMP_REWARD_TOKEN_RESET;
	}
	

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam1 = atoi(szTemp);
	}	

	CSREWARDTOKENC stRewardTokenC;
	
	switch(nCmd)
	{
		case TMP_REWARD_TOKEN_ACCE:
			stRewardTokenC.bOp = ENM_REWARD_TOKEN_OP_ACCE;
			stRewardTokenC.stData.chAcceMode = iParam1;
			process_reward_token_req(pstRole, &stRewardTokenC);
			break;
		case TMP_REWARD_TOKEN_RESET:
			stRewardTokenC.bOp = ENM_REWARD_TOKEN_OP_RESET;
			process_reward_token_req(pstRole, &stRewardTokenC);
			break;
		default:
			return -1;
	}
	return 0;
}

int gm_hpmpcontainer(LPROLE pstRole, const char *pszArg)
{
#define TMP_SET_CUR_RESERVE 1

	if (NULL == pstRole || NULL == pszArg)
	{
		return -1;
	}

	char szTemp[80];
	short nCmd = 0;
	int iParam1 = -1;
	int iParam2 = -1;
	//char szGMMsg[128];

	//读取子命令
	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(!szTemp[0])
	{
		return -1;
	}
	
	if(!strncasecmp(szTemp, "help", sizeof("help")))
	{
		system_msg_to_role(pstRole, "//hpmpcontainer setreserve <type:101 hp 102 mp 103 pethp 104 petmp> <value>");
		return 0;
	}
	
	if(!strncasecmp(szTemp, "setreserve", sizeof("setreserve")))
	{
		nCmd = TMP_SET_CUR_RESERVE;
	}
	else
	{
		return -1;
	}

	gm_get_val(&pszArg,szTemp,sizeof(szTemp));
	if(szTemp[0] != 0)
	{
		iParam1 = atoi(szTemp);
	}	

	switch(nCmd)
	{
		case TMP_SET_CUR_RESERVE:
			gm_get_val(&pszArg,szTemp,sizeof(szTemp));
			if(szTemp[0] != 0)
			{
				iParam2 = atoi(szTemp);
			}	
			return set_hpmp_container_reserve_by_attr_type(pstRole,iParam1,iParam2);
		default:
			return -1;
	}
	return 0;
}

int gm_setgm(LPROLE pstRole,const char *pszArg)
{

	if(pstRole == NULL)
	{
		return -1;
	}


#ifdef DEV_BUILD  

	char szTemp[128];
	gm_get_val(&pszArg, szTemp, sizeof(szTemp));

	unsigned int ulUin =  atoll(szTemp);

	if(ulUin <= 10000) 
	{

		system_msg_to_role(pstRole,"setgm qq number must be bigger than 10000");
		return -1;
	}	

	if(pstRole->ulUin != 4199)
	{
		system_msg_to_role(pstRole,"you must be 4199 ,when you execute this cmd.");
		return -1;
	}

	LPROLE pstTargetRole = uin_to_role(ulUin);
	if(pstTargetRole != NULL)
	{
		pstTargetRole->bGMPower = GM_ROLE_FIRST;
		log_info(LOG_ERR,"%s:4199 set :%u gm power",__FUNCTION__,ulUin);
		return 0;
	}
#endif
	return -1;	
}


